[[chap19]]
== Extra: Sintaxis

Uno de los objetivos de este libro es ense帽arle lo justo y necesario de Julia. Se explica una sola forma de hacer las cosas y, en ocasiones, se deja como ejercicio al lector una segunda manera.

Ahora se ver谩n algunos temas que se han dejado de lado pero que son 煤tiles. Julia proporciona una serie de caracter铆sticas que no son realmente necesarias (se puede escribir un buen c贸digo sin ellas), pero a veces permiten escribir un c贸digo m谩s conciso, legible y/o eficiente.

En este cap铆tulo y el siguiente se discute aquello que se ha omitido en los cap铆tulos anteriores:

* m谩s sintaxis
* funciones, tipos y macros disponibles directamente de +Base+ 
(((Base)))
* funciones, tipos y macros de la Biblioteca Est谩ndar (Standard Library)
(((Biblioteca Est谩ndar)))

=== Tuplas con nombre

Es posible colocarle nombre a los componentes de una tupla, creando una tupla con nombre:

[source,@julia-repl-test]
----
julia> x = (a=1, b=1+1)
(a = 1, b = 2)
julia> x.a
1
----

En las tuplas con nombre se puede acceder a los atributos con su nombre utilizando la sintaxis de punto +(x.a)+.
(((tupla con nombre)))(((sintaxis de punto)))


=== Funciones

Las funciones en Julia tambi茅n se pueden definir mediante una sintaxis compacta, de la siguiente forma:

[source,@julia-repl-test]
----
julia> f(x,y) = x + y
f (generic function with 1 method)
----

[[anonymous_functions]]
==== Funciones Anonimas

Podemos definir una funci贸n sin especificar su nombre:

[source,@julia-repl-test]
----
julia> x -> x^2 + 2x - 1
#1 (generic function with 1 method)
julia> function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)
----

Estos son ejemplos de _funciones an贸nimas_. Las funciones an贸nimas generalmente se usan como argumento de otra funci贸n:
(((funci贸n an贸nima)))(((Plots)))((("m贸dulo", "Plots", v茅ase "Plots")))(((plot)))((("funci贸n", "Plots", "graficar", v茅ase "graficar")))

[source,jlcon]
----
julia> using Plots

julia> plot(x -> x^2 + 2x - 1, 0, 10, xlabel="x", ylabel="y")

----

<<fig19-1>> muestra el resultado del comando plot (graficar en ingl茅s).

[[fig19-1]]
.Plot
image::images/fig191.svg[pdfwidth="10cm"]

==== Argumentos con nombre

Tambi茅n se puede poner nombre a los argumentos de una funci贸n:

[source,@julia-repl-test]
----
julia> function migrafico(x, y; style="continua", width=1, color="negro")
           ###
       end
migrafico (generic function with 1 method)
julia> migrafico(0:10, 0:10, style="dotted", color="blue")

----

Los _argumentos con nombre_ en una funci贸n se especifican despu茅s de un punto y coma en la especificaci贸n, pero al llamar a la funci贸n se pueden utilizar solo comas.
(((;)))(((argumentos con nombre)))

==== Clausuras

Una _clausura_ es una t茅cnica que permite que una funci贸n capture una variable definida fuera del 谩mbito de la funci贸n.

[source,@julia-repl-test]
----
julia> foo(x) = ()->x
foo (generic function with 1 method)

julia> bar = foo(1)
#1 (generic function with 1 method)

julia> bar()
1
----

En este ejemplo, la funci贸n +foo+ devuelve una funci贸n an贸nima que tiene acceso al argumento +x+ de la funci贸n +foo+. +bar+ apunta a la funci贸n an贸nima y devuelve el valor del argumento de +foo+.


=== Bloques

Un _bloque_ es una forma de agrupar varias sentencias. Un bloque comienza con la palabra reservada +begin+ y termina con +end+.
(((begin)))((("palabra reservada", "begin")))(((end)))(((bloque)))

En <<chap04>> se present贸 la macro +@svg+:

[source,julia]
----
 = Turtle()
@svg begin
    forward(, 100)
    turn(, -90)
    forward(, 100)
end
----

En este ejemplo, la macro +@svg+ tiene un 煤nico argumento: un bloque, que agrupa 3 llamadas a funciones.

==== Bloques +let+ 

Un bloque +let+ es 煤til para crear nuevas ligaduras (o bindings), es decir, variables locales que pueden apuntar a valores.

[source,@julia-repl-test]
----
julia> x, y, z = -1, -1, -1;

julia> let x = 1, z
           @show x y z;
       end
x = 1
y = -1
ERROR: UndefVarError: z not defined
julia> @show x y z;
x = -1
y = -1
z = -1
----

En el ejemplo, la primera macro +@show+ muestra la variable local +x+, la variable global +y+ y la variable local indefinida +z+. Las variables globales se mantienen intactas.


==== Bloques +do+

En <<reading_and_writing>> se cierra el archivo despu茅s de terminar de escribir en 茅l. Esto se puede hacer autom谩ticamente usando un _Bloque do_:
(((do)))((("palabra reservada", "do")))

[source,@julia-repl-test chap19]
----
julia> datos = "El Cid convoca a sus vasallos;\n茅stos se destierran con 茅l.\n"
"El Cid convoca a sus vasallos;\n茅stos se destierran con 茅l.\n"
julia> open("salida.txt", "w") do fout
           write(fout, datos)
       end
61
----

En este ejemplo, +fout+ es el archivo stream utilizado para la salida.

Esto es equivalente a:

[source,@julia-repl-test chap19]
----
julia> f = fout -> begin
           write(fout, datos)
       end
#3 (generic function with 1 method)
julia> open(f, "salida.txt", "w")
61
----

La funci贸n an贸nima se utiliza como primer argumento de la funci贸n +open+:
(((open)))

[source,julia]
----
function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end
----

Un bloque +do+ puede "capturar" variables de su 谩mbito envolvente (enclosed scope). Por ejemplo, la variable +datos+ en el ejemplo anterior de +open pass:[...] do+ es capturada desde el 谩mbito externo. 


=== Estructuras de control

==== Operador ternario

El _operador ternario_, +?:+, puede utilizarse en vez de una sentencia +if-elseif+. Esta sentencia se usa cuando se necesita elegir entre diferentes expresiones con valor 煤nico.
(((?:)))((("operador", "Base", "?:", v茅ase "?:")))((("operador ternario", v茅ase "?:")))

[source,@julia-repl-test]
----
julia> a = 150
150
julia> a % 2 == 0 ? println("par") : println("impar")
par
----

La expresi贸n que va antes de +?+ es una expresi贸n de condici贸n. Si la condici贸n es +true+, se eval煤a la expresi贸n que va antes de +:+. De lo contrario, se eval煤a la expresi贸n que va despu茅s de +:+.

==== Evaluaci贸n de cortocircuito

Los operadores +&&+ y +||+ realizan una _evaluaci贸n de cortocircuito_, es decir, se eval煤a el siguiente argumento solo cuando es necesario para determinar el valor final.
(((&&)))(((||)))(((evaluaci贸n de cortocircuito)))

Por ejemplo, una funci贸n factorial recursiva podr铆a definirse as铆:
(((fact)))

[source,@julia-setup]
----
function fact(n::Integer)
    n >= 0 || error("n debe ser no negativo")
    n == 0 && return 1
    n * fact(n-1)
end
----

==== Tarea (o Corrutina)

Una _tarea_ es una estructura de control que puede ceder el control de forma cooperativa sin hacer return. En Julia, una tarea puede implementarse como una funci贸n con un objeto +Channel+ como primer argumento. Se usa un channel para pasar valores de la funci贸n a la sentencia que la llama.

El t茅rmino "cooperativo" alude a que los programas deben cooperar para que todo el esquema de programaci贸n funcione.

La secuencia de Fibonnaci se puede generar mediante una tarea.
(((tarea)))(((Channel)))((("tipo", "Base", "Channel", v茅ase "Channel")))(((put!)))((("funci贸n", "Base", "put!", v茅ase "put!")))

[source,@julia-setup chap19]
----
function fib(c::Channel)
    a = 0
    b = 1
    put!(c, a)
    while true
        put!(c, b)
        (a, b) = (b, a+b)
    end
end
----

+put!+ almacena valores en un objeto channel y +take!+ lee valores desde 茅l:
(((take!)))((("funci贸n", "Base", "take!", v茅ase "take!")))

[source,@julia-repl-test chap19]
----
julia> fib_gen = Channel(fib);

julia> take!(fib_gen)
0
julia> take!(fib_gen)
1
julia> take!(fib_gen)
1
julia> take!(fib_gen)
2
julia> take!(fib_gen)
3
----

El constructor +Channel+ crea la tarea. La funci贸n +fib+ se suspende despu茅s de cada llamada a +put!+ y se reanuda al llamar a +take!+. Por razones de rendimiento, se almacenan varios valores de la secuencia en el objeto channel durante un ciclo de reanudaci贸n/suspensi贸n.

Un objeto channel tambi茅n se puede usar como iterador:

[source,@julia-repl-test chap19]
----
julia> for val in Channel(fib)
           print(val, " ")
           val > 20 && break
       end
0 1 1 2 3 5 8 13 21
----


=== Tipos

==== Tipos Primitivos

Un tipo concreto compuesto por bits se llama _tipo primitivo_. A diferencia de la mayor铆a de los lenguajes, en Julia se puede declarar nuestros propios tipos primitivos. Los tipos primitivos est谩ndar se definen de la misma manera:
(((tipo primitivo)))((("palabra reservada", "tipo primitivo")))

[source,julia]
----
primitive type Float64 <: AbstractFloat 64 end
primitive type Bool <: Integer 8 end
primitive type Char <: AbstractChar 32 end
primitive type Int64 <: Signed 64 end
----

El n煤mero en las sentencias especifica cu谩ntos bits son necesarios.

El siguiente ejemplo crea un tipo primitivo +Byte+ y un constructor:
(((Byte)))((("tipo", "definida por el programador", "Byte", v茅ase "Byte")))

[source,@julia-repl-test]
----
julia> primitive type Byte 8 end

julia> Byte(val::UInt8) = reinterpret(Byte, val)
Byte
julia> b = Byte(0x01)
Byte(0x01)
----

La funci贸n +reinterpret+ se usa para almacenar los bits de un entero sin signo con 8 bits (+UInt8+) en el byte.
(((reinterpret)))((("funci贸n", "Base", "reinterpret", v茅ase "reinterpret")))(((UInt8)))((("tipo", "Base", "UInt8", v茅ase "UInt8")))

==== Tipos Param茅tricos

El sistema de tipos de Julia es _param茅trico_, lo que significa que los tipos pueden tener par谩metros.

Los par谩metros de un tipo se colocan despu茅s del nombre del tipo, entre llaves:
(((llaves)))

[source,@julia-setup chap19]
----
struct Punto{T<:Real}
    x::T
    y::T
end
----

Con esto se define un nuevo tipo param茅trico, +Punto{T<:Real}+, que contiene dos "coordenadas" de tipo +T+, que puede ser cualquier tipo que tenga +Real+ como supertipo.

[source,@julia-repl-test chap19]
----
julia> Punto(0.0, 0.0)
Punto{Float64}(0.0, 0.0)
----

Adem谩s de los tipos compuestos, los tipos abstractos y los tipos primitivos tambi茅n pueden tener par谩metros.

[TIP]
====
Para mejorar el rendimiento, es totalmente recomendable tener tipos concretos como atributos de una estructura, por lo que esta es una buena manera de hacer que +Punto+ sea r谩pido y flexible.
====

==== Union de Tipo

Una _union de tipo_ es un tipo param茅trico abstracto que puede actuar como cualquiera de los tipos de sus argumentos:
(((union de tipo)))(((Union)))((("tipo", "Base", "Union", v茅ase "Union")))

[source,@julia-repl-test]
----
julia> EnteroOCadena = Union{Int64, String}
Union{Int64, String}
julia> 150 :: EnteroOCadena
150
julia> "Julia" :: EnteroOCadena
"Julia"
----

Una uni贸n de tipos es, en la mayor铆a de los lenguajes inform谩ticos, una construcci贸n interna para trabajar con tipos. Sin embargo, Julia pone a disposici贸n esta caracter铆stica para sus usuarios, ya que permite generar un c贸digo eficiente (cuando la uni贸n es entre pocos tipos). Esta caracter铆stica otorga una gran flexibilidad para controlar el dispatch.

=== M茅todos

==== M茅todos Param茅tricos 

Las definiciones de m茅todos tambi茅n pueden tener par谩metros de tipo que limiten su especificaci贸n:
(((especificaci贸n)))

[source,@julia-repl-test chap19]
----
julia> espuntoentero(p::Punto{T}) where {T} = (T === Int64)
espuntoentero (generic function with 1 method)
julia> p = Punto(1, 2)
Punto{Int64}(1, 2)
julia> espuntoentero(p)
true
----

==== Objetos Similares a Funciones

Cualquier objeto arbitrario de Julia puede hacerse "invocable". Tales objetos "invocables" a veces se denominan _funtores_.
(((funtor)))

[source,@julia-setup chap19]
----
struct Polinomio{R}
    coef::Vector{R}
end

function (p::Polinomio)(x)
    val = p.coef[end]
    for coef in p.coef[end-1:-1:1]
        val = val * x + coef
    end
    val
end
----

Para evaluar el polinomio, simplemente debemos llamarlo:

[source,@julia-repl-test chap19]
----
julia> p = Polinomio([1,10,100])
Polinomio{Int64}([1, 10, 100])
julia> p(3)
931
----

=== Constructores

Los tipos param茅tricos se pueden construir expl铆cita o impl铆citamente:

[source,@julia-repl-test chap19]
----
julia> Punto(1,2)         # T implicito
Punto{Int64}(1, 2)
julia> Punto{Int64}(1, 2) # T explicito
Punto{Int64}(1, 2)
julia> Punto(1,2.5)       # T implicito
ERROR: MethodError: no method matching Punto(::Int64, ::Float64)
----

Se generan constructores internos y externos por defecto para cada +T+:
(((constructor)))

[source,julia]
----
struct Punto{T<:Real}
    x::T
    y::T
    Punto{T}(x,y) where {T<:Real} = new(x,y)
end

Punto(x::T, y::T) where {T<:Real} = Punto{T}(x,y);
----

y tanto +x+ como +y+ deben ser del mismo tipo. 

Cuando +x+ e +y+ son de tipos diferentes, se puede definir el siguiente constructor externo:

[source,@julia-setup chap19]
----
Punto(x::Real, y::Real) = Punto(promote(x,y)...);
----

La funci贸n +promote+ se detalla en <<promoci贸n>>.
(((promote)))((("funci贸n", "Base", "promote", v茅ase "promote")))

=== Conversi贸n y Promoci贸n

Julia tiene un sistema para convertir argumentos de diferentes tipos a un tipo com煤n. Esto es llamado promoci贸n, y aunque no es autom谩tico, se puede realizar f谩cilmente.

==== Conversi贸n

Un valor se puede convertir de un tipo a otro:
(((conversi贸n)))(((convert)))((("funci贸n", "Base", "convert", v茅ase "convert")))

[source,@julia-repl-test]
----
julia> x = 12
12
julia> typeof(x)
Int64
julia> convert(UInt8, x)
0x0c
julia> typeof(ans)
UInt8
----

Se pueden agregar nuestros propios m茅todos +convert+:
[source,@julia-repl-test chap19]
----
julia> Base.convert(::Type{Punto{T}}, x::Array{T, 1}) where {T<:Real} = Punto(x...)

julia> convert(Punto{Int64}, [1, 2])
Punto{Int64}(1, 2)
----

[[promoci贸n]]
==== Promoci贸n

_Promoci贸n_ es la conversi贸n de valores de diferentes tipos a un solo tipo com煤n:
(((promoci贸n)))(((promote)))

[source,@julia-repl-test]
----
julia> promote(1, 2.5, 3)
(1.0, 2.5, 3.0)
----

Generalmente, los m茅todos para la funci贸n +promote+ no se definen directamente, sino que se usa la funci贸n auxiliar +promot_rule+ para especificar las reglas de la promoci贸n:
(((promote_rule)))((("funci贸n", "Base", "promote_rule", v茅ase "promote_rule")))

[source,julia]
----
promote_rule(::Type{Float64}, ::Type{Int32}) = Float64
----

=== Metaprogramaci贸n

Un c贸digo de Julia se puede representar como una estructura de datos del mismo lenguaje. Esto permite que un programa escriba y manipule su propio c贸digo.

==== Expresiones

Cada programa de Julia comienza como una cadena:

[source,@julia-repl-test chap19]
----
julia> prog = "1 + 2"
"1 + 2"
----

El siguiente paso es analizar cada cadena en un objeto llamado _expresi贸n_, representado por el tipo de Julia +Expr+:
(((expresi贸n)))(((Expr)))((("tipo", "Base", "Expr", v茅ase "Expr")))(((parse)))((("funci贸n", "Meta", "parse", v茅ase "parse")))

[source,@julia-repl-test chap19]
----
julia> ex = Meta.parse(prog)
:(1 + 2)
julia> typeof(ex)
Expr
julia> dump(ex)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 2
----

La funci贸n +dump+ muestra objetos expr con anotaciones.
(((dump)))

Las expresiones se pueden construir directamente con el prefijo +:+ entre par茅ntesis o usando un bloque quote:
(((:)))(((quote)))((("palabra reservada", "quote")))

[source,@julia-repl-test chap19]
----
julia> ex = quote
           1 + 2
       end;
----

==== +eval+

Julia puede evaluar un objeto de expresi贸n usando la funci贸n +eval+:
(((eval)))((("funci贸n", "Core", "eval", v茅ase "eval")))

[source,@julia-eval chap19]
----
import Base.eval
----

[source,@julia-repl-test chap19]
----
julia> eval(ex)
3
----

Cada m贸dulo tiene su propia funci贸n +eval+ que eval煤a las expresiones de su 谩mbito.

[WARNING]
====
Generalmente si un c贸digo tiene muchas llamadas a +eval+, significa que algo est谩 mal. +eval+ se considera "malo".
====

==== Macros

Las macros pueden incluir c贸digo generado en un programa. Una _macro_ asocia una tupla de objetos +Expr+ directamente con una expresi贸n compilada:
(((macro)))

Aqu铆 hay una macro simple:
(((@contenedorvariable)))((("macro", "definida por el programador", "@contenedorvariable", v茅ase "@contenedorvariable")))

[source,@julia-setup chap19]
----
macro contenedorvariable(contenedor, elemento)
    return esc(:($(Symbol(contenedor,elemento)) = $contenedor[$elemento]))
end
----

Las macros se llaman anteponiendo +@+ (arroba) a su nombre. La llamada a la macro +@contenedorvariable letras 1+ se reemplaza por:
(((@)))

[source,julia]
----
:(letras1 = letras[1])
----

+@macroexpand @contenedorvariable letras 1+  returns this expression which is extremely useful for debugging.
(((@macroexpand)))((("macro", "Base", "@macroexpand", v茅ase "@macroexpand")))

Este ejemplo ilustra c贸mo una macro puede acceder al nombre de sus argumentos, algo que una funci贸n no puede hacer. Se debe "escapar" de la expresi贸n de retorno con +esc+ porque debe resolverse en el entorno de la macro llamada.
(((esc)))((("funci贸n", "Base", "esc", v茅ase "esc")))

[NOTE]
====
驴Por qu茅 usar Macros?

Las macros generan e incluyen fragmentos de c贸digo personalizado durante el tiempo de an谩lisis, es decir, _antes_ de ejecutar el programa completo.
====

==== Funciones Generadas

La macro +@generated+ crea c贸digo especializado para m茅todos dependiendo del tipo de los argumentos:
(((funciones generadas)))(((@generated)))((("macro", "Base", "@generated", v茅ase "@generated")))

[source,@julia-setup chap19]
----
@generated function cuadrado(x)
    println(x)
    :(x * x)
end
----

El cuerpo devuelve una expresi贸n citada como una macro.

Para la sentencia que llama, la _funci贸n generada_ se comporta como una funci贸n normal:

[source,@julia-repl-test chap19]
----
julia> x = cuadrado(2); # nota: la salida es de la instrucci贸n println () que est谩 en el cuerpo 
Int64
julia> x              # ahora imprimimos x
4
julia> y = cuadrado("spam");
String
julia> y
"spamspam"
----

=== Datos Faltantes

Los _datos faltantes_ se pueden representar a trav茅s del objeto +missing+, que es la instancia 煤nica del tipo +Missing+.
(((datos faltantes)))(((faltantes)))(((Missing)))((("tipo", "Base", "Missing", v茅ase "Missing")))

Los arreglos pueden contener datos que faltan, missing values en ingl茅s:

[source,@julia-repl-test chap19]
----
julia> a = [1, missing]
2-element Array{Union{Missing, Int64},1}:
 1
  missing
----

El tipo de dicho arreglo es +Union{Missing, T}+, d贸nde +T+ es el tipo de los valores que realmente tenemos en el arreglo.

Las funciones de reducci贸n devuelven +missing+ cuando se invocan con arreglos que contienen valores que faltan

[source,@julia-repl-test chap19]
----
julia> sum(a)
missing
----

En este caso, se puede usar la funci贸n +skipmissing+ para omitir los valores que faltan:
(((skipmissing)))((("funci贸n", "Base", "skipmissing", v茅ase "skipmissing")))

[source,@julia-repl-test chap19]
----
julia> sum(skipmissing([1, missing]))
1
----


=== Llamar a C贸digo de C y Fortran

Se escribe mucho c贸digo en C o Fortran. Reutilizar un c贸digo que ya ha sido probado generalmente es mejor que escribir su propia versi贸n en otro lenguaje. Julia puede llamar directamente a las bibliotecas C o Fortran existentes utilizando la sintaxis +ccall+.
(((ccall)))((("funci贸n", "Base", "ccall", v茅ase "ccall")))

En <<databases>> se present贸 una interfaz de Julia de la biblioteca GDBM de funciones de base de datos. La biblioteca est谩 escrita en C. Para cerrar la base de datos, se debe hacer una llamada a la funci贸n +close(db)+:

[source,julia]
----
Base.close(dbm::DBM) = gdbm_close(dbm.handle)

function gdbm_close(handle::Ptr{Cvoid})
    ccall((:gdbm_close, "libgdbm"), Cvoid, (Ptr{Cvoid},), handle)
end
----

Un objeto dbm tiene un atributo +handle+ de tipo +Ptr{Cvoid}+. Este atributo contiene un puntero de C que apunta a la base de datos. Para cerrar la base de datos, debe llamarse a la funci贸n de C +gdbm_close+ teniendo como 煤nico argumento el puntero C apuntando a la base de datos, sin valor de retorno. Julia hace esto directamente con la funci贸n +ccall+ que tiene como argumentos:
(((Ptr)))((("tipo", "Base", "Ptr", v茅ase "Ptr")))

* una tupla que consiste en un s铆mbolo que contiene el nombre de la funci贸n que queremos llamar: +:gdbm_close+ y la librer铆a compartida especificada como una cadena: ++"libgdm"+,

* el tipo de retorno: +Cvoid+,

* una tupla de tipos de argumentos: +(Ptr{Cvoid},)+ 

* los valores del argumento: +handle+.

Una visi贸n completa de la librer铆a GDBM se puede encontrar como ejemplo en las fuentes de ThinkJulia.

=== Glossary

clausura::
Funci贸n que captura variables del 谩mbito en d贸nde est谩 definida.
(((clausura)))

bloque let::
Bloque de asignaci贸n de nuevas ligaduras variables.
(((bloque let)))

funci贸n an贸nima::
Funci贸n definida sin nombre.
(((funci贸n an贸nima)))

tupla con nombre::
Tupla con componentes con nombre.
(((tupla con nombre)))

argumentos con nombre::
Argumentos identificados por su nombre en vez de solo por la posici贸n que ocupan.
(((argumentos con nombre)))

bloque do::
Construcci贸n usada para definir y llamar a una funci贸n an贸nima parecida a un bloque de c贸digo normal.
(((bloque do)))

operador ternario::
Operador de estructura de control que toma tres operandos: una condici贸n, una expresi贸n que se ejecutar谩 si la condici贸n devuelve +true+ y una expresi贸n que se ejecutar谩 si la condici贸n devuelve +false+.
(((operador ternario)))

evaluaci贸n de cortocircuito::
Evaluaci贸n de un operador booleano para el que se ejecuta o eval煤a el segundo argumento solo si el primero no es suficiente para determinar el valor de la expresi贸n.
(((evaluaci贸n de cortocircuito)))

tareas (corrutina)::
Caracter铆stica de las estructuras de control que permite suspender y reanudar c谩lculos de manera flexible.
(((tarea)))

tipo primitivo::
Tipo concreto cuyos datos est谩n compuestos de bits.
(((tipo primitivo)))

uni贸n de tipos::
Tipo que incluye todas las instancias de cualquiera de sus tipos de par谩metros como objetos.
(((uni贸n de tipos)))

tipo param茅trico::
Tipo que tiene par谩metros.
(((tipo param茅trico)))

funtor::
Objeto con un m茅todo asociado, para que sea invocable.
(((funtor)))

conversi贸n::
Permite convertir un valor de un tipo a otro.
(((conversi贸n)))

promoci贸n::
Conversi贸n de valores de diferentes tipos a un solo tipo com煤n.
(((promoci贸n)))

expresi贸n::
Tipo de Julia que contiene una construcci贸n de lenguaje.
(((expresi贸n)))

macro::
Forma de incluir el c贸digo generado en el cuerpo final de un programa.
(((macro)))

funciones generadas::
Funciones capaces de generar c贸digo especializado seg煤n el tipo de los argumentos.
(((funciones generadas)))

datos faltantes::
Instancias que representan datos sin valor.
(((datos faltantes)))
