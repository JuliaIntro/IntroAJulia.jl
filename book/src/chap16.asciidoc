[[chap16]]
== Estructuras y Funciones

Ahora que sabemos cómo crear tipos compuestos, el siguiente paso es escribir funciones que tomen objetos definidos por el programador como parámetros, y que los devuelvan como resultados. En este capítulo también se presenta el "estilo de programación funcional" y dos nuevas formas de desarrollar programas.

[[time]]
=== Tiempo

Como otro ejemplo más de tipo compuesto, definiremos una +estructura+ llamada +Hora+ que registra la hora del día. La definición de esta estructura se muestra a continuación:
(((MyTime)))((("type", "programmer-defined", "MyTime", see="MyTime")))

[source,@julia-setup chap16]
----
"""
Representa la hora del día.

atributos: hora, minuto, segundo
"""
struct Hora
    hora
    minuto
    segundo
end
----

Observación: +Time+ es una palabra reservada de Julia. 
(((Time)))((("type", "Dates", "Time", see="Time")))

[source,@julia-repl-test chap16]
----
julia> hora = Hora(11, 59, 30)
Hora(11, 59, 30)
----

El diagrama de objeto para el objeto +Hora+ luce así <<fig16-1>>.

[[fig16-1]]
.Object diagram
image::images/fig161.svg[]

==== Ejercicio 16-1

Escriba una función llamada +imprimirhora+ que tome un objeto +Hora+ y lo imprima con el formato +hora:minuto:segundo+. +Printf+, de la macro +@printf+ del módulo StdLib, permite imprimir un número entero con el formato `"%02d"`, es decir, utilizando al menos dos dígitos, incluido un cero inicial si es necesario.
(((printtime)))((("function", "programmer-defined", "printtime", see="printtime")))

==== Ejercicio 16-2

Escriba una función booleana llamada +estadespues+ que tome dos objetos +Hora+: +t1+ y +t2+, y devuelva +true+ si la hora +t1+ está después que +t2+, y +false+ de lo contrario. Desafío: no use una sentencia +if+.
(((isafter)))((("function", "programmer-defined", "isafter", see="isafter")))


=== Funciones Puras

En las siguientes secciones escribiremos dos versiones de una función que calcula la suma de horas. La primera versión muestra un tipo de función llamado función pura, y la segunda un tipo llamado modificador. Además, estas versiones permitirán mostrar un nuevo plan de desarrollo de programa que llamaremos _prototipo y parche_, que es una forma de abordar un problema complejo comenzando con un prototipo simple y lidiando gradualmente con las complicaciones.
(((pure function)))(((prototype and patch)))

Este es un primer prototipo de la función +sumahora+:
(((addtime)))((("function", "programmer-defined", "addtime", see="addtime")))

[source,@julia-setup chap16]
----
function sumahora(t1, t2)
    Hora(t1.hora + t2.hora, t1.minuto + t2.minuto, t1.segundo + t2.segundo)
end
----

La función crea un nuevo objeto +Hora+, inicializa sus atributos y devuelve una referencia al nuevo objeto. A esto se le llama _función pura_ porque no modifica ninguno de los objetos que se le pasan como argumento, y no tiene efectos (como mostrar un valor o tomar una entrada del usuario) más que devolver un valor.

Para probar esta función, crearemos dos objetos +Hora+: +inicio+, que contiene la hora de inicio de una película, como _Roma_, y +duracion+, que contiene la duración de la película, que es dos horas y 15 minutos.

+sumahora+ calcula cuándo se terminará la película.

[source,@julia-eval chap16]
----
using Printf
function imprimirhora(tiempo::Hora)
    @printf("%02d:%02d:%02d", tiempo.hora, tiempo.minuto, tiempo.segundo)
end;
----

[source,@julia-repl-test chap16]
----
julia> inicio = Hora(9, 50, 0);

julia> duracion = Hora(2, 15, 0);

julia> finaliza = sumahora(inicio, duracion);

julia> imprimirhora(finaliza)
11:65:00
----

El resultado +11:65:00+ no es lo que queríamos. El problema es que esta función no considera de los casos en los que el número de segundos o minutos suma más que sesenta. Cuando ocurre eso, debemos "acarrear" (como en una suma) los segundos sobrantes a la columna de los minutos, o los minutos extras a la columna de las horas. He aquí una versión corregida de la función:

[source,@julia-setup chap16]
----
function sumahora(t1, t2)
    segundo = t1.segundo + t2.segundo
    minuto = t1.minuto + t2.minuto
    hora = t1.hora + t2.hora
    if segundo >= 60
        segundo -= 60
        minuto += 1
    end
    if minuto >= 60
        minuto -= 60
        hora += 1
    end
    Hora(hora, minuto, segundo)
end
----

Aunque esta función es correcta, es muy larga. Más adelante veremos una alternativa más corta.

[[modifiers]]
=== Modificadores

Hay veces en las que es útil que una función modifique uno o más de los objetos que recibe como parámetros. En ese caso, los cambios son visibles en el nivel en donde se ubica la sentencia de llamada. Las funciones así se llaman _modificadores_.
(((modifier)))

La función +incrementar!+, que agrega un número dado de segundos a un objeto +Hora+, puede escribirse naturalmente como un modificador. Aquí mostramos un esbozo rápido de la función:
(((increment!)))((("function", "programmer-defined", "increment!", see="increment!")))

[source,@julia-setup chap16]
----
function incrementar!(tiempo, segundos)
    tiempo.segundo += segundos
    if tiempo.segundo >= 60
        tiempo.segundo -= 60
        tiempo.minute += 1
    end
    if tiempo.minuto >= 60
        tiempo.minuto -= 60
        tiempo.hora += 1
    end
end
----

La primera línea realiza la suma de los segundos; las restantes se ocupan de los casos especiales que vimos antes.

¿Es correcta esta función? ¿Qué ocurre si el parámetro +segundos+ es mucho mayor que sesenta?

En tal caso, no es suficiente con acarrear una vez; debemos seguir haciéndolo hasta que +tiempo.segundo+ sea menor que sesenta. Una solución es sustituir las sentencias +if+ por sentencias +while+. Ahora, esta función es correcta, pero no es la solución más eficiente.

==== Ejercicio 16-3

Escriba una versión correcta de +incrementar!+ sin bucles.

Todo lo que se pueda hacer con modificadores también puede hacerse con funciones puras. De hecho, algunos lenguajes de programación solo permiten funciones puras. Hay ciertas evidencias de que los programas que usan funciones puras son más rápidos de desarrollar y menos propensos a errores que los programas que usan modificadores. Sin embargo, a veces los modificadores son utiles, y en algunos casos los programas funcionales (es decir, con funciones puras) tienden a ser menos eficientes.

En general, recomendamos que escriba funciones puras siempre que sea razonable hacerlo así, y recurra a los modificadores sólo si hay una ventaja convincente. Este enfoque podría llamarse _estilo de programación funcional_.
(((functional programming style)))

==== Ejercicio 16-4

Escriba una versión "pura" de +incrementar!+, que cree y devuelva un nuevo objeto +Hora+ en vez de modificar el parámetro.


[[prototyping_versus_planning]]
=== Desarrollo de prototipos frente a la planificación

El desarrollo de programas que veremos ahora se llama “desarrollo de prototipos”. En cada una de las funciones anteriores, escribimos un prototipo que realizaba el cálculo básico, y luego lo probamos sobre unos cuantos casos, corrigiendo las fallas a medida que las encontrábamos.
(((program development plan)))(((prototyping and patch)))

Este enfoque puede ser efectivo, especialmente si aún no tiene un conocimiento profundo del problema. Pero las correcciones incrementales pueden generar código innecesariamente complicado (que considere muchos casos especiales) y poco confiable (es difícil saber si ha encontrado todos los errores).

Una alternativa es el _desarrollo planificado_, en el que la comprensión del problema en profundidad puede facilitar en gran medida la programación. En el caso de sumahora, podemos ver un objeto Hora como ¡un numero de tres dígitos en base 60 (vea https://en.wikipedia.org/wiki/Sexagesimal)!. El atributo segundo es la “columna de unidades”, el atributo minuto es la “columna de los sesentas” y el atributo hora es la “columna de los treinta y seis cientos”.
(((designed development)))

Cuando escribimos +sumahora+ e +incrementar!+, efectivamente estábamos sumando en base 60, por eso tuvimos que "acarrear" de una columna a la siguiente.

Esta observación sugiere otro enfoque para el problema: podemos convertir los objetos +Hora+ en enteros y aprovechar el hecho de que la computadora sabe realizar aritmética con enteros.

La siguiente función convierte un objeto Hora en un entero:
(((timetoint)))((("function", "programmer-defined", "timetoint", see="timetoint")))

[source,@julia-setup chap16]
----
function horaaentero(tiempo)
    minutos = tiempo.hora * 60 + tiempo.minuto
    segundos = minutos * 60 + tiempo.segundo
end
----

Ahora, para convertir un entero en un objeto +Hora+ (recuerde que +divrem+ divide el primer argumento por el segundo, y devuelve el cociente y el resto como una tupla):
(((inttotime)))((("function", "programmer-defined", "inttotime", see="inttotime")))

[source,@julia-setup chap16]
----
function enteroahora(segundos)
    (minutos, segundo) = divrem(segundos, 60)
    hora, minuto = divrem(minutos, 60)
    Hora(hora, minuto, segundo)
end
----

Puede que tenga que pensar un poco y ejecutar algunas pruebas para convencerse de que estas funciones son correctas. Una forma de probarlas es verificar que +horaaentero((enteroahora(x)) == x+ para muchos valores de +x+. Este es un ejemplo de prueba de consistencia.

Una vez que esté convencido, puede usar estas funciones para reescribir sumahora:

[source,@julia-setup chap16]
----
function sumahora(t1, t2)
    segundos = horaaentero(t1) + horaaentero(t2)
    enteroahora(segundos)
end
----

Esta versión es más corta que la original y más fácil de verificar.

==== Ejercicio 16-5

Reescriba +incrementar!+ usando +horaaentero+ y +enteroahora+.



In some ways, converting from base 60 to base 10 and back is harder than just dealing with times. Base conversion is more abstract; our intuition for dealing with time values is better.

But if we have the insight to treat times as base 60 numbers and make the investment of writing the conversion functions (+timetoint+ and +inttotime+), we get a program that is shorter, easier to read and debug, and more reliable.

It is also easier to add features later. For example, imagine subtracting two +MyTime+s to find the duration between them. The naive approach would be to implement subtraction with borrowing. Using the conversion functions would be easier and more likely to be correct.

Ironically, sometimes making a problem harder (or more general) makes it easier (because there are fewer special cases and fewer opportunities for error).

[[chap16_debugging]]
=== Debugging

A +MyTime+ object is well-formed if the values of +minute+ and +second+ are between 0 and 60 (including 0 but not 60) and if +hour+ is positive. +hour+ and +minute+ should be integral values, but we might allow +second+ to have a fraction part.
(((debugging)))

Requirements like these are called _invariants_ because they should always be true. To put it a different way, if they are not true, something has gone wrong.
(((invariant)))

Writing code to check invariants can help detect errors and find their causes. For example, you might have a function like +isvalidtime+ that takes a +MyTime+ object and returns +false+ if it violates an invariant:
(((isvalidtime)))((("function", "programmer-defined", "isvalidtime", see="isvalidtime")))

[source,@julia-setup chap16]
----
function isvalidtime(time)
    if time.hour < 0 || time.minute < 0 || time.second < 0
        return false
    end
    if time.minute >= 60 || time.second >= 60
        return false
    end
    true
end
----

At the beginning of each function you could check the arguments to make sure they are valid:
(((addtime)))(((error)))

[source,@julia-setup chap16]
----
function addtime(t1, t2)
    if !isvalidtime(t1) || !isvalidtime(t2)
        error("invalid MyTime object in add_time")
    end
    seconds = timetoint(t1) + timetoint(t2)
    inttotime(seconds)
end
----

Or you could use an +@assert+ macro, which checks a given invariant and throws an exception if it fails:
(((@assert)))((("macro", "Base", "@assert", see="@assert")))

[source,@julia-setup chap16]
----
function addtime(t1, t2)
    @assert(isvalidtime(t1) && isvalidtime(t2), "invalid MyTime object in add_time")
    seconds = timetoint(t1) + timetoint(t2)
    inttotime(seconds)
end
----

+@assert+ macros are useful because they distinguish code that deals with normal conditions from code that checks for errors.


=== Glossary

prototype and patch::
A development plan that involves writing a rough draft of a program, testing, and correcting errors as they are found.
(((prototype and patch)))

designed development::
A development plan that involves high-level insight into the problem and more planning than incremental development or prototype development.
(((designed development)))

pure function::
A function that does not modify any of the objects it receives as arguments. Most pure functions are fruitful.
(((pure function)))

modifier::
A function that changes one or more of the objects it receives as arguments. Most modifiers are void; that is, they return +nothing+.
(((modifier)))

functional programming style::
A style of program design in which the majority of functions are pure.
(((functional programming style)))

invariant::
A condition that should never change during the execution of a program.
(((invariant)))


=== Exercises

[[ex16-1]]
==== Exercise 16-6

Write a function called +multime+ that takes a +MyTime+ object and a number and returns a new +MyTime+ object that contains the product of the original +MyTime+ and the number.
(((multime)))((("function", "programmer-defined", "multime", see="multime")))

Then use +multime+ to write a function that takes a +MyTime+ object that represents the finishing time in a race, and a number that represents the distance, and returns a +MyTime+ object that represents the average pace (time per mile).

[[ex16-2]]
==== Exercise 16-7

Julia provides time objects that are similar to the +MyTime+ objects in this chapter, but they provide a rich set of function and operators. Read the documentation at https://docs.julialang.org/en/v1/stdlib/Dates/.

. Write a program that gets the current date and prints the day of the week.

. Write a program that takes a birthday as input and prints the user’s age and the number of days, hours, minutes and seconds until their next birthday.

. For two people born on different days, there is a day when one is twice as old as the other. That’s their Double Day. Write a program that takes two birthdays and computes their Double Day.

. For a little more challenge, write the more general version that computes the day when one person is latexmath:[\(n\)] times older than the other.

