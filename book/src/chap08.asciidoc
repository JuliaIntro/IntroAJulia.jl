[[chap08]]
== Cadenas

Las cadenas son diferentes de los n√∫meros enteros, flotantes y booleanos. Una cadena es una _secuencia_, es decir, es una colecci√≥n ordenada de valores. En este cap√≠tulo veremos c√≥mo acceder a los caracteres que forman una cadena, y conoceremos algunas funciones integradas en Julia relacionadas con cadenas.
(((string)))(((sequence)))

[[characters]]
=== Caracteres

Los hispanohablantes est√°n familiarizados con algunos caracteres, tales como las letras del alfabeto (A, B, C, ...), los n√∫meros y los signos de puntuaci√≥n comunes. Estos caracteres est√°n estandarizados en el c√≥digo _ASCII_ (C√≥digo Est√°ndar Estadounidense para el Intercambio de Informaci√≥n).
(((ASCII standard)))

Por supuesto hay muchos otros caracteres utilizados en idiomas distintos del espa√±ol que no est√°n en el c√≥digo _ASCII_, tales como aquellos usados en los idiomas griego, √°rabe, chino, hebreo, hindi, japon√©s y coreano.

Definir qu√© es un car√°cter es altamente complejo. La _norma Unicode_ permite abordar este problema, y se considera como el est√°ndar definitivo para ello. Esta norma funciona asignando un n√∫mero √∫nico para cada car√°cter a nivel global.
(((Unicode standard)))

Un valor +Char+ representa un √∫nico car√°cter y est√° entre comillas simples:
(((Char)))((("type", "Base", "Char", see="Char")))

[source,@julia-repl-test]
----
julia> 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
julia> 'üçå'
'üçå': Unicode U+01f34c (category So: Symbol, other)
julia> typeof('x')
Char
----

Incluso los emojis son parte del est√°ndar Unicode. (*+\:banana: TAB+*)
(((emoji)))


=== Una Cadena es una Secuencia

Una cadena es una secuencia de caracteres. Se puede acceder a un car√°cter con el operador corchete:
(((string)))(((String)))(((sequence)))(((bracket operator)))((("[]", see="bracket operator")))((("operator", "Base", "[]", see="bracket operator")))

[source,@julia-repl-test chap08]
----
julia> fruta = "banana"
"banana"
julia> letra = fruta[1]
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
----

La segunda sentencia selecciona el car√°cter n√∫mero 1 de +fruta+ y la asigna a la variable +letra+. 

La expresi√≥n entre corchetes se llama _indice_. El √≠ndice indica el car√°cter de la secuencia a obtener (de ah√≠ el nombre).
(((index)))

La indexaci√≥n en Julia es base 1, es decir, el primer elemento de cualquier objeto indexado con enteros est√° en el √≠ndice 1, y el √∫ltimo en el √≠ndice +end+:
(((end)))

[source,@julia-repl-test chap08]
----
julia> fruta[end]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
----

Como √≠ndice se pueden usar expresiones que contengan variables y operadores:

[source,@julia-repl-test chap08]
----
julia> i = 1
1
julia> fruta[i+1]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia> fruta[end-1]
'n': ASCII/Unicode U+006e (category Ll: Letter, lowercase)
----

Pero el valor del √≠ndice tiene que ser un n√∫mero entero. De lo contrario se obtiene:
(((MethodError)))((("error", "Core", "MethodError", see="MethodError")))

[source,@julia-repl-test chap08]
----
julia> letra = fruta[1.5]
ERROR: MethodError: no method matching getindex(::String, ::Float64)
----


=== +length+

+length+ es una funci√≥n integrada que devuelve el n√∫mero de caracteres de una cadena:
(((length)))

[source,@julia-repl-test chap08]
----
julia> frutas = "üçå üçé üçê"
"üçå üçé üçê"
julia> len = length(frutas)
5
----

Para obtener la √∫ltima letra de una cadena, puede sentirse tentado a probar algo como esto:

[source,@julia-repl-test chap08]
----
julia> last = frutas[len]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
----

Pero con esto no se obtiene el resultado esperado.

Las cadenas se codifican usando _codificaci√≥n UTF-8_. UTF-8 es una codificaci√≥n de longitud variable, lo que significa que no todos los caracteres est√°n codificados con el mismo n√∫mero de bytes.
(((UTF-8 encoding)))

La funci√≥n +sizeof+ devuelve el n√∫mero de bytes de una cadena:
(((sizeof)))((("function", "Base", "sizeof", see="sizeof")))

[source,@julia-repl-test chap08]
----
julia> sizeof("üçå")
4
----

Dado que un emoji est√° codificado en 4 bytes y la indexaci√≥n de cadenas est√° basada en bytes, el quinto elemento de +frutas+ es un +ESPACIO+.
(((emoji)))

Esto significa que no todos los √≠ndices de byte de una cadena UTF-8 son necesariamente √≠ndices v√°lidos para un car√°cter. Si en una cadena se indexa con un √≠ndice de bytes no v√°lido, se genera un error:
(((StringIndexError)))((("error", "Base", "StringIndexError", see="StringIndexError")))

[source,@julia-repl-test chap08]
----
julia> frutas[2]
ERROR: StringIndexError("üçå üçé üçê", 2)
----

En el caso de +frutas+, el car√°cter +üçå+ es un car√°cter de cuatro bytes, por lo que los √≠ndices 2, 3 y 4 no son v√°lidos y el √≠ndice del siguiente car√°cter es 5; el siguiente √≠ndice v√°lido se puede calcular con +nextind(frutas, 1)+, el subsiguiente con +nextind(frutas,5)+ y as√≠ sucesivamente.
(((nextind)))((("function", "Base", "nextind", see="nextind")))


=== Recorrido

Muchos c√°lculos implican procesar una cadena car√°cter por car√°cter. A menudo empiezan por el principio, seleccionan cada car√°cter por turno, hacen algo con √©l y contin√∫an hasta el final. Este patr√≥n de proceso se llama _recorrido_. Una forma de escribir un recorrido es con una sentencia while:
(((traversal)))(((while statement)))

[source,@julia-setup chap08]
----
indice = firstindex(frutas)
while indice <= sizeof(frutas)
    letra = frutas[indice]
    println(letra)
    global indice = nextind(frutas, indice)
end
----

Este bucle recorre la cadena y muestra cada letra en una l√≠nea distinta. La condici√≥n del bucle es +index pass:[&lt;=] sizeof(fruta)+, de modo que cuando el indice es mayor al n√∫mero de bytes en la cadena, la condici√≥n es +falsa+, y no se ejecuta el cuerpo del bucle.

La funci√≥n +firstindex+ devuelve el primer √≠ndice de bytes v√°lido. La palabra reservada +global+ antes de +indice+ indica que queremos reasignar la variable +indice+ definida en +Main+ (ver <<variables_globales>>).
(((global)))(((firstindex)))((("function", "Base", "firstindex", see="firstindex")))

==== Ejercicio 8-1

Escriba una funci√≥n que tome una cadena como argumento y que muestre las letras desde la √∫ltima a la primera, una por l√≠nea.

Otra forma de escribir un recorrido es con un bucle +for+:
(((for statement)))(((in)))

[source,@julia-setup chap08]
----
for letra in frutas
    println(letra)
end
----

Cada vez que recorremos el bucle, se asigna a la variable +letra+ el siguiente car√°cter de la cadena. El bucle contin√∫a hasta que no quedan m√°s caracteres.

El ejemplo siguiente muestra c√≥mo usar la concatenaci√≥n (multiplicaci√≥n de cadenas) y un bucle for para generar una serie abecedaria (es decir, una serie con elementos en orden alfab√©tico). Por ejemplo, en el libro de Robert McCloskey _Make Way for Ducklings_, los nombres de los patitos son Jack, Kack, Lack, Mack, Nack, Ouack, Pack, y Quack. Este bucle muestra esos nombres en orden:

[source,@julia chap08-3]
----
prefijos = "JKLMNOPQ"
sufijo = "ack"

for letra in prefijos
    println(letra * sufijo)
end
----

Por supuesto, esto no es del todo correcto, porque ‚ÄúOuack‚Äù y ‚ÄúQuack‚Äù no est√°n correctamente escritos.

==== Ejercicio 8-2

Modifique este programa para solucionar este error.

=== Porciones de Cadenas

A la subcadena de una cadena se le llama _porci√≥n_. La selecci√≥n de una porci√≥n es similar a la selecci√≥n de un car√°cter:
(((slice)))

[source,@julia-repl-test chap08]
----
julia> str = "Julio Cesar";

julia> str[1:5]
"Julio"
----

El operador +[n:m]+ devuelve la parte de la cadena desde el +n+-√©simo byte hasta el +m+-√©simo. Por lo tanto, se siguen las mismas reglas que para la indexaci√≥n simple.
(((bracket operator)))

La palabra reservada +end+ se puede usar para indicar al √∫ltimo byte de la cadena:
(((end)))

[source,@julia-repl-test chap08]
----
julia> str[7:end]
"Cesar"
----

Si el primer √≠ndice es mayor que el segundo, el resultado es una _cadena vac√≠a_, representada por dos comillas:
(((empty string)))((("&quot;&quot;", see="empty string")))

[source,@julia-repl-test chap08]
----
julia> str[8:7]
""
----

Una cadena vac√≠a no contiene caracteres y tiene una longitud de 0, pero aparte de eso es igual a cualquier otra cadena.

==== Ejercicio 8-3

Continuando este ejemplo, ¬øqu√© crees que significa +str[:]+? Prueba y ver√°s.

=== Las Cadenas son Inmutables

Es tentador usar el operador +[]+ en el lado izquierdo de una asignaci√≥n, con la intenci√≥n de cambiar un car√°cter en una cadena. Por ejemplo:
(((bracket operator)))(((MethodError)))

[source,@julia-repl-test chap08]
----
julia> saludo = "¬°Hola, mundo!"
"¬°Hola, mundo!"
julia> saludo[3] = 'J'
ERROR: MethodError: no method matching setindex!(::String, ::Char, ::Int64)
----
Nota del traductor: De acuerdo con la codificaci√≥n de caracteres en utf-8 √≥ latin-1, el car√°cter de exclamaci√≥n ‚Äò¬°‚Äô, en la variable saludo ocupa dos posiciones, de ah√≠ que la letra ‚ÄòH‚Äô est√© localizada en el √≠ndice 3.

La raz√≥n del error es que las cadenas son _inmutables_, lo que significa que no se puede cambiar una cadena existente. Lo m√°s que puedes hacer es crear una nueva cadena que sea una variaci√≥n de la original:
(((immutable)))

[source,@julia-repl-test chap08]
----
julia> saludo = "¬°J" * saludo[4:end]
"¬°Jola, mundo!"
----

Este ejemplo concatena la apertura del signo de exclamaci√≥n y una nueva primera letra a una porci√≥n de saludo. Esta operaci√≥n no tiene efecto sobre la cadena original.

=== Interpolaci√≥n de Cadenas

Construir cadenas usando concatenaci√≥n puede ser un poco engorroso. Para disminuir la necesidad de las llamadas a +string+ o multiplicaciones repetidas, Julia permite la _interpolaci√≥n de cadenas_ usando +$+:
(((string interpolation)))((("$", see="string interpolation")))

[source,@julia-repl-test]
----
julia> saludo = "¬°Hola"
"¬°Hola"
julia> paraquien = "mundo"
"mundo"
julia> "$saludo, $(paraquien)!"
"¬°Hola, mundo!"
----

Esto es m√°s entendible y conveniente que la concatenaci√≥n de cadenas: +pass:[saludo * ", " * paraquien * "!"]+

La expresi√≥n inmediatamente siguiente a +$+ se toma como la expresi√≥n cuyo valor se va a interpolar en la cadena. Por lo tanto, puedes interpolar cualquier expresi√≥n en una cadena usando par√©ntesis:

[source,@julia-repl-test]
----
julia> "1 + 2 = $(1 + 2)"
"1 + 2 = 3"
----

[[searching]]
=== Buscar

¬øQu√© hace la siguiente funci√≥n?
(((find)))((("function", "programmer-defined", "find", see="find")))

[source,@julia-setup]
----
function buscar(palabra, letra)
    indice = primerindice(palabra)
    while indice <= sizeof(palabra)
        if palabra[indice] == letra
            return indice
        end
        indice = nextind(palabra, indice)
    end
    -1
end
----

En cierto sentido, la funcion buscar es lo contrario del operador +[]+. En lugar de tomar un √≠ndice y extraer el car√°cter correspondiente, toma un car√°cter y encuentra el √≠ndice donde aparece el car√°cter. Si el car√°cter no se encuentra, la funci√≥n devuelve -1.

Este es el primer ejemplo que hemos visto de una sentencia return dentro de un bucle. Si +palabra[indice] == letra+, la funci√≥n devuelve inmediatamente el √≠ndice, escapando del bucle prematuramente.

Si el car√°cter no aparece en la cadena, entonces el programa sale del bucle normalmente y devuelve -1.

Este patr√≥n de computaci√≥n se llama a veces un recorrido _eureka_ porque tan pronto como encontramos lo que buscamos, podemos gritar ‚Äú¬°Eureka! ‚Äù y dejar de buscar.
(((search)))

==== Ejercicio 8-4

Modifique la funci√≥n +buscar+ para que tenga un tercer par√°metro: el √≠ndice de +palabra+ donde deber√≠a comenzar a buscar.

[[looping_and_counting]]
=== Iterando y contando

El siguiente programa cuenta el n√∫mero de veces que aparece la letra +a+ en una cadena:

[source,@julia-setup]
----
palabra = "banana"
contador = 0
for letra in palabra
    if letra == 'a'
        global contador = contador + 1
    end
end
println(contador)
----

Este programa es otro ejemplo del patr√≥n de computaci√≥n llamado _conteo_.  La variable +contador+ se inicializa en 0 y se incrementa cada vez que encuentra la letra +a+. Cuando termina el bucle, +contador+ contiene el resultado (el n√∫mero total de letras +a+).
(((counter)))

==== Ejercicio 8-5

Coloque este c√≥digo en una funci√≥n llamada +conteo+, y general√≠celo de tal manera que tome como argumentos una cadena y una letra.

Luego, vuelva a escribir la funci√≥n para que, en vez de revisar toda la cadena, utilice la funci√≥n +buscar+ de tres par√°metros de la secci√≥n anterior.

=== Librer√≠a con cadenas

Julia tiene funciones integradas que realizan una variedad de operaciones √∫tiles en cadenas. Por ejemplo, la funci√≥n +uppercase+ toma una cadena y devuelve una nueva cadena con todas las letras may√∫sculas.
(((uppercase)))((("function", "Base", "uppercase", see="uppercase")))

[source,@julia-repl-test]
----
julia> uppercase("¬°Hola, mundo!")
"¬°HOLA, MUNDO!"
----

Existe una funci√≥n llamada +findfirst+ que es notablemente similar a la funci√≥n +buscar+ que escribimos:
(((findfirst)))((("function", "programmer-defined", "findfirst", see="findfirst")))

[source,@julia-repl-test]
----
julia> findfirst("a", "banana")
2:2
----

La funci√≥n +findfirst+ es m√°s general que nuestra funci√≥n; puede encontrar subcadenas, no solo caracteres:

[source,@julia-repl-test]
----
julia> findfirst("na", "banana")
3:4
----

Por defecto, +findfirst+ comienza la b√∫squeda al comienzo de la cadena, pero la funci√≥n +findnext+ toma un tercer argumento: el +indice+ donde deber√≠a comenzar:
(((findnext)))((("function", "programmer-defined", "findnext", see="findnext")))

[source,@julia-repl-test]
----
julia> findnext("na", "banana", 4)
5:6
----


===  El operador +‚àà+

El operador +‚àà+ (*+\in TAB+*) es un operador booleano que toma un car√°cter y una cadena, y devuelve +true+ si el primero aparece en el segundo:
((("‚àà", see="in")))((("operator", "Base", "in", see="in")))((("operator", "Base", "‚àà", see="in")))

[source,@julia-repl-test]
----
julia> 'a' ‚àà "banana"    # 'a' en "banana"
true
----

Por ejemplo, la siguiente funci√≥n imprime todas las letras de palabra1 que tambi√©n aparecen en palabra2:
(((inboth)))((("function", "programmer-defined", "inboth", see="inboth")))

[source,@julia-setup chap08-2]
----
function ambas(palabra1, palabra2)
    for letra in palabra1
        if letra ‚àà palabra2
            print(letra, " ")
        end
    end
end
----

Una  buena elecci√≥n de nombres de variables permite que Julia se pueda leer como el espa√±ol. Este bucle puede leerse como: "para (cada) letra en (la primera) palabra, si (la) letra es un elemento de (la segunda) palabra, imprima (la) letra".

Esto es lo que se obtiene si se compara +"manzanas"+ y +"naranjas"+:

[source,@julia-repl-test chap08-2]
----
julia> ambas("manzanas", "naranjas")
a n a n a s
----


=== Comparaci√≥n de Cadenas

Los operadores de comparaci√≥n trabajan sobre cadenas. Para ver si dos cadenas son iguales:
(((string comparison)))(((==)))

[source,@julia-setup chap08]
----
palabra = "Pi√±a"
if palabra == "banana"
    println("¬°Tenemos bananas!")
end
----

Otras operaciones de comparaci√≥n son √∫tiles para ordenar alfabeticamente palabras:
(((alphabetical order)))

[source,@julia-setup chap08]
----
if palabra < "banana"
    println("Su palabra, $palabra, va antes de banana.")
elseif word > "banana"
    println("Su palabra, $palabra, va antes de banana.")
else
    println("¬°Tenemos bananas!")
end
----

// Pamela, I'm not sure what's going on in the following. Do you really want this?

Julia no maneja las letras may√∫sculas y min√∫sculas como nosotros. Todas las letras may√∫sculas van antes de las letras min√∫sculas. Por lo tanto:

[source,julia chap08]
----
"Su palabra, Pi√±a, va antes de banana."
----

[TIP]
====

Una forma com√∫n de abordar este problema es convertir las cadenas a un formato est√°ndar, como por ejemplo a min√∫sculas, antes de realizar la comparaci√≥n. 

====


[[deb08]]
=== Depuraci√≥n

Cuando se usan √≠ndices para recorrer los valores en una secuencia, es dif√≠cil acceder al principio y al final del recorrido. Aqu√≠ hay una funci√≥n que compara dos palabras y devuelve +true+ si una de las palabras es el reverso de la otra, pero contiene dos errores:
(((debugging)))(((traversal)))(((isreverse)))((("function", "programmer-defined", "isreverse", see="isreverse")))

[source,@julia-setup chap08]
----
function esreverso(palabra1, palabra2)
    if length(palabra1) != length(palabra2)
        return false
    end
    i = firstindex(palabra1)
    j = lastindex(palabra2)
    while j >= 0
        j = prevind(palabra2, j)
        if palabra1[i] != palabra2[j]
            return false
        end
        i = nextind(palabra1, i)
    end
    true
end
----

La primera sentencia +if+ verifica si las palabras tienen la misma longitud. Si no, se devuelve +false+ inmediatamente. De lo contrario, para el resto de la funci√≥n, podemos suponer que las palabras tienen la misma longitud. Este es un ejemplo del patr√≥n guardi√°n.

+i+ y +j+ son √≠ndices: +i+ recorre +palabra1+ de derecha a izquierda mientras que +j+ recorre +palabra2+ de izquierda a derecha. Si dos letras no coinciden, se devuelve +false+ inmediatamente. Si el ciclo termina y todas las letras coinciden, se devuelve +true+.

La funci√≥n +lastindex+ devuelve el √∫ltimo √≠ndice de bytes v√°lido de una cadena y +prevind+ el √≠ndice v√°lido anterior a un car√°cter.

Si probamos esta funci√≥n con las palabras "amor" y "roma", esperamos el valor de retorno +true+, pero obtenemos +false+:

[source,@julia-repl-test chap08]
----
julia> esreverso("amor", "roma")
false
----

Para depurar este tipo de error, primeramente imprimamos los valores de los √≠ndices:

// [source,julia]
// ----
//     while j >= 0
//         j = prevind(palabra2, j)
//         @show i j
//         if palabra1[i] != palabra2[j]
// ----

[source,@julia-eval chap08]
----
function esreverso(palabra1, palabra2)
    if length(palabra1) != length(palabra2)
        return false
    end
    i = firstindex(palabra1)
    j = lastindex(palabra2)
    while j >= 0
        j = prevind(palabra2, j)
        @show i j
        if palabra1[i] != palabra2[j]
            return false
        end
        i = nextind(palabra1, i)
    end
    true
end;
----

Ahora, al ejecutar el programa, se obtiene m√°s informaci√≥n:

[source,@julia-repl-test chap08]
----
julia> esreverso("amor", "roma")
i = 1 
j = 3
false
----

En la primera iteraci√≥n del bucle, el valor de +j+ es 3, pero tendr√≠a que ser 4. Esto se puede solucionar trasladando la l√≠nea +j = prevind (palabra2, j)+ al final del ciclo +while+.

Si se soluciona ese error y se ejecuta el programa nuevamente, se obtiene:

[source,@julia-eval chap08]
----
function esreverso(palabra1, palabra2)
    if length(palabra1) != length(palabra2)
        return false
    end
    i = firstindex(palabra1)
    j = lastindex(palabra2)
    while j >= 0
        @show i j
        if palabra1[i] != palabra2[j]
            return false
        end
        i = nextind(palabra1, i)
        j = prevind(palabra2, j)
    end
    true
end;
----

[source,@julia-repl-test chap08]
----
julia> esreverso("amor", "roma")
i = 1
j = 4
i = 2
j = 3
i = 3
j = 2
i = 4
j = 1
i = 5
j = 0
ERROR: BoundsError: attempt to access String
  at index [5]
----

Esta vez se ha producido un +BoundsError+. El valor de +i+ es 5, que est√° fuera del rango de la cadena +"amor"+.
(((BoundsError)))((("error", "Core", "BoundsError", see="BoundsError")))

==== Ejercicio 8-6

Ejecute el programa en papel, cambiando los valores de +i+ y +j+ durante cada iteraci√≥n. Encuentre y arregle el segundo error en esta funci√≥n.

=== Glosario

secuencia::
Una colecci√≥n ordenada de valores donde cada valor se identifica mediante un √≠ndice entero.
(((sequence)))

c√≥digo ASCII::
C√≥digo de caracteres est√°ndar para el intercambio de informaci√≥n.
(((ASCII standard)))

norma Unicode::
Un est√°ndar en la industria inform√°tica para la codificaci√≥n, representaci√≥n y manejo consistentes de texto en la mayor√≠a de los sistemas de escritura del mundo.
(((Unicode standard)))

√≠ndice::
Un valor entero usado para seleccionar un miembro de un conjunto ordenado, como puede ser un car√°cter de una cadena. En Julia los √≠ndices comienzan en 1.
(((index)))

codificaci√≥n UTF-8::
Una codificaci√≥n de caracteres de longitud variable capaz de codificar todos los 1112064 puntos de c√≥digo v√°lidos en Unicode utilizando de uno a cuatro bytes de 8 bits.
(((UTF-8 encoding)))

recorrer::
Iterar sobre los elementos de un conjunto, realizando una operaci√≥n similar en cada uno de ellos.
(((traversal)))

porci√≥n::
Una parte de una cadena especificada mediante un rango de √≠ndices.
(((slice)))

cadena vac√≠a::
Una cadena sin caracteres y longitud 0, representada por dos comillas.
(((empty string)))

immutable::
La propiedad de una secuencia que hace que a sus elementos no se les pueda asignar nuevos valores.
(((immutable)))

interpolaci√≥n de cadenas::
El proceso de evaluar una cadena que contiene uno o m√°s marcadores de posici√≥n, produciendo un resultado en el que los marcadores de posici√≥n se reemplazan con sus valores correspondientes.
(((string interpolation)))

b√∫squeda::
Un patr√≥n de recorrido que se detiene cuando encuentra lo que est√° buscando.
(((search)))

contador::
Una variable utilizada para contar algo, generalmente inicializada en cero y luego incrementada.
(((counter)))


=== Ejercicios

[[ex08-1]]
==== Ejercicio 8-7

Lea la documentaci√≥n de las funciones relacionadas con cadenas en https://docs.julialang.org/en/v1/manual/strings/. Es posible que desee probar algunas de ellas para asegurarse de comprender c√≥mo funcionan. +strip+ y +replace+ son particularmente √∫tiles.

La documentaci√≥n utiliza una sintaxis que puede ser confusa. Por ejemplo, en +search(cadena::AbstractString, caracter::Chars, [comienzo::Integer])+, los corchetes indican argumentos opcionales. Por lo tanto, +cadena+ y +caracter+ son obligatorios, pero +comienzo+ es opcional.
(((search)))((("function", "Base", "search", see="search")))

[[ex08-2]]
==== Ejercicio 8-8

Hay una funci√≥n integrada llamada +count+ que es similar a la funci√≥n en <<looping_and_counting>>. Lea la documentaci√≥n de esta funci√≥n y √∫sela para contar el n√∫mero de letras +a+ en "banana".
(((count)))((("function","Base", "count", see="count")))

[[ex08-3]]
==== Ejercicio 8-9

Una porci√≥n de cadena puede tomar un tercer √≠ndice. El primero especifica el inicio, el tercero el final y el segundo el "tama√±o del paso"; es decir, el n√∫mero de espacios entre caracteres sucesivos. Un tama√±o de paso de 2 significa cada un caracter; 3 significa cada dos, etc.
(((slice)))

[source,@julia-repl-test]
----
julia> fruta = "banana"
"banana"
julia> fruta[1:2:6]
"bnn"
----

Un tama√±o de paso de -1 recorre la palabra hacia la izquierda, por lo que la porci√≥n +[end:-1:1]+ genera una cadena invertida.

Use esto para escribir una versi√≥n de una l√≠nea de c√≥digo de +espalindrome+ de <<ex06-3>>.
(((ispalindrome)))

[[ex08-4]]
==== Exercise 8-10

Las siguientes funciones est√°n _destinadas_ a verificar si una cadena contiene letras min√∫sculas, pero algunas de ellas son incorrectas. Para cada funci√≥n, describa qu√© hace realmente la funci√≥n (suponiendo que el par√°metro es una cadena).

[source,@julia-setup]
----
function cualquierminuscula1(s)
    for c in s
        if islowercase(c)
            return true
        else
            return false
        end
    end
end

function cualquierminuscula2(s)
    for c in s
        if islowercase('c')
            return "true"
        else
            return "false"
        end
    end
end

function cualquierminuscula3(s)
    for c in s
        bandera = islowercase(c)
    end
    flag
end

function cualquierminuscula4(s)
    bandera = false
    for c in s
        bandera = bandera || islowercase(c)
    end
    flag
end

function cualquierminuscula5(s)
    for c in s
        if !islowercase(c)
            return false
        end
    end
    true
end
----

[[ex08-5]]
==== Exercise 8-11

Un cifrado C√©sar es una forma simple de cifrado que implica desplazar cada letra un n√∫mero fijo de lugares. Desplazar una letra significa reemplazarla por otra letra que se encuentra un n√∫mero fijo de posiciones m√°s adelante en el alfabeto. Es posible desplazarse hasta el principio del abecedario si fuera necesario. De esta manera, con un desplazamiento de 3, +'A'+ es +'D'+, y con un desplazamiento de 1, +'Z'+ es +'A'+ .
(((C√©sar cypher)))

Para desplazar una palabra, desplace cada letra en la misma cantidad. Por ejemplo, con un desplazamiento de 6, +"ABCDEF"+ es +"GHIJKL"+ y con un desplazamiento de -6, +"BCDE"+ es +"VWXY"+. En la pel√≠cula _2001: Una odisea del espacio_, la computadora de la nave se llama HAL, que es IBM desplazada por -1.

Escriba una funci√≥n llamada +desplazarpalabra+ que tome una cadena y un n√∫mero entero como par√°metros, y devuelva una nueva cadena que contenga las letras de la cadena original desplazadas por la cantidad dada.
(((rotateword)))((("function","programmer-defined", "rotateword", see="rotateword")))

[TIP]
====
Es posible que desee utilizar la funci√≥n integrada +Int+, que convierte un car√°cter en un c√≥digo num√©rico, y +Char+, que convierte los c√≥digos num√©ricos en caracteres. Las letras del alfabeto est√°n codificadas en orden alfab√©tico, por ejemplo:
(((Int)))(((Char)))

[source,@julia-repl-test]
----
julia> Int('c') - Int('a')
2
----

Porque +'c'+ es la tercera letra del alfabeto. Pero cuidado: los c√≥digos num√©ricos para las letras may√∫sculas son diferentes.

[source,@julia-repl-test]
----
julia> Char(Int('A') + 32)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
----
====

Algunos chistes ofensivos en Internet est√°n codificados en ROT13, que es un cifrado C√©sar con desplazamiento 13. Si no te ofendes f√°cilmente, encuentra y decodifica algunos de ellos.
