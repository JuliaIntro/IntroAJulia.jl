[[chap04]]
== Estudio de Caso: Dise√±o de Interfaz

Este cap√≠tulo presenta un segundo estudio de caso, que muestra el proceso de dise√±ar funciones que trabajen en conjunto.

Se presentan gr√°ficos turtle, que es una forma de crear dibujos a trav√©s de la programaci√≥n. Los gr√°ficos turtle no est√°n incluidos en la Biblioteca Est√°ndar, por lo que se debe agregar el m√≥dulo PiensaEnJulia a su configuraci√≥n de Julia.

Los ejemplos de este cap√≠tulo se pueden ejecutar en un notebook gr√°fico en JuliaBox, el cual combina c√≥digo, texto formateado, matem√°ticas y multimedia en un solo documento (vea <<juliabox>>).
(((JuliaBox, graphical notebook)))


=== Turtles

Un _modulo_ es un archivo que contiene una colecci√≥n de funciones relacionadas. Julia proporciona algunos m√≥dulos en su Biblioteca Est√°ndar. Adem√°s, es posible agregar m√°s funciones a una gran cantidad de _paquetes_ (https://juliaobserver.com).
(((module)))(((package)))

Los paquetes se pueden instalar en REPL ingresando al modo Pkg REPL con la tecla +]+.
(((pass:[&#93;])))(((PiensaEnJulia)))((("module", "PiensaEnJulia", see="PiensaEnJulia")))

[source,jlcon]
----
(v1.2) pkg> add https://github.com/PiensaEnJulia/PiensaEnJulia.jl
----

Esto puede demorar un poco.

Antes de que podamos usar las funciones de un m√≥dulo, tenemos que importarlo con una sentencia +using+:
(((using)))((("keyword", "using", see="using")))(((using statement)))((("statement", "using", see="using statement")))

[source,@julia-repl-test]
----
julia> using PiensaEnJulia

julia> üê¢ = Turtle()
Luxor.Turtle(0.0, 0.0, true, 0.0, (0.0, 0.0, 0.0))
----

El m√≥dulo +PiensaEnJulia+ proporciona una funci√≥n llamada +Turtle+ (tortuga en espa√±ol) que crea un objeto +Luxor.Turtle+, el cual asignamos a una variable llamada +üê¢+ (*+\:turtle: TAB+*).
(((Turtle)))((("type", "Luxor", "Turtle", see="Turtle")))

Una vez que crea una tortuga, puede llamar a una funci√≥n para "moverla", y as√≠ hacer un dibujo con ella. Por ejemplo, para mover la tortuga hacia adelante (forward en ingl√©s):
(((forward)))((("function", "PiensaEnJulia", "forward", see="forward")))

[source,julia]
----
@svg begin
    forward(üê¢, 100)
end
----

[[fig04-1]]
.Moving the turtle forward
image::images/fig41.svg[]


La palabra reservada +@svg+ ejecuta una macro que dibuja una imagen SVG. Las macros son una caracter√≠stica importante pero avanzada de Julia.
(((@svg)))((("macro", "Luxor", "@svg", see="@svg")))(((macro)))(((SVG picture)))

Los argumentos de +forward+ son la tortuga y una distancia en p√≠xeles, por lo que el tama√±o real depende de su pantalla.

Tambi√©n es posible hacer girar a la tortuga con la funci√≥n +turn+. Los argumentos de esta funci√≥n son la tortuga y un √°ngulo en grados.
(((turn)))((("function", "PiensaEnJulia", "turn", see="turn")))

Adem√°s, cada tortuga est√° sosteniendo un l√°piz, que puede estar hacia arriba o hacia abajo; si el l√°piz est√° hacia abajo, la tortuga deja un rastro cuando se mueve. <<fig04-1>> muestra el rastro dejado por la tortuga. Las funciones +penup+ y +pendown+ significan "l√°piz hacia arriba" y "l√°piz hacia abajo".
(((penup)))((("function", "PiensaEnJulia", "penup", see="penup")))(((pendown)))((("function", "PiensaEnJulia", "pendown", see="pendown")))

Para dibujar un √°ngulo recto, modifique la llamada a la macro:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

==== Ejercicio 4-1

Ahora modifique la macro para que dibuje un cuadrado. ¬°No sigas hasta haberlo terminado!


[[simple_repetition]]
=== Repetici√≥n Simple

Es probable que hayas escrito algo como esto:
(((repetition)))

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

Podemos hacer lo mismo de manera m√°s concisa con una sentencia +for+:
(((for statement)))((("statement", "for", see="for statement)))(((for)))((("keyword", "for", see="for")))(((in)))((("keyword", "in", see="in")))

[source,@julia-repl-test]
----
julia> for i in 1:4
          println("¬°Hola!")
       end
¬°Hola!
¬°Hola!
¬°Hola!
¬°Hola!
----

Este es el uso m√°s simple de la sentencia +for+; veremos m√°s usos despu√©s. Pero esto deber√≠a ser suficiente para reescribir su programa que dibuja un cuadrado. No contin√∫es hasta que lo hagas.

Aqu√≠ hay una sentencia +for+ que dibuja un cuadrado:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    for i in 1:4
        forward(üê¢, 100)
        turn(üê¢, -90)
    end
end
----

La sintaxis de una sentencia +for+ es similar a la definici√≥n de una funci√≥n. Tiene un encabezado y un cuerpo que termina con la palabra reservada +end+. El cuerpo puede contener el n√∫mero de sentencias que desee.
(((end)))

Una sentencia +for+ tambi√©n es llamada _bucle_ porque el flujo de ejecuci√≥n recorre el cuerpo y luego vuelve a la parte superior. En este caso, ejecuta el cuerpo cuatro veces.
(((loop)))

Esta versi√≥n es en realidad un poco diferente del c√≥digo anterior que dibujaba un cuadrado porque hace otro giro despu√©s de dibujar el √∫ltimo lado del cuadrado. El giro adicional lleva m√°s tiempo, pero simplifica el c√≥digo si hacemos lo mismo en cada iteraci√≥n del ciclo. Esta versi√≥n tambi√©n tiene el efecto de dejar a la tortuga nuevamente en la posici√≥n inicial, mirando hacia la direcci√≥n inicial.

=== Ejercicios

Los siguientes ejercicios usan tortugas. Son divertidos, pero tambi√©n tienen un trasfondo. Mientras trabaja en ellos, piense cu√°l es este trasfondo.

[TIP]
====
Las siguientes secciones muestran las soluciones para estos ejercicios, as√≠ que no mire hasta que haya terminado (o al menos lo haya intentado).
====

[[ex04-1]]
==== Ejercicio 4-2

Escriba una funci√≥n llamada +cuadrado+ que tome como par√°metro a un turtle +t+. Deber√≠a usar este turtle para dibujar un cuadrado.

[[ex04-2]]
==== Ejercicio 4-3

Escriba una llamada a funci√≥n que pase +t+ como argumento a +cuadrado+, y luego vuelva a ejecutar la macro.

[[ex04-3]]
==== Ejercicio 4-4

Agregue otro par√°metro, llamado +lon+, a cuadrado. Modifique el cuerpo para que la longitud de los lados sea +lon+, y luego modifique la llamada a funci√≥n agregando este segundo argumento. Ejecute la macro nuevamente. Prueba con un rango de valores para +lon+.

[[ex04-4]]
==== Ejercicio 4-5

Haga una copia de +cuadrado+ y cambie su nombre a +pol√≠gono+. Agregue otro par√°metro llamado +n+ y modifique el cuerpo para que dibuje un pol√≠gono regular de latexmath:[\(n\)]-lados.

[TIP]
====
Los √°ngulos exteriores de un pol√≠gono regular de latexmath:[\(n\)]-lados son latexmath:[\(\frac{360}{n}\)] grados.
====

[[ex04-5]]
==== Ejercicio 4-6

Escriba una funci√≥n llamada +c√≠rculo+ que tome un turtle +t+, y un radio +r+ como par√°metros, y que dibuje un c√≠rculo aproximado llamando a +pol√≠gono+ con una longitud y n√∫mero de lados apropiados. Pruebe su funci√≥n con un rango de valores de +r+.

[TIP]
====
Calcule la circunferencia del c√≠rculo y aseg√∫rese de que +len * n == circunferencia+.
====

[[ex04-6]]
==== Ejercicio 4-7

Haga una versi√≥n m√°s general de +circulo+ llamada +arco+ que tome un par√°metro adicional +angulo+, que determina qu√© fracci√≥n de un c√≠rculo dibujar. +angulo+ est√° en grados, entonces cuando +angulo= 360+, +arco+ deber√≠a dibujar un c√≠rculo completo.


=== Encapsulaci√≥n

El primer ejercicio le pide que coloque el c√≥digo que permite dibujar un cuadrado en una definici√≥n de funci√≥n, y que luego llame a la funci√≥n, pasando a turtle como par√°metro. Aqu√≠ hay una soluci√≥n:
(((square)))((("function", "programmer-defined", "square", see="square")))

[source,julia]
----
function cuadrado(t)
    for i in 1:4
        forward(t, 100)
        turn(t, -90)
    end
end
üê¢ = Turtle()
@svg begin
    cuadrado(üê¢)
end
----

Las sentencias m√°s internas, +forward+ y +turn+ tienen doble sangr√≠a para mostrar que est√°n dentro del bucle +for+, que a su vez est√° dentro de la definici√≥n de funci√≥n.
(((indentation)))

Dentro de la funci√≥n, +t+ se refiere a la misma tortuga +üê¢+, entonces +turn(t, -90)+ tiene el mismo efecto que +turn(üê¢, -90)+. En ese caso, ¬øpor qu√© no llamar al par√°metro +üê¢+? La raz√≥n es que +t+ puede ser cualquier tortuga, no solo +üê¢+, por lo que podr√≠amos crear una segunda tortuga y pasarla como argumento a +cuadrado+:

[source,julia]
----
üê´ = Turtle()
@svg begin
    cuadrado(üê´)
end
----

Colocar una porci√≥n de c√≥digo en una funci√≥n se denomina _encapsulaci√≥n_. Uno de los beneficios de la encapsulaci√≥n es que al ponerle un nombre al c√≥digo, esto sirve como una especie de documentaci√≥n. Otra ventaja es que si reutiliza el c√≥digo, ¬°es m√°s conciso llamar a una funci√≥n dos veces que copiar y pegar el cuerpo!
(((encapsulation)))


=== Generalizaci√≥n

El siguiente paso es agregar un par√°metro +lon+ a +cuadrado+. Aqu√≠ hay una soluci√≥n:
(((square)))

[source,julia]
----
function cuadrado(t, lon)
    for i in 1:4
        forward(t, lon)
        turn(t, -90)
    end
end
üê¢ = Turtle()
@svg begin
    cuadrado(üê¢, 100)
end
----

Agregar un par√°metro a una funci√≥n se llama _generalizaci√≥n_ porque hace que la funci√≥n sea m√°s general: en la versi√≥n anterior, el cuadrado siempre ten√≠a el mismo tama√±o; en esta versi√≥n puede ser de cualquier tama√±o.
(((generalization)))

El siguiente paso tambi√©n es una generalizaci√≥n. En vez de dibujar cuadrados, +poligono+ dibuja pol√≠gonos regulares con cualquier n√∫mero de lados. Aqu√≠ hay una soluci√≥n:
(((polygon)))((("function", "programmer-defined", "polygon", see="polygon")))

[source,julia]
----
function poligono(t, n, lon)
    angulo = 360 / n
    for i in 1:n
        forward(t, lon)
        turn(t, -angulo)
    end
end
üê¢ = Turtle()
@svg begin
    poligono(üê¢, 7, 70)
end
----

Este ejemplo dibuja un pol√≠gono de 7 lados, con una longitud de 70 por lado.


=== Dise√±o de Interfaz

El siguiente paso es escribir +circulo+, que toma un radio +r+ como par√°metro. Aqu√≠ hay una soluci√≥n simple que usa +poligono+ para dibujar un pol√≠gono de 50 lados:
(((circle)))((("function", "programmer-defined", "circle", see="circle")))

[source,julia]
----
function circulo(t, r)
    circunferencia = 2 * œÄ * r
    n = 50
    len = circunferencia / n
    poligono(t, n, lon)
end
----

La primera l√≠nea calcula la circunferencia de un c√≠rculo con radio latexmath:[\(r\)] usando la f√≥rmula latexmath:[\(2 \pi r\)]. +n+ es el n√∫mero de segmentos de l√≠nea de nuestra aproximaci√≥n a un c√≠rculo, y +len+ es la longitud de cada segmento. Por lo tanto, +pol√≠gono+ dibuja un pol√≠gono de 50 lados que se aproxima a un c√≠rculo de radio +r+.

Una limitante de esta soluci√≥n es que +n+ es constante, lo que significa que para c√≠rculos muy grandes, los segmentos de l√≠nea son demasiado largos, y para c√≠rculos peque√±os, perdemos tiempo dibujando segmentos muy peque√±os. Una soluci√≥n ser√≠a generalizar la funci√≥n tomando +n+ como par√°metro. Esto le dar√≠a al usuario (quien llama a c√≠rculo) m√°s control, pero la interfaz ser√≠a menos pulcra.

La _interfaz_ de una funci√≥n es un resumen de c√≥mo se usa: ¬øcu√°les son los par√°metros? ¬øQu√© hace la funci√≥n? ¬øY cu√°l es el valor de retorno? Una interfaz es "pulcra" si le permite al usuario que la llama hacer lo que quiera sin tener que lidiar con detalles innecesarios.
(((interface)))

En este ejemplo, +r+ pertenece a la interfaz porque especifica el c√≠rculo a dibujar. +n+ es menos apropiado porque se refiere a los detalles de c√≥mo se debe representar el c√≠rculo.

En lugar de saturar la interfaz, es mejor elegir un valor apropiado de +n+ dependiendo de la +circunferencia+:

[source,julia]
----
function circulo(t, r)
    circunferencia = 2 * œÄ * r
    n = trunc(circunferencia / 3) + 3
    len = circunferencia / n
    poligono(t, n, len)
end
----

Ahora, el n√∫mero de segmentos es un n√∫mero entero cercano a +circunferencia/3+, por lo que la longitud de cada segmento es aproximadamente 3, que es lo suficientemente peque√±o como para que los c√≠rculos se vean bien, pero lo suficientemente grandes como para ser eficientes y aceptables para cualquier c√≠rculo.

Agregar 3 a +n+ garantiza que el pol√≠gono tenga al menos 3 lados.


[[refactoring]]
=== Refactorizaci√≥n

Cuando escribimos +circulo+, pudimos reutilizar +poligono+ ya que un pol√≠gono de muchos lados es una buena aproximaci√≥n de un c√≠rculo. Pero +arco+ no es tan versatil; no podemos usar +poligono+ o +circulo+ para dibujar un arco.

Una alternativa es comenzar con una copia de +poligono+ y transformarla en +arco+. El resultado podr√≠a verse as√≠:
(((arc)))((("function", "programmer-defined", "arc", see="arc")))

[source,julia]
----
function arco(t, r, angulo)
    arco_lon = 2 * œÄ * r * angulo / 360
    n = trunc(arco_lon / 3) + 1
    paso_lon = arco_lon / n
    paso_angulo = angulo / n
    for i in 1:n
        forward(t, paso_lon)
        turn(t, -paso_angulo)
    end
end
----

La segunda mitad de esta funci√≥n se parece a +poligono+, pero no podemos reutilizar +poligono+ sin cambiar la interfaz. Podr√≠amos generalizar +poligono+ para tomar un +angulo+ como tercer argumento, ¬°pero entonces +poligono+ ya no ser√≠a un nombre apropiado! En su lugar, llamemos a esta funci√≥n m√°s general +polilinea+:
(((polyline)))((("function", "programmer-defined", "polyline", see="polyline")))

[source,julia]
----
function polilinea(t, n, lon, angulo)
    for i in 1:n
        forward(t, lon)
        turn(t, -angulo)
    end
end
----

Now we can rewrite +polygon+ and +arc+ to use +polyline+:
(((polygon)))(((arc)))

[source,julia]
----
function polygon(t, n, len)
    angle = 360 / n
    polyline(t, n, len, angle)
end

function arc(t, r, angle)
    arc_len = 2 * œÄ * r * angle / 360
    n = trunc(arc_len / 3) + 1
    step_len = arc_len / n
    step_angle = angle / n
    polyline(t, n, step_len, step_angle)
end
----

Finally, we can rewrite +circle+ to use +arc+:
(((circle)))

[source,julia]
----
function circle(t, r)
    arc(t, r, 360)
end
----

This process‚Äîrearranging a program to improve interfaces and facilitate code re-use‚Äîis called _refactoring_. In this case, we noticed that there was similar code in +arc+ and +polygon+, so we ‚Äúfactored it out‚Äù into +polyline+.
(((refactoring)))

If we had planned ahead, we might have written +polyline+ first and avoided refactoring, but often you don‚Äôt know enough at the beginning of a project to design all the interfaces. Once you start coding, you understand the problem better. Sometimes refactoring is a sign that you have learned something.


=== A Development Plan

A _development plan_ is a process for writing programs. The process we used in this case study is ‚Äúencapsulation and generalization‚Äù. The steps of this process are:
(((program development plan)))

. Start by writing a small program with no function definitions.

. Once you get the program working, identify a coherent piece of it, encapsulate the piece in a function and give it a name.

. Generalize the function by adding appropriate parameters.

. Repeat steps 1‚Äì3 until you have a set of working functions. Copy and paste working code to avoid retyping (and re-debugging).

. Look for opportunities to improve the program by refactoring. For example, if you have similar code in several places, consider factoring it into an appropriately general function.

This process has some drawbacks‚Äîwe will see alternatives later‚Äîbut it can be useful if you don‚Äôt know ahead of time how to divide the program into functions. This approach lets you design as you go along.


=== Docstring

A _docstring_ is a string before a function that explains the interface (‚Äúdoc‚Äù is short for ‚Äúdocumentation‚Äù). Here is an example:
(((docstring)))(((triple quotes)))((("pass:[&quot;&quot;&quot;]", see="triple quotes")))

[source,julia]
----
"""
polyline(t, n, len, angle)

Draws n line segments with the given length and
angle (in degrees) between them.  t is a turtle.
"""
function polyline(t, n, len, angle)
    for i in 1:n
        forward(t, len)
        turn(t, -angle)
    end
end
----

Documentation can be accessed in the REPL or in a notebook by typing ? followed by the name of a function or macro, and pressing +ENTER+:
(((help)))((("?", see="help")))

----
help?> polyline
search:

  polyline(t, n, len, angle)

  Draws n line segments with the given length and angle (in degrees) between them. t is a turtle.
----

Docstrings are often triple-quoted strings, also known as multiline strings because the triple quotes allow the string to span more than one line.

A docstring contains the essential information someone would need to use this function. It explains concisely what the function does (without getting into the details of how it does it). It explains what effect each parameter has on the behavior of the function and what type each parameter should be (if it is not obvious).

[TIP]
====
Writing this kind of documentation is an important part of interface design. A well-designed interface should be simple to explain; if you have a hard time explaining one of your functions, maybe the interface could be improved.
====


=== Debugging

An interface is like a contract between a function and a caller. The caller agrees to provide certain parameters and the function agrees to do certain work.
(((debugging)))

For example, +polyline+ requires four arguments: +t+ has to be a turtle; +n+ has to be an integer; +len+ should be a positive number; and +angle+ has to be a number, which is understood to be in degrees.

These requirements are called _preconditions_ because they are supposed to be true before the function starts executing. Conversely, conditions at the end of the function are _postconditions_. Postconditions include the intended effect of the function (like drawing line segments) and any side effects (like moving the turtle or making other changes).
(((precondition)))(((postcondition)))

Preconditions are the responsibility of the caller. If the caller violates a (properly documented!) precondition and the function doesn‚Äôt work correctly, the bug is in the caller, not the function.

If the preconditions are satisfied and the postconditions are not, the bug is in the function. If your pre- and postconditions are clear, they can help with debugging.


=== Glossary

module::
A file that contains a collection of related functions and other definitions.
(((module)))

package::
An external library with additional functionality.
(((package)))

using statement::
A statement that reads a module file and creates a module object.
(((using statement)))

loop::
A part of a program that can run repeatedly.
(((loop)))

encapsulation::
The process of transforming a sequence of statements into a function definition.
(((encapsulation)))

generalization::
The process of replacing something unnecessarily specific (like a number) with something appropriately general (like a variable or parameter).
(((generalization)))

interface::
A description of how to use a function, including the name and descriptions of the arguments and return value.
(((interface)))

refactoring::
The process of modifying a working program to improve function interfaces and other qualities of the code.
(((refactoring)))

development plan::
A process for writing programs.
(((program development plan)))

docstring::
A string that appears at the top of a function definition to document the function‚Äôs interface.
(((docstring)))

precondition::
A requirement that should be satisfied by the caller before a function starts.
(((precondition)))

postcondition::
A requirement that should be satisfied by the function before it ends.
(((postcondition)))


=== Exercises

[[ex04-7]]
==== Exercise 4-8

Enter the code in this chapter in a notebook.

. Draw a stack diagram that shows the state of the program while executing +circle(üê¢, radius)+. You can do the arithmetic by hand or add print statements to the code.

. The version of +arc+ in <<refactoring>> is not very accurate because the linear approximation of the circle is always outside the true circle. As a result, the turtle ends up a few pixels away from the correct destination. My solution shows a way to reduce the effect of this error. Read the code and see if it makes sense to you. If you draw a diagram, you might see how it works.
(((arc)))

[source,julia]
----
"""
arc(t, r, angle)

Draws an arc with the given radius and angle:

    t: turtle
    r: radius
    angle: angle subtended by the arc, in degrees
"""
function arc(t, r, angle)
    arc_len = 2 * œÄ * r * abs(angle) / 360
    n = trunc(arc_len / 4) + 3
    step_len = arc_len / n
    step_angle = angle / n

    # making a slight left turn before starting reduces
    # the error caused by the linear approximation of the arc
    turn(t, -step_angle/2)
    polyline(t, n, step_len, step_angle)
    turn(t, step_angle/2)
end
----

[[ex04-8]]
==== Exercise 4-9

Write an appropriately general set of functions that can draw flowers as in <<fig04-2>>.

[[fig04-2]]
.Turtle flowers
image::images/fig42.svg[]

[[ex04-9]]
==== Exercise 4-10

Write an appropriately general set of functions that can draw shapes as in <<fig04-3>>.

[[fig04-3]]
.Turtle pies
image::images/fig43.svg[]

[[ex04-10]]
==== Exercise 4-11

The letters of the alphabet can be constructed from a moderate number of basic elements, like vertical and horizontal lines and a few curves. Design an alphabet that can be drawn with a minimal number of basic elements and then write functions that draw the letters.

You should write one function for each letter, with names +draw_a+, +draw_b+, etc., and put your functions in a file named _letters.jl_.

[[ex04-11]]
==== Exercise 4-12

Read about spirals at https://en.wikipedia.org/wiki/Spiral; then write a program that draws an Archimedan spiral as in <<fig04-4>>.

[[fig04-4]]
.Archimedan spiral
image::images/fig44.svg[]
