[[chap04]]
== Estudio de Caso: Dise√±o de Interfaz

Este cap√≠tulo presenta un segundo estudio de caso, que muestra el proceso de dise√±ar funciones que trabajen en conjunto.

Se presentan gr√°ficos turtle, que es una forma de crear dibujos a trav√©s de la programaci√≥n. Los gr√°ficos turtle no est√°n incluidos en la Biblioteca Est√°ndar, por lo que se debe agregar el m√≥dulo IntroAJulia a su configuraci√≥n de Julia.

Los ejemplos de este cap√≠tulo se pueden ejecutar en un notebook gr√°fico en JuliaBox, el cual combina c√≥digo, texto formateado, matem√°ticas y multimedia en un solo documento (vea <<juliabox>>).
(((JuliaBox, notebook gr√°fico)))


=== Turtles

Un _modulo_ es un archivo que contiene una colecci√≥n de funciones relacionadas. Julia proporciona algunos m√≥dulos en su Biblioteca Est√°ndar. Adem√°s, es posible agregar m√°s funciones a una gran cantidad de _paquetes_ (https://juliaobserver.com).
(((modulo)))(((paquete)))

Los paquetes se pueden instalar en REPL ingresando al modo Pkg REPL con la tecla +]+.
(((])))(((IntroAJulia)))((("modulo", v√©ase "IntroAJulia")))

[source,jlcon]
----
(v1.2) pkg> add https://github.com/JuliaIntro/IntroAJulia.jl
----

Esto puede demorar un poco.

Antes de que podamos usar las funciones de un m√≥dulo, tenemos que importarlo con una sentencia +using+:
(((using)))((("palabra reservada", "using")))(((sentencia using)))

[source,@julia-repl-test]
----
julia> using IntroAJulia

julia> üê¢ = Turtle()
Luxor.Turtle(0.0, 0.0, true, 0.0, (0.0, 0.0, 0.0))
----

El m√≥dulo +IntroAJulia+ proporciona una funci√≥n llamada +Turtle+ (tortuga en espa√±ol) que crea un objeto +Luxor.Turtle+, el cual es asignado a una variable llamada +üê¢+ (*+\:turtle: TAB+*).
(((Turtle)))((("tipo", "Luxor", "Turtle", v√©ase "Turtle")))

Una vez que crea una tortuga, puede llamar a una funci√≥n para "moverla", y as√≠ hacer un dibujo con ella. Por ejemplo, para mover la tortuga hacia adelante (forward en ingl√©s):
(((forward)))((("funci√≥n", "IntroAJulia", "forward", v√©ase "forward")))

[source,julia]
----
@svg begin
    forward(üê¢, 100)
end
----

[[fig04-1]]
.Haciendo avanzar a la tortuga
image::images/fig41.svg[]


La palabra reservada +@svg+ ejecuta una macro que dibuja una imagen SVG. Las macros son una caracter√≠stica importante pero avanzada de Julia.
(((@svg)))((("macro", "Luxor", "@svg", v√©ase "@svg")))(((macro)))(((SVG picture)))

Los argumentos de +forward+ son la tortuga y una distancia en p√≠xeles, por lo que el tama√±o real depende de su pantalla.

Tambi√©n es posible hacer girar a la tortuga con la funci√≥n +turn+. Los argumentos de esta funci√≥n son la tortuga y un √°ngulo en grados.
(((turn)))((("funci√≥n", "IntroAJulia", "turn", v√©ase "turn")))

Adem√°s, cada tortuga est√° sosteniendo un l√°piz, que puede estar hacia arriba o hacia abajo; si el l√°piz est√° hacia abajo, la tortuga deja un rastro cuando se mueve. <<fig04-1>> muestra el rastro dejado por la tortuga. Las funciones +penup+ y +pendown+ significan "l√°piz hacia arriba" y "l√°piz hacia abajo".
(((penup)))((("funci√≥n", "IntroAJulia", "penup", v√©ase "penup")))(((pendown)))((("funci√≥n", "IntroAJulia", "pendown", v√©ase "pendown")))

Para dibujar un √°ngulo recto, modifique la llamada a la macro:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

==== Ejercicio 4-1

Ahora modifique la macro para que dibuje un cuadrado. ¬°No sigas hasta haberlo terminado!


[[simple_repetition]]
=== Repetici√≥n Simple

Es probable que haya escrito algo como esto:
(((repetition)))

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

Se puede hacer lo mismo de manera m√°s concisa con una sentencia +for+:
(((sentencia for)))(((for)))((("palabra reservada", "for")))(((in)))((("palabra reservada", "in")))

[source,@julia-repl-test]
----
julia> for i in 1:4
          println("¬°Hola!")
       end
¬°Hola!
¬°Hola!
¬°Hola!
¬°Hola!
----

Este es el uso m√°s simple de la sentencia +for+, aunque se ver√°n m√°s usos despu√©s. √âsto deber√≠a ser suficiente para reescribir su programa que dibuja un cuadrado. No contin√∫e hasta que lo haga.

Aqu√≠ hay una sentencia +for+ que dibuja un cuadrado:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    for i in 1:4
        forward(üê¢, 100)
        turn(üê¢, -90)
    end
end
----

La sintaxis de una sentencia +for+ es similar a la definici√≥n de una funci√≥n. Tiene un encabezado y un cuerpo que termina con la palabra reservada +end+. El cuerpo puede contener el n√∫mero de sentencias que desee.
(((end)))

Una sentencia +for+ tambi√©n es llamada _bucle_ porque el flujo de ejecuci√≥n recorre el cuerpo y luego vuelve a la parte superior. En este caso, ejecuta el cuerpo cuatro veces.
(((bucle)))

Esta versi√≥n es en realidad un poco diferente del c√≥digo anterior que dibujaba un cuadrado porque hace otro giro despu√©s de dibujar el √∫ltimo lado del cuadrado. El giro adicional lleva m√°s tiempo, pero simplifica el c√≥digo si se hace lo mismo en cada iteraci√≥n del ciclo. Esta versi√≥n tambi√©n tiene el efecto de dejar a la tortuga nuevamente en la posici√≥n inicial, mirando hacia la direcci√≥n inicial.

=== Ejercicios

Los siguientes ejercicios usan tortugas. Son divertidos, pero tambi√©n tienen un trasfondo. Mientras trabaja en ellos, piense cu√°l es ese trasfondo.

[TIP]
====
Las siguientes secciones muestran las soluciones para estos ejercicios, as√≠ que no mire hasta que haya terminado (o al menos lo haya intentado).
====

[[ex04-1]]
==== Ejercicio 4-2

Escriba una funci√≥n llamada +cuadrado+ que tome como par√°metro a un turtle +t+. Deber√≠a usar este turtle para dibujar un cuadrado.

[[ex04-2]]
==== Ejercicio 4-3

Escriba una llamada a funci√≥n que pase +t+ como argumento a +cuadrado+, y luego vuelva a ejecutar la macro.

[[ex04-3]]
==== Ejercicio 4-4

Agregue otro par√°metro, llamado +lon+, a cuadrado. Modifique el cuerpo para que la longitud de los lados sea +lon+, y luego modifique la llamada a funci√≥n agregando este segundo argumento. Ejecute la macro nuevamente. Pruebe con un rango de valores para +lon+.

[[ex04-4]]
==== Ejercicio 4-5

Haga una copia de +cuadrado+ y cambie su nombre a +pol√≠gono+. Agregue otro par√°metro llamado +n+ y modifique el cuerpo para que dibuje un pol√≠gono regular de latexmath:[n]-lados.

[TIP]
====
Los √°ngulos exteriores de un pol√≠gono regular de latexmath:[n]-lados son latexmath:[\frac{360}{n}] grados.
====

[[ex04-5]]
==== Ejercicio 4-6

Escriba una funci√≥n llamada +c√≠rculo+ que tome un turtle +t+ y un radio +r+ como par√°metros, y que dibuje un c√≠rculo aproximado llamando a +pol√≠gono+ con una longitud y n√∫mero de lados apropiados. Pruebe su funci√≥n con un rango de valores de +r+.

[TIP]
====
Calcule la circunferencia del c√≠rculo y aseg√∫rese de que +len * n == circunferencia+.
====

[[ex04-6]]
==== Ejercicio 4-7

Haga una versi√≥n m√°s general de +circulo+ llamada +arco+ que tome un par√°metro adicional +angulo+ y que determine qu√© fracci√≥n de un c√≠rculo dibujar. +angulo+ est√° en grados, entonces cuando +angulo= 360+, +arco+ deber√≠a dibujar un c√≠rculo completo.


=== Encapsulaci√≥n

El primer ejercicio le pide que coloque el c√≥digo que permite dibujar un cuadrado en una definici√≥n de funci√≥n, y que luego llame a la funci√≥n, pasando a turtle como par√°metro. Aqu√≠ hay una soluci√≥n:
(((cuadrado)))((("funci√≥n", "definida por el programador", "cuadrado", v√©ase "cuadrado")))

[source,julia]
----
function cuadrado(t)
    for i in 1:4
        forward(t, 100)
        turn(t, -90)
    end
end
üê¢ = Turtle()
@svg begin
    cuadrado(üê¢)
end
----

Las sentencias m√°s internas, +forward+ y +turn+ tienen doble sangr√≠a para mostrar que est√°n dentro del bucle +for+, que a su vez est√° dentro de la definici√≥n de funci√≥n.
(((indentaci√≥n)))

Dentro de la funci√≥n, +t+ se refiere a la misma tortuga +üê¢+, entonces +turn(t, -90)+ tiene el mismo efecto que +turn(üê¢, -90)+. En ese caso, ¬øpor qu√© no llamar al par√°metro +üê¢+? La raz√≥n es que +t+ puede ser cualquier tortuga, no solo +üê¢+, por lo que podr√≠amos crear una segunda tortuga y pasarla como argumento a +cuadrado+:

[source,julia]
----
üê´ = Turtle()
@svg begin
    cuadrado(üê´)
end
----

Colocar una porci√≥n de c√≥digo en una funci√≥n se denomina _encapsulaci√≥n_. Uno de los beneficios de la encapsulaci√≥n es que al ponerle un nombre al c√≥digo, esto sirve como una especie de documentaci√≥n. Otra ventaja es que si reutiliza el c√≥digo, ¬°es m√°s conciso llamar a una funci√≥n dos veces que copiar y pegar el cuerpo!
(((encapsulaci√≥n)))

=== Generalizaci√≥n

El siguiente paso es agregar un par√°metro +lon+ a +cuadrado+. Aqu√≠ hay una soluci√≥n:
(((square)))

[source,julia]
----
function cuadrado(t, lon)
    for i in 1:4
        forward(t, lon)
        turn(t, -90)
    end
end
üê¢ = Turtle()
@svg begin
    cuadrado(üê¢, 100)
end
----

Agregar un par√°metro a una funci√≥n se llama _generalizaci√≥n_ porque hace que la funci√≥n sea m√°s general: en la versi√≥n anterior, el cuadrado siempre ten√≠a el mismo tama√±o; en esta versi√≥n puede ser de cualquier tama√±o.
(((generalizaci√≥n)))

El siguiente paso tambi√©n es una generalizaci√≥n. En vez de dibujar cuadrados, +poligono+ dibuja pol√≠gonos regulares con cualquier n√∫mero de lados. Aqu√≠ hay una soluci√≥n:
(((pol√≠gono)))((("funci√≥n", "definida por el programador", "pol√≠gono", v√©ase "pol√≠gono")))

[source,julia]
----
function poligono(t, n, lon)
    angulo = 360 / n
    for i in 1:n
        forward(t, lon)
        turn(t, -angulo)
    end
end
üê¢ = Turtle()
@svg begin
    poligono(üê¢, 7, 70)
end
----

Este ejemplo dibuja un pol√≠gono de 7 lados, con una longitud de 70 por lado.


=== Dise√±o de Interfaz

El siguiente paso es escribir +circulo+, que toma un radio +r+ como par√°metro. Aqu√≠ hay una soluci√≥n simple que usa +poligono+ para dibujar un pol√≠gono de 50 lados:
(((c√≠rculo)))((("funci√≥n", "definida por el programador", "c√≠rculo", v√©ase "c√≠rculo")))

[source,julia]
----
function circulo(t, r)
    circunferencia = 2 * œÄ * r
    n = 50
    lon = circunferencia / n
    poligono(t, n, lon)
end
----

La primera l√≠nea calcula la circunferencia de un c√≠rculo con radio latexmath:[r] usando la f√≥rmula latexmath:[2 \pi r]. +n+ es el n√∫mero de segmentos de l√≠nea de nuestra aproximaci√≥n a un c√≠rculo, y +lon+ es la longitud de cada segmento. Por lo tanto, +pol√≠gono+ dibuja un pol√≠gono de 50 lados que se aproxima a un c√≠rculo de radio +r+.

Una limitante de esta soluci√≥n es que +n+ es constante, lo que significa que para c√≠rculos muy grandes, los segmentos de l√≠nea son demasiado largos, y para c√≠rculos peque√±os, perdemos tiempo dibujando segmentos muy peque√±os. Una soluci√≥n ser√≠a generalizar la funci√≥n tomando +n+ como par√°metro. Esto le dar√≠a al usuario (quien llama a c√≠rculo) m√°s control pero la interfaz ser√≠a menos pulcra.

La _interfaz_ de una funci√≥n es un resumen de c√≥mo se usa: ¬øcu√°les son los par√°metros? ¬øQu√© hace la funci√≥n? ¬øY cu√°l es el valor de retorno? Una interfaz es "pulcra" si le permite al usuario que la llama hacer lo que quiera sin tener que lidiar con detalles innecesarios.
(((interfaz)))

En este ejemplo, +r+ pertenece a la interfaz porque especifica el c√≠rculo a dibujar. +n+ es menos apropiado porque se refiere a los detalles de c√≥mo se debe representar el c√≠rculo.

En lugar de saturar la interfaz, es mejor elegir un valor apropiado de +n+ dependiendo de la +circunferencia+:

[source,julia]
----
function circulo(t, r)
    circunferencia = 2 * œÄ * r
    n = trunc(circunferencia / 3) + 3
    lon = circunferencia / n
    poligono(t, n, lon)
end
----

Ahora, el n√∫mero de segmentos es un n√∫mero entero cercano a +circunferencia/3+, por lo que la longitud de cada segmento es aproximadamente 3, que es lo suficientemente peque√±o como para que los c√≠rculos se vean bien, pero lo suficientemente grandes como para ser eficientes y aceptables para cualquier c√≠rculo.

Agregar 3 a +n+ garantiza que el pol√≠gono tenga al menos 3 lados.


[[refactorizaci√≥n]]
=== Refactorizaci√≥n

Cuando se escribi√≥ +circulo+, se pudo reutilizar +poligono+ ya que un pol√≠gono de muchos lados es una buena aproximaci√≥n de un c√≠rculo. Pero +arco+ no es tan vers√°til; no se puede usar +poligono+ o +circulo+ para dibujar un arco.

Una alternativa es comenzar con una copia de +poligono+ y transformarla en +arco+. El resultado podr√≠a verse as√≠:
(((arco)))((("funci√≥n", "programmer-defined", "arco", v√©ase "arco")))

[source,julia]
----
function arco(t, r, angulo)
    arco_lon = 2 * œÄ * r * angulo / 360
    n = trunc(arco_lon / 3) + 1
    paso_lon = arco_lon / n
    paso_angulo = angulo / n
    for i in 1:n
        forward(t, paso_lon)
        turn(t, -paso_angulo)
    end
end
----

La segunda mitad de esta funci√≥n se parece a +poligono+, pero no se puede reutilizar +poligono+ sin cambiar la interfaz. Se podr√≠a generalizar +poligono+ para tomar un +angulo+ como tercer argumento, ¬°pero entonces +poligono+ ya no ser√≠a un nombre apropiado! En su lugar, se puede llamar a esta funci√≥n m√°s general +polilinea+:
(((polyline)))((("funci√≥n", "definida por el programador", "polyline", v√©ase "polyline")))

[source,julia]
----
function polilinea(t, n, lon, angulo)
    for i in 1:n
        forward(t, lon)
        turn(t, -angulo)
    end
end
----

Ahora se puede reescribir +poligono+ y +arco+ usando +polilinea+:
(((polygon)))(((arc)))

[source,julia]
----
function poligono(t, n, lon)
    angulo = 360 / n
    polilinea(t, n, lon, angulo)
end

function arco(t, r, angulo)
    arco_lon = 2 * œÄ * r * angulo / 360
    n = trunc(arco_lon / 3) + 1
    paso_lon = arco_lon / n
    paso_angulo = angulo / n
    polilinea(t, n, paso_lon, paso_angulo)
end
----

Finalmente, se puede reescribir +circulo+ usando +arco+:
(((c√≠rculo)))

[source,julia]
----
function circulo(t, r)
    arco(t, r, 360)
end
----

Este proceso, que reorganiza un programa para mejorar las interfaces y facilitar la reutilizaci√≥n del c√≥digo, se denomina _refactorizaci√≥n_. En este caso, se observa que hab√≠a un c√≥digo similar en +arco+ y +poligono+, por lo que lo "factorizamos" en +polilinea+.
(((refactorizaci√≥n))

Si se hubiese planeado con anticipaci√≥n, se podr√≠a haber escrito +polilinea+ primero y haber evitado la refactorizaci√≥n, pero a menudo no se sabe lo suficiente al comienzo de un proyecto para dise√±ar todas las interfaces. Una vez que se comienza a programar, se comprende mejor el problema. A veces, refactorizar es una se√±al de que se ha aprendido algo.


=== Un Plan de Desarrollo

Un _plan de desarrollo de programa_ es un proceso para escribir programas. El proceso que se utiliza en este estudio de caso es "encapsulaci√≥n y generalizaci√≥n". Los pasos de este proceso son:
(((plan de desarrollo de programa)))

. Comience escribiendo un peque√±o programa sin definiciones de funciones.

. Una vez que el programa funcione, identifique una porci√≥n de c√≥digo que tenga un objetivo espec√≠fico, encapsule esta porci√≥n en una funci√≥n y as√≠gnele un nombre.

. Generalice la funci√≥n agregando los par√°metros apropiados.

. Repita los pasos 1‚Äì3 hasta que tenga un conjunto de funciones. De ser posible, copie y pegue c√≥digo para evitar volver a escribir (y volver a depurar).

. Busque oportunidades para mejorar el programa refactorizando. Por ejemplo, si tiene un c√≥digo similar en varios lugares, considere factorizarlo en una funci√≥n general apropiada.

Este proceso tiene algunos inconvenientes, se explorar√°n alternativas m√°s adelante, pero puede ser √∫til si no sabe de antemano c√≥mo dividir el programa en funciones. Este enfoque permite dise√±ar conforme se avanza.


=== Docstring

Un _docstring_ es una cadena que va antes de una funci√≥n y que explica la interfaz ("doc" es la abreviatura de "documentaci√≥n"). Aqu√≠ hay un ejemplo:
(((docstring)))(((comillas triples)))((("&quot;&quot;&quot;", v√©ase "comillas triples")))

[source,julia]
----
"""
polilinea(t, n, lon, angulo)

Dibuja n segmentos de l√≠nea de la longitud dada y con
√°ngulo entre ellos (en grados) dado. t es una tortuga.
"""
function polilinea(t, n, lon, angulo)
    for i in 1:n
        forward(t, lon)
        turn(t, -angulo)
    end
end
----

Se puede acceder a la documentaci√≥n en REPL o en un notebook escribiendo ? seguido del nombre de una funci√≥n o macro, y presionando +ENTER+:
(((help)))((("?", v√©ase "help")))

----
help?> polilinea
search:

  polilinea(t, n, lon, angulo)

  Dibuja n segmentos de l√≠nea de la longitud dada y con √°ngulo entre ellos (en grados) dado. t es una tortuga.
----

Los docstring generalmente son cadenas de comillas triples, tambi√©n conocidas como cadenas de l√≠neas m√∫ltiples ya que las comillas triples permiten que la cadena abarque m√°s de una l√≠nea.

Un docstring contiene la informaci√≥n esencial que alguien necesitar√≠a para usar esta funci√≥n. Explica de manera concisa lo que hace la funci√≥n (sin entrar en detalles sobre c√≥mo lo hace). Explica qu√© efecto tiene cada par√°metro en el comportamiento de la funci√≥n y de qu√© tipo debe ser cada par√°metro (si no es obvio).

[TIP]
====
Escribir este tipo de documentaci√≥n es una parte importante del dise√±o de la interfaz. Una interfaz bien dise√±ada debe ser simple de explicar; si tiene dificultades para explicar una de sus funciones, tal vez la interfaz podr√≠a mejorarse.
====


=== Depuraci√≥n

Una interfaz es como un contrato entre una funci√≥n y el usuario. El usuario acepta proporcionar ciertos par√°metros y la funci√≥n acepta hacer cierto trabajo.
(((depuraci√≥n)))

Por ejemplo, +polilinea+ requiere cuatro argumentos: +t+ tiene que ser una tortuga; +n+ tiene que ser un n√∫mero entero; +lon+ deber√≠a ser un n√∫mero positivo; y +angulo+ tiene que ser un n√∫mero, en grados.

Estos requisitos se llaman _precondiciones_ porque se supone que son verdaderos antes de que la funci√≥n comience a ejecutarse. Por el contrario, las condiciones al final de la funci√≥n son _postcondiciones_. Las postcondiciones incluyen el efecto deseado de la funci√≥n (como dibujar segmentos de l√≠nea) y cualquier efecto secundario (como mover la tortuga o hacer otros cambios).
(((precondici√≥n)))(((postcondici√≥n)))

Las condiciones previas son responsabilidad del usuario. Si el usuario viola una precondici√≥n (¬°debidamente documentada!) y la funci√≥n no funciona correctamente, el error est√° en el usuario, no en la funci√≥n.

Si se cumplen las precondiciones pero no las postcondiciones, el error est√° en la funci√≥n. Si sus pre y postcondiciones son claras, pueden ayudar con la depuraci√≥n.


=== Glosario

modulo::
Un archivo que contiene una colecci√≥n de funciones relacionadas y otras definiciones.
(((modulo)))

paquete::
Una biblioteca externa con m√°s funcionalidades.
(((paquete)))

sentencia using::
Una sentencia que lee un archivo de m√≥dulo y crea un objeto de m√≥dulo.
(((sentencia using)))

bucle::
Una parte de un programa que puede ejecutarse repetidamente.
(((bucle)))

encapsulaci√≥n::
El proceso de transformar una secuencia de sentencias en una definici√≥n de funci√≥n.
(((encapsulado)))

generalizaci√≥n::
El proceso de reemplazar algo innecesariamente espec√≠fico (como un n√∫mero) con algo m√°s general (como una variable o par√°metro).
(((generalizaci√≥n)))

interfaz::
Una descripci√≥n de c√≥mo usar una funci√≥n, incluido el nombre y las descripciones de los argumentos y el valor de retorno.
(((interfaz)))

refactorizaci√≥n::
El proceso de modificar un programa para mejorar las interfaces de las funciones y otras cualidades del c√≥digo.
(((refactorizaci√≥n)))

plan de desarrollo de programa::
Un proceso para escribir programas.
(((plan de desarrollo de programa)))

docstring::
Una cadena que aparece en la parte superior de una definici√≥n de funci√≥n para documentar la interfaz de la funci√≥n.
(((docstring)))

precondici√≥n::
Un requisito que debe cumplir el usuario antes de que comience una funci√≥n.
(((precondici√≥n)))

postcondici√≥n::
Un requisito que debe cumplir la funci√≥n antes de que finalice.
(((postcondici√≥n)))


=== Ejercicios

[[ex04-7]]
==== Ejercicio 4-8

Copie y pegue el c√≥digo de este cap√≠tulo en un notebook.

. Dibuje un diagrama de pila que muestre el estado del programa mientras ejecuta +circulo(üê¢, radio)+. Puede hacer la aritm√©tica a mano o agregar sentencias de impresi√≥n al c√≥digo.

. La versi√≥n de +arco+ en <<refactorizaci√≥n>> no es muy precisa ya que la aproximaci√≥n lineal del c√≠rculo siempre queda por afuera del c√≠rculo verdadero. Como resultado, la tortuga termina a unos pocos p√≠xeles del destino correcto. La siguiente soluci√≥n muestra una forma de reducir el efecto de este error. Lea el c√≥digo y vea si tiene sentido. Si dibuja un diagrama, es posible que entienda mejor c√≥mo funciona.
(((arco)))

[source,julia]
----
"""
arco(t, r, angulo)

Dibuja un arco con el radio y el √°ngulo dados:

    t: tortuga
    r: radio
    angulo: √°ngulo subtendido por el arco, en grados
"""
function arco(t, r, angulo)
    arco_lon = 2 * œÄ * r * abs(angulo) / 360
    n = trunc(arco_lon / 4) + 3
    paso_lon = arco_lon / n
    paso_angulo = angulo / n

    # haciendo un ligero giro a la izquierda antes de comenzar se reduce
    # el error causado por la aproximaci√≥n lineal del arco
    turn(t, -paso_angulo/2)
    polilinea(t, n, paso_lon, paso_angulo)
    turn(t, paso_angulo/2)
end
----

[[ex04-8]]
==== Ejercicio 4-9

Escriba un conjunto de funciones generales que permitan dibujar flores como en <<fig04-2>>.

[[fig04-2]]
.Flores con Turtle
image::images/fig42.svg[]

[[ex04-9]]
==== Ejercicio 4-10

Escriba un conjunto de funciones generales que puedan dibujar formas como en <<fig04-3>>.

[[fig04-3]]
.Pol√≠gonos con Turtle
image::images/fig43.svg[]

[[ex04-10]]
==== Ejercicio 4-11

Las letras del alfabeto se pueden construir a partir de un n√∫mero peque√±o de elementos b√°sicos, como l√≠neas verticales y horizontales, y algunas curvas. Dise√±e un alfabeto que se pueda dibujar con un n√∫mero m√≠nimo de elementos b√°sicos y luego escriba funciones que dibujen las letras.

Deber√≠a escribir una funci√≥n para cada letra, con nombres +dibujar_a+, +dibujar_b+, etc., y colocar sus funciones en un archivo llamado _letras.jl_.

[[ex04-11]]
==== Ejercicio 4-12

Lea sobre espirales en https://es.wikipedia.org/wiki/Espiral; luego escriba un programa que dibuje una espiral de Arqu√≠medes como en <<fig04-4>>.

[[fig04-4]]
.Espiral de Arqu√≠medes
image::images/fig44.svg[]
