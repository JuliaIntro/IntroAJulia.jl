<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Ben Lauwens y Allen Downey, Traducido por Pamela Alejandra Bustamante Faúndez">
<title>Piensa en Julia: Cómo Pensar como un Informático</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Piensa en Julia: Cómo Pensar como un Informático</h1>
<div class="details">
<span id="author" class="author">Ben Lauwens y Allen Downey</span><br>
<span id="author2" class="author">Traducido por Pamela Alejandra Bustamante Faúndez</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Tabla de Contenido</div>
<ul class="sectlevel1">
<li><a href="#_license">License</a></li>
<li><a href="#_dedicatoria">Dedicatoria</a></li>
<li><a href="#_prefacio">Prefacio</a>
<ul class="sectlevel2">
<li><a href="#_a_quién_está_dirigido_este_libro">¿A quién está dirigido este libro?</a></li>
<li><a href="#_para_quién_es_este_libro">¿Para quién es este libro?</a></li>
<li><a href="#_convenciones_utilizadas_en_este_libro">Convenciones utilizadas en este libro</a></li>
<li><a href="#_usando_los_códigos_de_ejemplo">Usando los códigos de ejemplo</a></li>
<li><a href="#_agradecimientos">Agradecimientos</a></li>
<li><a href="#_lista_de_colaboradores">Lista de Colaboradores</a></li>
</ul>
</li>
<li><a href="#chap01">1. El camino de la programación</a>
<ul class="sectlevel2">
<li><a href="#_qué_es_un_programa">¿Qué es un programa?</a></li>
<li><a href="#_ejecutando_julia">Ejecutando Julia</a></li>
<li><a href="#_el_primer_programa">El primer programa</a></li>
<li><a href="#_operadores_aritméticos">Operadores aritméticos</a></li>
<li><a href="#_valores_y_tipos">Valores y tipos</a></li>
<li><a href="#_lenguajes_formales_y_naturales">Lenguajes formales y naturales</a></li>
<li><a href="#_depuración">Depuración</a></li>
<li><a href="#_glosario">Glosario</a></li>
<li><a href="#_ejercicios">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap02">2. Variables, expresiones y sentencias</a>
<ul class="sectlevel2">
<li><a href="#_sentencias_de_asignación">Sentencias de asignación</a></li>
<li><a href="#_nombres_de_variables">Nombres de variables</a></li>
<li><a href="#_expresiones_y_sentencias">Expresiones y sentencias</a></li>
<li><a href="#_modo_script">Modo script</a></li>
<li><a href="#_orden_de_operaciones">Orden de operaciones</a></li>
<li><a href="#_operaciones_con_cadenas">Operaciones con cadenas</a></li>
<li><a href="#_comentarios">Comentarios</a></li>
<li><a href="#_depuración_2">Depuración</a></li>
<li><a href="#_glosario_2">Glosario</a></li>
<li><a href="#_ejercicios_2">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap03">3. Funciones</a>
<ul class="sectlevel2">
<li><a href="#_llamada_a_función">Llamada a función</a></li>
<li><a href="#_funciones_matemáticas">Funciones matemáticas</a></li>
<li><a href="#_composición">Composición</a></li>
<li><a href="#_agregar_nuevas_funciones">Agregar nuevas funciones</a></li>
<li><a href="#_definiciones_y_usos">Definiciones y usos</a></li>
<li><a href="#_flujo_de_ejecución">Flujo de ejecución</a></li>
<li><a href="#_parámetros_y_argumentos">Parámetros y argumentos</a></li>
<li><a href="#_las_variables_y_los_parámetros_son_locales">Las variables y los parámetros son locales</a></li>
<li><a href="#stack_diagrams">Diagramas de pila</a></li>
<li><a href="#_funciones_productivas_y_funciones_nulas">Funciones productivas y funciones nulas</a></li>
<li><a href="#_por_qué_se_necesitan_funciones">¿Por qué se necesitan funciones?</a></li>
<li><a href="#_depuración_3">Depuración</a></li>
<li><a href="#_glosario_3">Glosario</a></li>
<li><a href="#_ejercicios_3">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap04">4. Estudio de Caso: Diseño de Interfaz</a>
<ul class="sectlevel2">
<li><a href="#_turtles">Turtles</a></li>
<li><a href="#simple_repetition">Repetición Simple</a></li>
<li><a href="#_ejercicios_4">Ejercicios</a></li>
<li><a href="#_encapsulación">Encapsulación</a></li>
<li><a href="#_generalización">Generalización</a></li>
<li><a href="#_diseño_de_interfaz">Diseño de Interfaz</a></li>
<li><a href="#refactoring">Refactorización</a></li>
<li><a href="#_un_plan_de_desarrollo">Un Plan de Desarrollo</a></li>
<li><a href="#_docstring">Docstring</a></li>
<li><a href="#_depuración_4">Depuración</a></li>
<li><a href="#_glosario_4">Glosario</a></li>
<li><a href="#_ejercicios_5">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap05">5. Condicionales y recursividad</a>
<ul class="sectlevel2">
<li><a href="#_división_entera_de_tipo_piso_y_módulo">División entera de tipo piso y Módulo</a></li>
<li><a href="#_expresiones_booleanas">Expresiones booleanas</a></li>
<li><a href="#_operadores_lógicos">Operadores Lógicos</a></li>
<li><a href="#_ejecución_condicional">Ejecución Condicional</a></li>
<li><a href="#_ejecución_alternativa">Ejecución alternativa</a></li>
<li><a href="#_condicionales_encadenadas">Condicionales encadenadas</a></li>
<li><a href="#_condicionales_anidadas">Condicionales anidadas</a></li>
<li><a href="#recursividad">Recursividad</a></li>
<li><a href="#_diagramas_de_pila_para_funciones_recursivas">Diagramas de pila para funciones recursivas</a></li>
<li><a href="#_recursión_infinita">Recursión infinita</a></li>
<li><a href="#_entrada_por_teclado">Entrada por teclado</a></li>
<li><a href="#_depuración_5">Depuración</a></li>
<li><a href="#_glosario_5">Glosario</a></li>
<li><a href="#_ejercicios_6">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap06">6. Funciones productivas</a>
<ul class="sectlevel2">
<li><a href="#_valores_de_retorno">Valores de retorno</a></li>
<li><a href="#incremental_development">Desarrollo incremental</a></li>
<li><a href="#_composición_2">Composición</a></li>
<li><a href="#boolean_functions">Funciones Booleanas</a></li>
<li><a href="#_más_recursividad">Más recursividad</a></li>
<li><a href="#_salto_de_fe">Salto de fe</a></li>
<li><a href="#one_more_example">Un Ejemplo Más</a></li>
<li><a href="#_tipos_de_comprobación">Tipos de Comprobación</a></li>
<li><a href="#deb06">Depuración</a></li>
<li><a href="#_glossary">Glossary</a></li>
<li><a href="#_ejercicios_7">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap07">7. Iteración</a>
<ul class="sectlevel2">
<li><a href="#_asignación_múltiple">Asignación múltiple</a></li>
<li><a href="#_actualización_de_variables">Actualización de variables</a></li>
<li><a href="#_la_sentencia_while">La Sentencia <code>while</code></a></li>
<li><a href="#_break"><code>break</code></a></li>
<li><a href="#_continue"><code>continue</code></a></li>
<li><a href="#square_roots">Raíces Cuadradas</a></li>
<li><a href="#_algoritmos">Algoritmos</a></li>
<li><a href="#_depuración_6">Depuración</a></li>
<li><a href="#_glosario_6">Glosario</a></li>
<li><a href="#_ejercicios_8">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap08">8. Cadenas</a>
<ul class="sectlevel2">
<li><a href="#characters">Caracteres</a></li>
<li><a href="#_una_cadena_es_una_secuencia">Una Cadena es una Secuencia</a></li>
<li><a href="#_length"><code>length</code></a></li>
<li><a href="#_recorrido">Recorrido</a></li>
<li><a href="#_porciones_de_cadenas">Porciones de Cadenas</a></li>
<li><a href="#_las_cadenas_son_inmutables">Las Cadenas son Inmutables</a></li>
<li><a href="#_interpolación_de_cadenas">Interpolación de Cadenas</a></li>
<li><a href="#searching">Búsqueda</a></li>
<li><a href="#looping_and_counting">Iterando y contando</a></li>
<li><a href="#_librería_con_cadenas">Librería con cadenas</a></li>
<li><a href="#_el_operador">El operador <code>∈</code></a></li>
<li><a href="#_comparación_de_cadenas">Comparación de Cadenas</a></li>
<li><a href="#deb08">Depuración</a></li>
<li><a href="#_glosario_7">Glosario</a></li>
<li><a href="#_ejercicios_9">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap09">9. Estudio de Caso: Juego de Palabras</a>
<ul class="sectlevel2">
<li><a href="#reading_word_lists">Leer listas de palabras</a></li>
<li><a href="#_ejercicios_10">Ejercicios</a></li>
<li><a href="#search">Búsqueda</a></li>
<li><a href="#_bucle_con_índices">Bucle con índices</a></li>
<li><a href="#_depuración_7">Depuración</a></li>
<li><a href="#_glosario_8">Glosario</a></li>
<li><a href="#_ejercicios_11">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap10">10. Arreglos</a>
<ul class="sectlevel2">
<li><a href="#_un_arreglo_es_una_secuencia">Un arreglo es una secuencia</a></li>
<li><a href="#_los_arreglos_son_mutables">Los arreglos son mutables</a></li>
<li><a href="#_recorriendo_un_arreglo">Recorriendo un Arreglo</a></li>
<li><a href="#_porciones_de_arreglos">Porciones de arreglos</a></li>
<li><a href="#_librería_de_arreglos">Librería de Arreglos</a></li>
<li><a href="#_mapear_filtrar_y_reducir">Mapear, Filtrar y Reducir</a></li>
<li><a href="#_sintaxis_de_punto">Sintaxis de punto</a></li>
<li><a href="#_borrando_insertando_elementos">Borrando (Insertando) Elementos</a></li>
<li><a href="#_arreglos_y_cadenas">Arreglos y Cadenas</a></li>
<li><a href="#_objeto_y_valores">Objeto y Valores</a></li>
<li><a href="#_alias_poner_sobrenombres">Alias (poner sobrenombres)</a></li>
<li><a href="#_arreglos_como_argumentos">Arreglos como argumentos</a></li>
<li><a href="#_depuración_8">Depuración</a></li>
<li><a href="#_glosario_9">Glosario</a></li>
<li><a href="#_ejercicios_12">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap11">11. Diccionarios</a>
<ul class="sectlevel2">
<li><a href="#_un_diccionario_es_un_mapeo">Un Diccionario es un Mapeo</a></li>
<li><a href="#dictionary_collection_counters">Diccionario como una Colección de Frecuencias</a></li>
<li><a href="#_iteración_y_diccionarios">Iteración y Diccionarios</a></li>
<li><a href="#_búsqueda_inversa">Búsqueda inversa</a></li>
<li><a href="#_diccionarios_y_matrices">Diccionarios y Matrices</a></li>
<li><a href="#memos">Pistas</a></li>
<li><a href="#global_variables">Variables Globales</a></li>
<li><a href="#_depuración_9">Depuración</a></li>
<li><a href="#_glosario_10">Glosario</a></li>
<li><a href="#_ejercicios_13">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap12">12. Tuplas</a>
<ul class="sectlevel2">
<li><a href="#_las_tuplas_son_immutables">Las Tuplas son Immutables</a></li>
<li><a href="#_asignación_de_tupla">Asignación de tupla</a></li>
<li><a href="#_tuplas_como_valor_de_retorno">Tuplas como valor de retorno</a></li>
<li><a href="#_tupla_con_argumentos_de_longitud_variable">Tupla con Argumentos de Longitud Variable</a></li>
<li><a href="#_arreglos_y_tuplas">Arreglos y tuplas</a></li>
<li><a href="#_diccionarios_y_tuplas">Diccionarios y Tuplas</a></li>
<li><a href="#_secuencias_de_secuencias">Secuencias de Secuencias</a></li>
<li><a href="#_depuración_10">Depuración</a></li>
<li><a href="#_glosario_11">Glosario</a></li>
<li><a href="#_ejercicios_14">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap13">13. Estudio de Caso: Selección de Estructura de Datos</a>
<ul class="sectlevel2">
<li><a href="#_análisis_de_frecuencia_de_palabras">Análisis de Frecuencia de Palabras</a></li>
<li><a href="#_números_aleatorios">Números aleatorios</a></li>
<li><a href="#_histograma_de_palabras">Histograma de Palabras</a></li>
<li><a href="#_palabras_más_comunes">Palabras Más Comunes</a></li>
<li><a href="#_parametros_opcionales">Parametros Opcionales</a></li>
<li><a href="#dictionary_subtraction">Resta de Diccionario</a></li>
<li><a href="#_palabras_al_azar">Palabras al Azar</a></li>
<li><a href="#markov_analysis">Análisis de Markov</a></li>
<li><a href="#_estructuras_de_datos">Estructuras de Datos</a></li>
<li><a href="#_depuración_11">Depuración</a></li>
<li><a href="#_glosario_12">Glosario</a></li>
<li><a href="#_ejercicios_15">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap14">14. Archivos</a>
<ul class="sectlevel2">
<li><a href="#_persistencia">Persistencia</a></li>
<li><a href="#reading_and_writing">Lectura y Escritura</a></li>
<li><a href="#_formateo">Formateo</a></li>
<li><a href="#_nombre_de_archivo_y_ruta">Nombre de Archivo y Ruta</a></li>
<li><a href="#catching_exceptions">Captura de Excepciones</a></li>
<li><a href="#databases">Bases de datos</a></li>
<li><a href="#_serialización">Serialización</a></li>
<li><a href="#_objetos_de_comando">Objetos de Comando</a></li>
<li><a href="#_modulos">Modulos</a></li>
<li><a href="#_depuración_12">Depuración</a></li>
<li><a href="#_glosario_13">Glosario</a></li>
<li><a href="#_ejercicios_16">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap15">15. Estructuras y Objetos</a>
<ul class="sectlevel2">
<li><a href="#_tipos_compuestos">Tipos Compuestos</a></li>
<li><a href="#_las_estructuras_son_inmutables">Las Estructuras son Inmutables</a></li>
<li><a href="#_estructuras_mutables">Estructuras Mutables</a></li>
<li><a href="#_rectángulos">Rectángulos</a></li>
<li><a href="#_instancias_como_argumentos">Instancias como Argumentos</a></li>
<li><a href="#_instancias_como_valores_de_retorno">Instancias como Valores de Retorno</a></li>
<li><a href="#_copiado">Copiado</a></li>
<li><a href="#_depuración_13">Depuración</a></li>
<li><a href="#_glosario_14">Glosario</a></li>
<li><a href="#_ejercicios_17">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap16">16. Estructuras y Funciones</a>
<ul class="sectlevel2">
<li><a href="#time">Tiempo</a></li>
<li><a href="#_funciones_puras">Funciones Puras</a></li>
<li><a href="#modifiers">Modificadores</a></li>
<li><a href="#prototyping_versus_planning">Desarrollo de prototipos frente a la planificación</a></li>
<li><a href="#chap16_debugging">Depuración</a></li>
<li><a href="#_glosario_15">Glosario</a></li>
<li><a href="#_ejercicios_18">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap17">17. Dispatch Múltiple</a>
<ul class="sectlevel2">
<li><a href="#_declaraciones_de_tipo">Declaraciones de Tipo</a></li>
<li><a href="#_métodos">Métodos</a></li>
<li><a href="#_ejemplos_adicionales">Ejemplos Adicionales</a></li>
<li><a href="#constructor">Constructores</a></li>
<li><a href="#_show"><code>show</code></a></li>
<li><a href="#_sobrecarga_de_operadores">Sobrecarga de Operadores</a></li>
<li><a href="#_dispatch_múltiple">Dispatch Múltiple</a></li>
<li><a href="#_programación_genérica">Programación Genérica</a></li>
<li><a href="#_interfaz_e_implementación">Interfaz e implementación</a></li>
<li><a href="#_depuración_14">Depuración</a></li>
<li><a href="#_glosario_16">Glosario</a></li>
<li><a href="#_ejercicios_19">Ejercicios</a></li>
</ul>
</li>
<li><a href="#chap18">18. Subtipos</a>
<ul class="sectlevel2">
<li><a href="#_naipes">Naipes</a></li>
<li><a href="#_variables_globales">Variables Globales</a></li>
<li><a href="#_comparación_de_naipes">Comparación de naipes</a></li>
<li><a href="#_prueba_unitaria">Prueba unitaria</a></li>
<li><a href="#_mazos">Mazos</a></li>
<li><a href="#_añadir_eliminar_barajar_y_ordenar">Añadir, Eliminar, Barajar y Ordenar</a></li>
<li><a href="#_tipos_abstractos_y_subtipos">Tipos Abstractos y Subtipos</a></li>
<li><a href="#_tipos_abstractos_y_funciones">Tipos Abstractos y Funciones</a></li>
<li><a href="#_diagramas_de_tipos">Diagramas de tipos</a></li>
<li><a href="#interactive">Depuración</a></li>
<li><a href="#_encapsulado_de_datos">Encapsulado de Datos</a></li>
<li><a href="#_glosario_17">Glosario</a></li>
<li><a href="#_exercises">Exercises</a></li>
</ul>
</li>
<li><a href="#chap19">19. Extra: Sintaxis</a>
<ul class="sectlevel2">
<li><a href="#_tuplas_con_nombre">Tuplas con nombre</a></li>
<li><a href="#_funciones">Funciones</a></li>
<li><a href="#_bloques">Bloques</a></li>
<li><a href="#_estructuras_de_control">Estructuras de control</a></li>
<li><a href="#_tipos">Tipos</a></li>
<li><a href="#_métodos_2">Métodos</a></li>
<li><a href="#_constructores">Constructores</a></li>
<li><a href="#_conversión_y_promoción">Conversión y Promoción</a></li>
<li><a href="#_metaprogramación">Metaprogramación</a></li>
<li><a href="#_datos_faltantes">Datos Faltantes</a></li>
<li><a href="#_llamar_a_código_de_c_y_fortran">Llamar a Código de C y Fortran</a></li>
<li><a href="#_glossary_2">Glossary</a></li>
</ul>
</li>
<li><a href="#chap20">20. Extra: Base y Librería Estándar</a>
<ul class="sectlevel2">
<li><a href="#_midiendo_el_rendimiento">Midiendo el Rendimiento</a></li>
<li><a href="#collections_and_data_structures">Colecciones y Estructuras de Datos</a></li>
<li><a href="#_matemáticas">Matemáticas</a></li>
<li><a href="#_cadenas">Cadenas</a></li>
<li><a href="#_arreglos">Arreglos</a></li>
<li><a href="#_interfaces">Interfaces</a></li>
<li><a href="#_módulo_interactive_utilities">Módulo Interactive Utilities</a></li>
<li><a href="#_depuración_15">Depuración</a></li>
<li><a href="#_glosario_18">Glosario</a></li>
</ul>
</li>
<li><a href="#chap21">21. Depuración</a>
<ul class="sectlevel2">
<li><a href="#_errores_de_sintaxis">Errores de Sintaxis</a></li>
<li><a href="#_errores_en_tiempo_de_ejecución">Errores en Tiempo de Ejecución</a></li>
<li><a href="#_errores_semánticos">Errores Semánticos</a></li>
</ul>
</li>
<li><a href="#_entrada_de_unicode">Apéndice A: Entrada de Unicode</a></li>
<li><a href="#juliabox">Apéndice B: JuliaBox</a></li>
<li><a href="#cambios">Apéndice C: Cambios de ThinkJulia</a></li>
<li><a href="#_index">Index</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Este libro aún no está completamente terminado; Se realizarán más cambios en el texto a medida que se revise el libro.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_license">License</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright © 2018 Allen Downey, Ben Lauwens. Todos los derechos reservados.</p>
</div>
<div class="paragraph">
<p><a href="https://piensaenjulia.github.io/PiensaEnJulia.jl/latest/book.html">Este libro</a> está disponible bajo la <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.es">Licencia Creative Commons Atribución-NoComercial 3.0 No portada</a>. Es una traducción de <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html">ThinkJulia</a>, que tiene la misma licencia. Una lista de las diferencias entre ThinkJulia y este libro está disponible en <a href="#cambios">Apéndice C</a>.</p>
</div>
<div class="paragraph">
<p><strong>Ben Lauwens</strong> es profesor de matemáticas en Royal Military Academy (RMA Bélgica). Tiene un doctorado en ingeniería y maestrías de KU Leuven y RMA, y una licenciatura de RMA.</p>
</div>
<div class="paragraph">
<p><strong>Allen Downey</strong> es profesor de informática en Olin College of Engineering. Ha dado clases en Wellesley College, Colby College y U.C. Berkeley Tiene un doctorado en informática de U.C. Berkeley, y maestrías y licenciaturas del MIT.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dedicatoria">Dedicatoria</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para Emeline, Arnaud y Tibo.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_prefacio">Prefacio</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En enero de 2018 comencé a preparar un curso de programación pensado en estudiantes que no tuvieran experiencia previa en programación. Quería usar Julia como lenguaje de programación, y descubrí que no existía ningún libro para aprender a programar que usara Julia como primer lenguaje de programación. Hay tutoriales maravillosos que explican los conceptos clave de Julia, pero ninguno de ellos se dedicaba lo suficiente a enseñar a pensar como un programador.</p>
</div>
<div class="paragraph">
<p>Conocía el libro Think Python de Allen Downey que contiene todos los elementos clave para aprender a programar correctamente. Sin embargo, este libro se basa en el lenguaje de programación Python. Mi primer borrador del curso fue una mezcla de muchas referencias, pero a medida que trabajaba en él, el contenido comenzó a parecerse cada vez más a los capítulos de Think Python. La idea de desarrollar mi curso como base para traspasar ese libro a Julia se hizo realidad.</p>
</div>
<div class="paragraph">
<p>Todo el material estaba disponible en notebooks de Jupyter, en un repositorio de GitHub. Después de publicar un mensaje en el sitio Discourse de Julia sobre el progreso de mi curso, los comentarios fueron abrumadores. Aparentemente, un libro sobre conceptos básicos de programación con Julia como primer lenguaje de programación era algo que faltaba en el universo de Julia. Contacté a Allen para ver si podía iniciar oficialmente la versión de Think Python para Julia y su respuesta fue inmediata: "¡adelante!", me puso en contacto con su editor de O&#8217;Reilly Media y ahora, un año después, estoy haciendo los retoques finales a este libro.</p>
</div>
<div class="paragraph">
<p>Fue un camino difícil. En agosto de 2018 se lanzó Julia v1.0 y, como todos mis colegas programadores de Julia, tuve que hacer una migración del código. Todos los ejemplos en el libro se prueban durante la conversión de los archivos fuente a archivos ASCIIDoc compatibles con O&#8217;Reilly. Tanto la cadena de herramientas como el código de los ejemplos tenían que ser compatibles con Julia v1.0. Afortunadamente no hay conferencias en agosto&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Espero que disfrutes al trabajar con este libro, y que te ayude a aprender a programar y pensar como un informático, al menos un poquito.</p>
</div>
<div class="paragraph">
<p><em>Ben Lauwens</em></p>
</div>
<div class="sect2">
<h3 id="_a_quién_está_dirigido_este_libro">¿A quién está dirigido este libro?</h3>
<div class="paragraph">
<p>Julia fue lanzado originalmente en 2012 por Alan Edelman, Stefan Karpinski, Jeff Bezanson y Viral Shah. Es un lenguaje de programación gratuito y de código abierto.</p>
</div>
<div class="paragraph">
<p>La elección de un lenguaje de programación es siempre subjetiva. Para mí, las siguientes características de Julia son decisivas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Julia está desarrollado como un lenguaje de programación de alto rendimiento.</p>
</li>
<li>
<p>Julia usa dispatch múltiple que le permite al programador elegir entre diferentes patrones de programación de acuerdo a la aplicación.</p>
</li>
<li>
<p>Julia es un lenguaje de tipo dinámico que se puede usar fácilmente de forma interactiva.</p>
</li>
<li>
<p>Julia tiene una sintaxis de alto nivel que es fácil de aprender.</p>
</li>
<li>
<p>Julia es un lenguaje de programación con tipos opcionales, cuyos tipos de datos (definidos por el usuario) hacen que el código sea más claro y robusto.</p>
</li>
<li>
<p>Julia tiene una biblioteca estándar extendida y numerosos paquetes de terceros están disponibles.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Julia es un lenguaje de programación único, ya que resuelve el problema de los dos idiomas. No se necesita de ningún otro lenguaje de programación para escribir código de alto rendimiento. Esto no significa que ocurra automáticamente. Es responsabilidad del programador optimizar el código que produzca cuellos de botella, pero esto puede hacerse en Julia.</p>
</div>
</div>
<div class="sect2">
<h3 id="_para_quién_es_este_libro">¿Para quién es este libro?</h3>
<div class="paragraph">
<p>Este libro es para cualquier persona que quiera aprender a programar. No se requieren conocimientos previos formales.</p>
</div>
<div class="paragraph">
<p>Los nuevos conceptos se introducen gradualmente y los temas más avanzados se describen en capítulos posteriores.</p>
</div>
<div class="paragraph">
<p>Piensa en Julia puede ser usado como un curso de un semestre de nivel secundario o universitario.</p>
</div>
</div>
<div class="sect2">
<h3 id="_convenciones_utilizadas_en_este_libro">Convenciones utilizadas en este libro</h3>
<div class="paragraph">
<p>En este libro se utilizan las siguientes convenciones tipográficas:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Cursiva</em></dt>
<dd>
<p>Indica nuevos términos, URL, direcciones de correo electrónico, nombres de archivo y extensiones de archivo.</p>
</dd>
<dt class="hdlist1"><code>Ancho constante</code></dt>
<dd>
<p>Se utiliza para mostrar código de programas, así como dentro de los párrafos para referirse a elementos del programa como nombres de variables o funciones, bases de datos, tipos de datos, variables de entorno, sentencias y palabras reservadas.</p>
</dd>
<dt class="hdlist1"><strong><code>Ancho constante en negrita</code></strong></dt>
<dd>
<p>Muestra comandos u otro texto que el usuario debe escribir.</p>
</dd>
<dt class="hdlist1"><em><code>Ancho constante en cursiva</code></em></dt>
<dd>
<p>Muestra el texto que debe reemplazarse con valores proporcionados por el usuario o por valores determinados por el contexto.</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Esto indica consejo o sugerencia.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Nota</div>
</td>
<td class="content">
<div class="paragraph">
<p>Esto es una nota general.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>Esto indica una advertencia o precaución.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_usando_los_códigos_de_ejemplo">Usando los códigos de ejemplo</h3>
<div class="paragraph">
<p>Todo el código utilizado en este libro está disponible en un repositorio de Git en GitHub: <a href="https://github.com/PiensaEnJulia/PiensaEnJulia.jl" class="bare">https://github.com/PiensaEnJulia/PiensaEnJulia.jl</a>. Si no está familiarizado con Git, es un sistema de control de versiones que le permite realizar seguimiento a los archivos que componen un proyecto. Una colección de archivos controlados por Git se denomina "repositorio". GitHub es un servicio de hosting que proporciona almacenamiento para repositorios de Git y una interfaz web conveniente.</p>
</div>
<div class="paragraph">
<p>El siguiente paquete puede ser de utilidad, y se puede agregar directamente a Julia. Simplemente escriba <strong><code>add https://github.com/PiensaEnJulia/PiensaEnJulia.jl</code></strong> en el REPL, en modo Pkg.</p>
</div>
<div class="paragraph">
<p>La forma más fácil de ejecutar un código de Julia es en <a href="https://juliabox.com" class="bare">https://juliabox.com</a>, iniciando una sesión de prueba gratuita. Es posible utilizar la interfaz REPL y notebooks. Si desea que Julia esté instalada localmente en su computadora, puede descargar JuliaPro de Julia Computing gratuitamente desde <a href="https://juliacomputing.com/products/juliapro.html" class="bare">https://juliacomputing.com/products/juliapro.html</a>. Consiste en una versión reciente de Julia, el IDE de Juno basado en Atom y varios paquetes de Julia preinstalados. Si eres más aventurero, puedes descargar Julia desde <a href="https://julialang.org" class="bare">https://julialang.org</a>, instalar el editor que te gusta, por ejemplo Atom o Visual Studio Code, y activar los complementos para su integración de Julia. Para una instalación local, también puedes agregar el paquete <code>IJulia</code> y ejecutar un notebook Jupyter en su computadora.</p>
</div>
<div class="paragraph">
<p>Apreciamos, pero no requerimos, la atribución. Una atribución generalmente incluye el título, autor, editor y ISBN. Por ejemplo: “Piensa en Julia de Ben Lauwens y Allen B; Downey (O&#8217;Reilly). Copyright 2019 Allen Downey, Ben Lauwens, 978-1-492-04503-8."</p>
</div>
</div>
<div class="sect2">
<h3 id="_agradecimientos">Agradecimientos</h3>
<div class="paragraph">
<p>Realmente quiero agradecer a Allen por escribir Think Python y permitirme traspasar este libro a Julia. ¡Tu entusiasmo es contagioso!</p>
</div>
<div class="paragraph">
<p>También me gustaría agradecer a los revisores técnicos de este libro, que hicieron muchas sugerencias útiles: Tim Besard, Bart Janssens y David P. Sanders.</p>
</div>
<div class="paragraph">
<p>Gracias a Melissa Potter de O&#8217;Reilly Media por hacer de este un libro mejor. Me obligaste a hacer las cosas bien y hacer que este libro sea lo más original posible.</p>
</div>
<div class="paragraph">
<p>Gracias a Matt Hacker de O&#8217;Reilly Media que me ayudó con la cadena de herramientas Atlas y algunos problemas al destacar la sintaxis.</p>
</div>
<div class="paragraph">
<p>Gracias a todos los estudiantes que trabajaron con una versión temprana de este libro y a todos los colaboradores (enumerados a continuación) que enviaron correcciones y sugerencias.</p>
</div>
</div>
<div class="sect2">
<h3 id="_lista_de_colaboradores">Lista de Colaboradores</h3>
<div class="paragraph">
<p>Si tiene una sugerencia o corrección, envíe un correo electrónico a <a href="mailto:ben.lauwens@gmail.com">ben.lauwens@gmail.com</a> o abra un issue en GitHub. Si se realiza un cambio basado en sus comentarios, será agregado a la lista de contribuyentes (a menos que solicite ser omitido).</p>
</div>
<div class="paragraph">
<p>Avíseme con qué versión del libro está trabajando y en qué formato. Si incluye al menos parte de la oración en la que aparece el error, eso facilita la búsqueda. Los números de página y sección también son útiles, pero no es tan fácil trabajar con ellos. ¡Gracias!</p>
</div>
<div class="openblock small">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Scott Jones señaló el cambio de nombre de <code>Void</code> a <code>Nothing</code> y con esto se comenzó la migración a Julia v1.0</p>
</li>
<li>
<p>Robin Deits encontró algunos errores tipográficos en el Capítulo 2.</p>
</li>
<li>
<p>Mark Schmitz sugirió destacar la sintaxis.</p>
</li>
<li>
<p>Zigu Zhao encontró algunos errores en el Capítulo 8.</p>
</li>
<li>
<p>Oleg Soloviev detectó un error en la url al agregar el paquete <code>ThinkJulia</code>.</p>
</li>
<li>
<p>Aaron Ang encontró algunos problemas de representación y nomenclatura.</p>
</li>
<li>
<p>Sergey Volkov encontró un enlace caido en el Capítulo 7.</p>
</li>
<li>
<p>Sean McAllister sugirió mencionar el excelente paquete <code>BenchmarkTools</code>.</p>
</li>
<li>
<p>Carlos Bolech envió una larga lista de correcciones y sugerencias.</p>
</li>
<li>
<p>Krishna Kumar corrigió el ejemplo de Markov en el Capítulo 18.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 pagenumrestart">
<h2 id="chap01">1. El camino de la programación</h2>
<div class="sectionbody">
<div class="paragraph">
<p>El objetivo de este libro es enseñarle a pensar como un informático. Esta manera de pensar combina las mejores características de las matemáticas, la ingeniería y las ciencias naturales. Los informáticos, al igual que los matemáticos, usan lenguajes formales para expresar ideas (específicamente cálculos). También diseñan estructuras; ensamblan componentes para formar sistemas, y evalúan los costos y beneficios entre alternativas, tal como los ingenieros. Además, observan el comportamiento de sistemas complejos, elaboran hipótesis y prueban predicciones, como los científicos.</p>
</div>
<div class="paragraph">
<p>La habilidad más importante para un informático es la resolución de problemas. Esto implica ser capaz de formular problemas, pensar soluciones de manera creativa y poder expresar una solución clara y precisa. Como resultado, el proceso de aprender a programar es una excelente oportunidad para practicar habilidades de resolución de problemas. Es por ello que este capítulo se llama "El camino de la programación".</p>
</div>
<div class="paragraph">
<p>Por una parte, aprenderás a programar, lo cual es beneficioso por si solo. Por otra, la programación se constituirá como un medio para un fin. A medida que avancemos este fin será más claro.</p>
</div>
<div class="sect2">
<h3 id="_qué_es_un_programa">¿Qué es un programa?</h3>
<div class="paragraph">
<p>Un <em>programa</em> es una secuencia de instrucciones que especifican cómo hacer un cálculo. El cálculo puede ser de naturaleza matemática; tal como resolver un sistema de ecuaciones, o encontrar las raíces de un polinomio, pero también puede ser un cálculo simbólico; como encontrar y reemplazar texto en un documento, o bien algo gráfico; tal como procesar una imagen o reproducir un video.</p>
</div>
<div class="paragraph">
<p>Los detalles difieren para cada lenguaje, pero algunas instrucciones básicas aparecen en casi todos los lenguajes:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Input/Entrada</dt>
<dd>
<p>Se obtienen datos a través del teclado, un archivo, una red, u otro dispositivo.</p>
</dd>
<dt class="hdlist1">Salida/Output</dt>
<dd>
<p>Los datos se muestran por pantalla, se guardan en un archivo, se envían a través de la red, etc.</p>
</dd>
<dt class="hdlist1">Matemáticas</dt>
<dd>
<p>Se realizan operaciones matemáticas básicas como la suma y la multiplicación.</p>
</dd>
<dt class="hdlist1">Ejecución condicional </dt>
<dd>
<p>Se verifican ciertas condiciones y se ejecuta el código apropiado.</p>
</dd>
<dt class="hdlist1">Repetición</dt>
<dd>
<p>Se realiza alguna acción repetidamente, generalmente con alguna variación.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Aunque no lo creas, eso es todo lo que se debe hacer. Cada programa que has usado, sin importar su complejidad, está construido en base a instrucciones que se parecen bastante a estas. De esta manera, la programación puede entenderse como el proceso de dividir una tarea compleja y larga en pequeñas subtareas, lo suficientemente simples como para realizarse con una de estas instrucciones básicas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ejecutando_julia">Ejecutando Julia</h3>
<div class="paragraph">
<p>Uno de los desafíos para comenzar a utilizar Julia es su instalación, además del software relacionado. Si está familiarizado con su sistema operativo, y se siente cómodo con la interfaz de línea de comandos, no tendrá problemas. Pero para los principiantes puede ser difícil aprender sobre administración de sistema y programación al mismo tiempo.</p>
</div>
<div class="paragraph">
<p>Para evitar ese problema, recomiendo que comience ejecutando Julia en un navegador. Más tarde, cuando se sienta cómodo con Julia, se harán sugerencias para instalar Julia en su ordenador.</p>
</div>
<div class="paragraph">
<p>En el navegador, puede ejecutar Julia en <a href="https://www.juliabox.com">JuliaBox</a>. No se requiere instalación: simplemente abra su navegador y entre a la página de JuliaBox, inicie sesión y comience a programar (consulte <a href="#juliabox">JuliaBox</a>).</p>
</div>
<div class="paragraph">
<p>Julia <em>REPL</em> (Read–Eval–Print Loop) es un programa que lee y ejecuta código de Julia. Puede iniciar REPL abriendo un terminal en JuliaBox y escribiendo <strong><code>julia</code></strong> en la línea de comando. Cuando comienza, debería ver una salida como esta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.3.1 (2019-12-30)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |

julia&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Las primeras líneas contienen información sobre el REPL, por lo que esto puede lucir diferente en su ordenador. Debe verificar que la versión sea al menos <code>1.0.0</code>.</p>
</div>
<div class="paragraph">
<p>La última línea es un <em>prompt</em> que indica que el REPL está listo para que usted ingrese el código. Si escribe una línea de código y presiona Enter, REPL muestra el resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 1 + 1
2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los fragmentos de código se pueden copiar y pegar textualmente, incluido el prompt "<code>julia&gt;</code>" y cualquier salida.</p>
</div>
<div class="paragraph">
<p>Ahora estás listo para comenzar. De aquí en adelante, ya sabrás cómo iniciar Julia REPL y ejecutar el código.</p>
</div>
</div>
<div class="sect2">
<h3 id="_el_primer_programa">El primer programa</h3>
<div class="paragraph">
<p>Tradicionalmente, el primer programa que se escribe en un nuevo lenguaje se llama "¡Hola, mundo!" porque todo lo que hace es mostrar las palabras "¡Hola, mundo!". En Julia, se ve así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; println("¡Hola, mundo!")
¡Hola, mundo!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este  es un ejemplo de una <em>sentencia de impresión</em>, aunque en realidad no imprime nada en papel. Muestra un resultado en la pantalla.</p>
</div>
<div class="paragraph">
<p>Las comillas en el programa marcan el principio y el final del texto que se mostrará; no aparecen en el resultado.</p>
</div>
<div class="paragraph">
<p>Los paréntesis indican que <code>printl</code> es una función. Se estudiarán funciones en <a href="#chap03">Funciones</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_operadores_aritméticos">Operadores aritméticos</h3>
<div class="paragraph">
<p>Después de nuestro programa "¡Hola, Mundo!", el siguiente paso es la aritmética. Julia tiene <em>operadores</em>, los cuales son símbolos que representan cálculos como la suma y la multiplicación.</p>
</div>
<div class="paragraph">
<p>Los  operadores <code>+</code>, <code>-</code>, y <code>*</code> realizan sumas, restas y multiplicaciones respectivamente, como en los siguientes ejemplos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 40 + 2
42
julia&gt; 43 - 1
42
julia&gt; 6 * 7
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador <code>/</code> realiza la división:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 84/2
42.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quizás se pregunte por qué el resultado es <code>42.0</code> en vez de <code>42</code>. Esto será explicado en la siguiente sección.</p>
</div>
<div class="paragraph">
<p>Finalmente, el  operador <code>^</code> realiza potencias; es decir, eleva un número a una potencia:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 6^2 + 6
42</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_valores_y_tipos">Valores y tipos</h3>
<div class="paragraph">
<p>Un <em>valor</em>  es uno de los elementos básicos con los que trabaja un programa, tal como una letra o un número. Algunos de los valores que hemos visto hasta ahora son <code>2</code>, <code>42.0</code> y <code>"Hola, Mundo!"</code>.</p>
</div>
<div class="paragraph">
<p>Estos valores pertenecen a diferentes <em>tipos</em>: <code>2</code> es un <em>entero</em> (<em>integer</em> en inglés), <code>42.0</code> es un <em>número de punto flotante</em> (<em>floating-point number</em> en inglés), y <code>"Hola, Mundo!"</code> es una <em>cadena</em> (<em>string</em> en inglés), llamada así porque las letras que contiene están unidas.</p>
</div>
<div class="paragraph">
<p>Si no está seguro del tipo de un valor, el REPL puede ayudarle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; typeof(2)
Int64
julia&gt; typeof(42.0)
Float64
julia&gt; typeof("¡Hola, mundo!")
String</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los enteros pertenecen al tipo <code>Int64</code>, las cadenas pertenecen a <code>String</code> y los números de punto flotante pertenecen a <code>Float64</code>.</p>
</div>
<div class="paragraph">
<p>¿Qué  pasa con los valores "2" y "42.0"? Parecen números, pero están entre comillas como si fueran cadenas. Estos valores también son cadenas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; typeof("2")
String
julia&gt; typeof("42.0")
String</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si   quisiéramos escribir un número de grandes dimensiones, podríamos caer en la costumbre de usar comas para separar sus cifras, como por ejemplo 1,000,000. Este no es un <em>entero</em> válido en Julia, aunque sí es válido.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 1,000,000
(1, 0, 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>¡Esto no es lo que esperábamos! Julia entiende <code>1,000,000</code> como una secuencia de enteros separados por comas. Más adelante aprenderemos más sobre este tipo de secuencias.</p>
</div>
<div class="paragraph">
<p>Sin embargo, puedes   obtener el resultado esperado usando 1_000_000.</p>
</div>
</div>
<div class="sect2">
<h3 id="_lenguajes_formales_y_naturales">Lenguajes formales y naturales</h3>
<div class="paragraph">
<p><em>Los lenguajes naturales</em> son los idiomas hablados, como el español, inglés y francés. No fueron diseñados por personas (aunque las personas intentan imponerles un orden); sino que evolucionaron naturalmente.</p>
</div>
<div class="paragraph">
<p><em>Los lenguajes formales</em> son idiomas diseñados por personas para propósitos específicos. Por ejemplo, la notación que usan los matemáticos es un lenguaje formal particularmente útil para denotar relaciones entre números y símbolos. Los químicos usan un lenguaje formal para representar su estructura química de las moléculas. Los lenguajes de programación también son lenguajes formales, y han sido diseñados para expresar cálculos.</p>
</div>
<div class="paragraph">
<p>Los lenguajes formales tienden a tener reglas estrictas de sintaxis que gobiernan la estructura de las sentencias. Por ejemplo, en matemáticas, la sentencia \(3 + 3 = 6\) tiene la sintaxis correcta, pero \(3 += 3 \$ 6\) no. En química, \(\mathrm{H_2O}\) es una fórmula sintácticamente correcta, pero \(\mathrm{_2Zz}\) no lo es.</p>
</div>
<div class="paragraph">
<p>Las reglas de sintaxis    pueden ser de dos tipos, correspondientes a componentes léxicos y a la estructura. Los componentes léxicos son los elementos básicos del lenguaje, como palabras, números y elementos químicos. Uno de los problemas con \(3 += 3 \$ 6\) es que \(\$\) no es un componente léxico válido en matemáticas (al menos hasta donde conocemos). Del mismo modo, \(\mathrm{_2Zz}\) no es válido porque no hay ningún elemento con la abreviatura \(\mathrm{Zz}\).</p>
</div>
<div class="paragraph">
<p>El segundo tipo de regla de sintaxis se refiere a la forma en que se combinan los componentes léxicos. La ecuación \(3 += 3 \) no es válida porque aunque \(+\) y \(=\) son componentes léxicos válidos, no puedes tener uno justo después el otro. Del mismo modo, en una fórmula química, el subíndice viene después del nombre del elemento, no antes.</p>
</div>
<div class="paragraph">
<p>Esta es un@ oración en espa$ol bien estructurada con c*mponentes léxicos no válidos. Esta oración léxicos todos componentes los tiene, pero estructura una no válida con.</p>
</div>
<div class="paragraph">
<p>Cuando  lee una oración en español, o una sentencia en un idioma formal, tiene que descubrir la estructura (aunque en un lenguaje natural lo hace inconscientemente). Este proceso se llama <em>parsing</em> o <em>análisis de sintaxis</em>.</p>
</div>
<div class="paragraph">
<p>Aunque los lenguajes formales y naturales tienen muchas características en común (componentes léxicos, estructura y sintaxis), existen algunas diferencias:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Ambigüedad</dt>
<dd>
<p>Los lenguajes naturales están llenos de ambigüedad, esto es abordado mediante el uso del contexto y otro tipo de información. Los lenguajes formales están diseñados para ser casi o completamente inequívocos, lo que significa que cualquier declaración tiene exactamente un significado, independientemente del contexto.</p>
</dd>
<dt class="hdlist1">Redundancia</dt>
<dd>
<p>Para compensar la ambigüedad y reducir los malentendidos, los lenguajes naturales emplean mucha redundancia. Como resultado, a menudo tienen un uso excesivo de palabras. Los lenguajes formales son menos redundantes y más concisos.</p>
</dd>
<dt class="hdlist1">Literalidad </dt>
<dd>
<p>Los lenguajes naturales están llenos de modismos y metáforas. Si digo: "Caí en la cuenta", probablemente no haya una cuenta y nada se caiga (este modismo significa que alguien entendió algo después de un período de confusión). Los idiomas formales significan exactamente lo que dicen.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Debido a que todos crecemos hablando lenguajes naturales, a veces es difícil adaptarse a los lenguajes formales. La diferencia entre lenguaje formal y natural es como la diferencia entre poesía y prosa:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Poesía</dt>
<dd>
<p>Las palabras se usan por sus sonidos y significados. El poema en conjunto crea un efecto o una respuesta emocional. La ambigüedad no solo es común sino a menudo deliberada.</p>
</dd>
<dt class="hdlist1">Prosa</dt>
<dd>
<p>El significado literal de las palabras es más importante, y la estructura aporta significado. La prosa es más fácil de análizar que la poesía, pero a menudo sigue siendo ambigua.</p>
</dd>
<dt class="hdlist1">Programas </dt>
<dd>
<p>El significado de un programa computacional es inequívoco y literal, y puede entenderse por completo mediante el análisis de los componentes léxicos y la estructura.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Los lenguajes formales son más densos que los naturales, por lo que lleva más tiempo leerlos. Además, la estructura es importante, por lo que no siempre es mejor leer de arriba a abajo, y de izquierda a derecha. En cambio, aprenderás a analizar el programa mentalmente, identificando los componentes léxicos e interpretando la estructura. Finalmente, los detalles importan. Pequeños errores de ortografía y puntuación, que pueden pasar desapercibidos en los lenguajes naturales, pueden hacer una gran diferencia en un lenguaje formal .</p>
</div>
</div>
<div class="sect2">
<h3 id="_depuración">Depuración</h3>
<div class="paragraph">
<p>Los programadores cometen errores. Los errores de programación se denominan <em>bugs</em> y el proceso para rastrearlos se denomina <em>debugging</em> o <em>depuración</em>.</p>
</div>
<div class="paragraph">
<p>La programación, y especialmente la depuración, pueden provocar emociones negativas. Frente a un error difícil de solucionar, puedes sentir  enojo, verguenza, y cansancio.</p>
</div>
<div class="paragraph">
<p>Existe evidencia de que las personas responden naturalmente a las computadoras como si fueran personas. Cuando trabajan bien, los consideramos compañeros de equipo, y cuando son obstinados o groseros, les respondemos de la misma manera que respondemos a personas groseras y obstinadas. <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</div>
<div class="paragraph">
<p>Prepararse para estas reacciones puede ayudarlo a lidiar con ellas. Un enfoque es pensar en la computadora como un empleado con ciertas fortalezas, como la velocidad y la precisión, y debilidades particulares, como la falta de empatía y la incapacidad para comprender el panorama general.</p>
</div>
<div class="paragraph">
<p>Su trabajo es ser un buen gerente: debe encontrar formas de aprovechar las fortalezas y mitigar las debilidades. Y encontrar formas de usar sus emociones para involucrarse con el problema, sin dejar que sus reacciones interfieran con su capacidad para trabajar de manera efectiva.</p>
</div>
<div class="paragraph">
<p>Aprender a depurar puede ser frustrante, pero es una habilidad valiosa que es útil para muchas actividades más allá de la programación. Al final de cada capítulo hay una sección, como esta, con mis sugerencias para la depuración. ¡Espero que te ayuden!</p>
</div>
</div>
<div class="sect2">
<h3 id="_glosario">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">resolución de problemas </dt>
<dd>
<p>El proceso de formular un problema, encontrar una solución y expresarla.</p>
</dd>
<dt class="hdlist1">programa</dt>
<dd>
<p>Una secuencia de instrucciones que especifica un cálculo.</p>
</dd>
<dt class="hdlist1">REPL </dt>
<dd>
<p>Un programa que de manera reiterada lee una entrada, la ejecuta y genera resultados.</p>
</dd>
<dt class="hdlist1">prompt</dt>
<dd>
<p>Caracteres mostrados por el REPL para indicar que está listo para recibir información del usuario.</p>
</dd>
<dt class="hdlist1">sentencia de impresión (print)</dt>
<dd>
<p>Una instrucción que hace que Julia REPL muestre un valor en la pantalla.</p>
</dd>
<dt class="hdlist1">operador</dt>
<dd>
<p>Un símbolo que representa un cálculo simple como la suma, la multiplicación o la concatenación de cadenas.</p>
</dd>
<dt class="hdlist1">valor</dt>
<dd>
<p>Una de las unidades básicas de datos, como un número o cadena, que manipula un programa.</p>
</dd>
<dt class="hdlist1">tipo</dt>
<dd>
<p>Una categoría de valores . Los tipos que hemos visto hasta ahora son enteros (<code>Int64</code>), números de punto flotante (<code>Float64</code>) y cadenas (<code>String</code>).</p>
</dd>
<dt class="hdlist1">entero</dt>
<dd>
<p>Un tipo que representa números enteros.</p>
</dd>
<dt class="hdlist1">punto flotante</dt>
<dd>
<p>Un tipo que representa números con un punto decimal.</p>
</dd>
<dt class="hdlist1">cadena</dt>
<dd>
<p>Un tipo que representa secuencias de caracteres.</p>
</dd>
<dt class="hdlist1">lenguaje natural</dt>
<dd>
<p>Cualquier lenguaje hablado que evolucionó naturalmente.</p>
</dd>
<dt class="hdlist1">lenguaje formal</dt>
<dd>
<p>Cualquier lenguaje que se ha diseñado para fines específicos, como la representación de ideas matemáticas o programas de computadora. Todos los lenguajes de programación son lenguajes formales.</p>
</dd>
<dt class="hdlist1">sintaxis</dt>
<dd>
<p>Las reglas que gobiernan la estructura de un programa.</p>
</dd>
<dt class="hdlist1">componente léxico</dt>
<dd>
<p>Uno de los elementos básicos de la estructura de un programa, análogo a una palabra en un lenguaje natural.</p>
</dd>
<dt class="hdlist1">estructura</dt>
<dd>
<p>La manera en que los componentes léxicos se combinan.</p>
</dd>
<dt class="hdlist1">análisis de sintaxis</dt>
<dd>
<p>Examinar un programa y analizar la estructura sintáctica.</p>
</dd>
<dt class="hdlist1">bug</dt>
<dd>
<p>Un error en un programa.</p>
</dd>
<dt class="hdlist1">depuración/debugging </dt>
<dd>
<p>El proceso de búsqueda y corrección de errores.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios">Ejercicios</h3>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Es una buena idea leer este libro frente a un computador para que pueda hacer los ejemplos y ejercicios conforme avance.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ex01-1">Ejercicio 1-1</h4>
<div class="paragraph">
<p>Siempre que esté experimentando con algo nuevo, debe intentar cometer errores. Por ejemplo, en el programa "¡Hola, Mundo!", ¿Qué sucede si omite una de las comillas? ¿Qué pasa si omite ambas? ¿Qué pasa si escribe <code>println</code> mal?</p>
</div>
<div class="paragraph">
<p>Este tipo de ejercicios le ayuda a recordar lo que leyó; también le ayuda a programar, porque puede saber qué significan los mensajes de error. Es mejor cometer errores ahora y a propósito, en lugar de después y accidentalmente.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>En un comando print, ¿qué sucede si omite uno de los paréntesis, o ambos?</p>
</li>
<li>
<p>Si está intentando imprimir un <em>string</em>, ¿qué sucede si omite una de las comillas, o ambas?</p>
</li>
<li>
<p>Se puede usar un signo menos para escribir un número negativo, como <code>-2</code>. ¿Qué sucede si pone un signo + antes de un número? ¿Qué pasa con <code>2++2</code>?</p>
</li>
<li>
<p>En notación matemática, los ceros a la derecha no tienen implicancia, como 02. ¿Qué pasa si intenta esto en Julia?</p>
</li>
<li>
<p>¿Qué sucede si tiene dos valores sin operador entre ellos?</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="ex01-2">Ejercicio 1-2</h4>
<div class="paragraph">
<p>Inicie el Julia REPL y úselo como una calculadora.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>¿Cuántos segundos hay en 42 minutos y 42 segundos?</p>
</li>
<li>
<p>¿Cuántas millas hay en 10 kilómetros?</p>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Hay 1,61 kilómetros en una milla.</p>
</div>
</div>
</div>
</li>
<li>
<p>Si corres una carrera de 10 kilómetros en 37 minutos y 48 segundos, ¿cuál es tu ritmo promedio (tiempo por milla en minutos y segundos)? ¿Cuál es tu velocidad promedio en millas por hora?</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap02">2. Variables, expresiones y sentencias</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Una de las características más poderosas de un lenguaje de programación es la capacidad de manipular <em>variables</em>. Una variable es un nombre que hace referencia a un valor.
</p>
</div>
<div class="sect2">
<h3 id="_sentencias_de_asignación">Sentencias de asignación</h3>
<div class="paragraph">
<p>Una <em>sentencia de asignación</em> crea una nueva variable y le asigna un valor:
 </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; mensaje = "Y ahora, algo completamente diferente"
"Y ahora, algo completamente diferente"
julia&gt; n = 17
17
julia&gt; π_val = 3.141592653589793
3.141592653589793</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este ejemplo hace tres asignaciones. La primera asigna una cadena a una nueva variable llamada <code>mensaje</code>; la segunda le asigna a la variable <code>n</code> el entero <code>17</code>; el tercero asigna el valor (aproximado) de \(\pi\) a la variable <code>π_val</code> (<strong><code>\pi TAB</code></strong>).</p>
</div>
<div class="paragraph">
<p>Una forma común de representar variables en papel es escribir el nombre de la variable con una flecha apuntando a su valor. Este tipo de figura se llama "diagrama de estado" porque muestra en qué estado se encuentra cada una de las variables. La Figura 1, <a href="#fig02-1">Diagrama de estado</a>, muestra el resultado del ejemplo anterior.
</p>
</div>
<div id="fig02-1" class="imageblock">
<div class="content">
<img src="images/fig21.svg" alt="fig21">
</div>
<div class="title">Figura 1. Diagrama de estado</div>
</div>
</div>
<div class="sect2">
<h3 id="_nombres_de_variables">Nombres de variables</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Los programadores generalmente eligen nombres representativos para sus variables, es decir, nombres que explican para qué se usa o qué contiene la variable.</p>
</div>
<div class="paragraph">
<p>Los nombres de las variables pueden ser tan largos como se desee. Pueden contener casi todos los caracteres Unicode (consulte <a href="#caracteres">[caracteres]</a>), pero no pueden comenzar con un número. Es válido usar letras mayúsculas, pero lo común es usar solo minúsculas para nombres de variables.</p>
</div>
<div class="paragraph">
<p>Los caracteres Unicode se pueden ingresar mediante autocompletado por tabulación de las abreviaturas tipo LaTeX en el REPL de Julia.
</p>
</div>
<div class="paragraph">
<p>El carácter guión bajo, <code>_</code>, puede formar parte del nombre de una variable. Generalmente se usa como separador en nombres con varias palabras, como por ejemplo en <code>tu_nombre</code> o <code>velocidad_aerodinámica_de_una_golondrina_sin_cargamento</code>.
</p>
</div>
<div class="paragraph">
<p>Si le das un nombre inválido a una variable, tendrás un error de sintaxis:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 76trombones = "un gran desfile"
ERROR: syntax: "76" is not a valid function argument name (ERROR: sintaxis: "76" no es un nombre de argumento de función válido)
julia&gt; mas@ = 1000000
ERROR: syntax: extra token "@" after end of expression (ERROR: sintaxis: componente léxico adicional "@" después del final de la expresión)
julia&gt; struct = "Química avanzada"
ERROR: syntax: unexpected "=" (ERROR: sintaxis: "=" inesperado)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>76trombones</code> es un nombre de variable inválido porque comienza con un número. También es inválido <code>mas@</code> porque contiene el carácter inválido: <code>@</code>. Pero, ¿cuál es el error en <code>struct</code>?</p>
</div>
<div class="paragraph">
<p>Resulta que <code>struct</code> es una de las <em>palabras reservadas</em> de Julia. Julia usa las palabras reservadas para reconocer la estructura del programa, por ello no pueden usarse como nombres de variables.
</p>
</div>
<div class="paragraph">
<p>Julia tiene las siguientes palabras reservadas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>abstract type    baremodule   begin      break       catch
const            continue     do         else        elseif
end              export       finally    for         function
global           if           import     importall   in
let              local        macro      module      mutable struct
primitive type   quote        return     try         using
struct           where        while</pre>
</div>
</div>
<div class="paragraph">
<p>No es necesario memorizar esta lista. En la mayoría de los entornos de desarrollo, las palabras reservadas se muestran en un color diferente; por lo tanto, si intenta usar una como nombre de variable, lo sabrá.</p>
</div>
</div>
<div class="sect2">
<h3 id="_expresiones_y_sentencias">Expresiones y sentencias</h3>
<div class="paragraph">
<p>Una <em>expresión</em> es una combinación de valores, variables y operadores. Un valor o una variable por sí solos se consideran una expresión, por lo que las siguientes expresiones son válidas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 42
42
julia&gt; n
17
julia&gt; n + 25
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando escribe una expresión en el prompt, REPL la <em>evalúa</em>, lo que significa que encuentra el valor de la expresión. En este ejemplo, <code>n</code> tiene el valor 17 previamente asignado y <code>n+25</code> retorna el valor 42.
</p>
</div>
<div class="paragraph">
<p>Una <em>sentencia</em> es una unidad de código que tiene un efecto, tal como crear una variable o mostrar un valor.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; n = 17
17
julia&gt; println(n)
17</code></pre>
</div>
</div>
<div class="paragraph">
<p>La primera línea es una sentencia de asignación, ya que asigna un valor a <code>n</code>. La segunda línea es una sentencia de impresión que muestra el valor de <code>n</code>.</p>
</div>
<div class="paragraph">
<p>Cuando escribe una sentencia, REPL la ejecuta, es decir, hace lo que dice la sentencia.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_modo_script">Modo script</h3>
<div class="paragraph">
<p>Hasta ahora hemos ejecutado Julia en <em>modo interactivo</em>, lo que significa que hemos interactuado directamente con el REPL. El modo interactivo es una buena manera de comenzar, pero si está trabajando con varias líneas de código, puede resultar incomodo.
</p>
</div>
<div class="paragraph">
<p>Una alternativa es guardar el código en un archivo de órdenes o <em>script</em> y luego utilizar Julia en <em>modo script</em> para ejecutarlo. Por convención, los scripts de Julia tienen nombres que terminan en <em>.jl</em>.
</p>
</div>
<div class="paragraph">
<p>Si sabe cómo crear y ejecutar un <em>script</em> en su computadora, está listo para comenzar. De lo contrario, es recomendable usar JuliaBox nuevamente. Abra un archivo de texto, escriba el script y guárdelo con una extensión <em>.jl</em>. El script se puede ejecutar en una terminal con el comando <strong><code>julia nombre_del_script.jl</code></strong>.
</p>
</div>
<div class="paragraph">
<p>Debido a que Julia proporciona ambos modos, puede probar líneas de código en modo interactivo antes de colocarlos en un script. Aún así, tenga en consideración que existen diferencias entre el modo interactivo y el modo script que pueden generar confusión.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si está utilizando Julia como una calculadora, puede escribir</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; millas = 26.2
26.2
julia&gt; millas * 1.61
42.182</code></pre>
</div>
</div>
<div class="paragraph">
<p>La primera línea asigna un valor a <code>millas</code> y muestra el valor. La segunda línea es una expresión, por lo que REPL la evalúa y muestra el resultado. Gracias al código anterior sabemos que una maratón tiene unos 42 kilómetros.</p>
</div>
<div class="paragraph">
<p>Pero si escribe el mismo código en un script y lo ejecuta, no obtendrá ningún resultado. En el modo script, una expresión, por sí sola, no tiene ningún efecto visible. Julia evalúa la expresión, pero no muestra el valor a menos que se lo indique:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">millas = 26.2
println(millas * 1.61)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Al principio este comportamiento puede ser confuso.</p>
</div>
<div class="paragraph">
<p>Un script generalmente contiene una secuencia de sentencias. Si hay más de una sentencia, los resultados aparecen de uno a la vez a medida que se ejecutan las sentencias.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, el script</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">println(1)
x = 2
println(x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>produce la salida</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2</pre>
</div>
</div>
<div class="paragraph">
<p>Notar que la sentencia de asignación <code>x = 2</code> no tiene salida.</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_2_1">Ejercicio 2-1</h4>
<div class="paragraph">
<p>Para comprobar si ha comprendido, escriba las siguientes sentencias en Julia REPL y vea lo que hace cada una:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">5
x = 5
x + 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora coloque las mismas sentencias en un script y ejecútelo. ¿Cuál es el resultado? Modifique el script transformando cada expresión en una sentencia de impresión y luego ejecútelo de nuevo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_orden_de_operaciones">Orden de operaciones</h3>
<div class="paragraph">
<p>Cuando una expresión contiene más de un operador, el orden de evaluación depende de las <em>reglas de precedencia</em>. Julia sigue la convención matemática para el order de evaluación de los operadores matemáticos. El acrónimo <em>PAPOMUDAS</em> es una forma útil de recordar estas reglas:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>PA</em>réntesis: tienen la mayor precedencia y se pueden utilizar para forzar la evaluación de una expresión en el orden que desee. Dado que las expresiones entre paréntesis se evalúan primero, <code>2*(3-1)</code> es 4, y <code>(1+1)^(5-2)</code> es 8. También puede usar paréntesis para hacer una expresión más fácil de leer, como en <code>(minuto*100)/60</code>, incluso si no cambia el resultado.
</p>
</li>
<li>
<p><em>PO</em>tenciación: tiene la siguiente precedencia más alta, por lo que <code>1+2^3</code> es 9, no 27, y <code>2*3^2</code> es 18, no 36.
</p>
</li>
<li>
<p><em>MU</em>ltiplicación y <em>D</em>ivisión tienen mayor precedencia que la <em>A</em>dición y <em>S</em>ustracción. Entonces <code>2*3-1</code> es 5, no 4, y <code>6+4/2</code> es 8, no 5.
</p>
</li>
<li>
<p>Los operadores con la misma precedencia se evalúan de izquierda a derecha (excepto potencias). Entonces, en la expresión <code>grados/2*π</code>, la división ocurre primero y el resultado se multiplica por <code>π</code>. Para dividir entre \(2\pi\), puede usar paréntesis, escribir <code>grados/2/π</code> o <code>grados/2π</code>.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>No se esfuerce demasiado en recordar el orden de las operaciones. Si el orden no es evidente mirando la expresión, use paréntesis para que sí lo sea.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operaciones_con_cadenas">Operaciones con cadenas</h3>
<div class="paragraph">
<p>En general, no se puede realizar operaciones matemáticas con cadenas, incluso si las cadenas parecen números, por lo que lo siguiente es inválido:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">"2" - "1"
"huevos" / "fácil"
"tercero" + "talismán"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pero hay dos excepciones, <code><strong></code> y <code>^</code>.
 </p>
</div>
<div class="paragraph">
<p>El operador <code>*</code> realiza <em>concatenación de cadenas</em>, lo que significa que une las cadenas de extremo a extremo. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; primer_str = "auto"
"auto"
julia&gt; segundo_str = "móvil"
"móvil"
julia&gt; primer_str * segundo_str
"automóvil"</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador <code>^</code> también funciona con cadenas; realiza repeticiones. Por ejemplo, <code>"Spam"^3</code> es <code>"SpamSpamSpam"</code>. Si uno de los valores es una cadena, el otro tiene que ser un número entero.
</p>
</div>
<div class="paragraph">
<p>De manera análoga, este uso de <code>*</code> y <code>^</code> también tiene sentido en la multiplicación y potencia. Así como <code>4^3</code> es equivalente a <code>4*4*4</code>, esperamos que el <code>"Spam"^3</code> sea lo mismo que el <code>"Spam"*"Spam"*"Spam"</code>, y lo es.</p>
</div>
</div>
<div class="sect2">
<h3 id="_comentarios">Comentarios</h3>
<div class="paragraph">
<p>A medida que los programas se hacen más largos y complejos, se vuelven más difíciles de leer. Los lenguajes formales son densos, y a menudo es difícil leer el código y entender qué está haciendo o por qué.</p>
</div>
<div class="paragraph">
<p>Por esta razón, es una buena idea agregar notas a sus programas para explicar en lenguaje natural lo que está haciendo el programa. Estas notas se llaman <em>comentarios</em>, y comienzan con el símbolo <code>#</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia"># calcula el porcentaje de hora que ha transcurrido
porcentaje = (minuto * 100) / 60</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este caso, el comentario aparece solo en una línea. También puede poner comentarios al final de una línea:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">porcentaje = (minuto * 100) / 60    # porcentaje de una hora</code></pre>
</div>
</div>
<div class="paragraph">
<p>Todo, desde el <code>#</code> hasta el final de la línea se ignora, no tiene ningún efecto en la ejecución del programa.</p>
</div>
<div class="paragraph">
<p>Los comentarios son más útiles cuando documentan características no obvias del código. Es razonable suponer que el lector puede averiguar qué hace el código, por lo tanto es más útil explicar <em>por qué</em>.</p>
</div>
<div class="paragraph">
<p>Este comentario es inútil porque es redundante con el código:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">v = 5   # asigna 5 a v</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este comentario contiene información útil que no está presente en el código:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">v = 5   # velocidad en metros/segundo.</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Los nombres de las variables tienen que ser descriptivos pueden reducir la necesidad de comentarios, pero no tan largos como para dificultar la lectura del código.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_2">Depuración</h3>
<div class="paragraph">
<p>Se pueden producir tres tipos de errores en un programa: errores de sintaxis, errores en tiempo de ejecución, y errores semánticos. Es útil distinguirlos para rastrearlos más rápidamente.
</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Error de sintaxis</dt>
<dd>
<p>"Sintaxis" se refiere a la estructura de un programa y las reglas sobre esa estructura. Por ejemplo, los paréntesis deben presentarse de a pares, por lo que <code>(1+2)</code> es válido, pero <code>8)</code> es un error de sintaxis.</p>
<div class="paragraph">
<p>Si hay un error de sintaxis en cualquier parte de su programa, Julia muestra un mensaje de error y se cierra, no pudiendo ejecutar el programa. Durante sus primeras semanas como programador, puede pasar mucho tiempo rastreando errores de sintaxis. A medida que gane experiencia, cometerá menos errores y los encontrará más rápido.
</p>
</div>
</dd>
<dt class="hdlist1">Error en tiempo de ejecución</dt>
<dd>
<p>El segundo tipo de error es el error en tiempo de ejecución, llamado así porque aparece durante la ejecución del programa. Estos errores también se denominan <em>excepciones</em> porque generalmente indican que ha sucedido algo excepcional (y malo).</p>
<div class="paragraph">
<p>Los errores de tiempo de ejecución son raros en los programas simples que verá en los primeros capítulos, por lo que puede pasar un tiempo antes de que encuentre uno.
</p>
</div>
</dd>
<dt class="hdlist1">Error semántico </dt>
<dd>
<p>El tercer tipo de error es "semántico", es decir, relacionado con el significado. Si hay un error semántico en su programa, se ejecutará sin generar mensajes de error, pero no hará lo correcto. Hará algo más. Específicamente, hará lo que usted le dijo que hiciera.</p>
<div class="paragraph">
<p>Identificar errores semánticos puede ser complicado porque requiere que trabajes a la inversa, analizando la salida del programa para intentar descubrir qué está haciendo.
 </p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_2">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">variable</dt>
<dd>
<p>Un nombre que hace referencia a un valor.
</p>
</dd>
<dt class="hdlist1">asignación</dt>
<dd>
<p>Una sentencia que asigna un valor a una variable
</p>
</dd>
<dt class="hdlist1">diagrama de estado</dt>
<dd>
<p>Una representación gráfica de un conjunto de variables y los valores a los que hace referencia.
</p>
</dd>
<dt class="hdlist1">palabra clave</dt>
<dd>
<p>Una palabra reservada que se utiliza para definir la sintaxis y estructura de un programa; no puede usar palabras reservadas como <code>if</code>, <code>function</code> y <code>while</code> como nombres de variables.
</p>
</dd>
<dt class="hdlist1">operando </dt>
<dd>
<p>Uno de los valores en los que opera un operador.
</p>
</dd>
<dt class="hdlist1">expresión</dt>
<dd>
<p>Una combinación de variables, operadores y valores que representa un solo valor como resultado.
</p>
</dd>
<dt class="hdlist1">evaluar</dt>
<dd>
<p>Simplificar una expresión realizando operaciones para obtener un solo valor.
</p>
</dd>
<dt class="hdlist1">sentencia</dt>
<dd>
<p>Una sección de código que representa un comando o acción. Hasta ahora, las sentencias que hemos visto son asignaciones e impresiones.
</p>
</dd>
<dt class="hdlist1">ejecutar</dt>
<dd>
<p>Ejecutar una sentencia y hacer lo que esta dice.
</p>
</dd>
<dt class="hdlist1">modo interactivo</dt>
<dd>
<p>Una forma de utilizar el REPL de Julia escribiendo código en el <em>prompt</em>.
</p>
</dd>
<dt class="hdlist1">modo script</dt>
<dd>
<p>Una forma de usar Julia para leer código desde un script y ejecutarlo.
</p>
</dd>
<dt class="hdlist1">script</dt>
<dd>
<p>Un programa almacenado en un archivo.
</p>
</dd>
<dt class="hdlist1">precedencia del operador </dt>
<dd>
<p>Reglas que rigen el orden en que se evalúan las expresiones que involucran múltiples operadores matemáticos y operandos.
</p>
</dd>
<dt class="hdlist1">concatenar</dt>
<dd>
<p>Unir dos cadenas de extremo a extremo.
</p>
</dd>
<dt class="hdlist1">comentario</dt>
<dd>
<p>Información en un programa que está destinada a otros programadores (o cualquier persona que lea el código fuente) y que no tiene efecto en la ejecución del programa.
</p>
</dd>
<dt class="hdlist1">error de sintaxis</dt>
<dd>
<p>Un error en un programa que hace que sea imposible de analizar (y, por lo tanto, imposible de ejecutar).
</p>
</dd>
<dt class="hdlist1">error en tiempo de ejecución o excepción </dt>
<dd>
<p>Un error que se detecta mientras se ejecuta el programa.
</p>
</dd>
<dt class="hdlist1">semántica</dt>
<dd>
<p>El significado de un programa.
</p>
</dd>
<dt class="hdlist1">error semántico </dt>
<dd>
<p>Un error en un programa que hace que haga algo diferente a lo que pretendía el programador.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_2">Ejercicios</h3>
<div class="sect3">
<h4 id="ex02-1">Ejercicio 2-2</h4>
<div class="paragraph">
<p>Repitiendo el consejo del capítulo anterior, cada vez que aprenda algo nuevo, debe probarlo en el modo interactivo y cometer errores a propósito para ver el resultado.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Hemos visto que <code>n=42</code> es válido. ¿Qué pasa con <code>42=n</code>?</p>
</li>
<li>
<p>¿Y con <code>x=y=1</code>?</p>
</li>
<li>
<p>En algunos lenguajes, cada sentencia termina con un punto y coma, <code>;</code>. ¿Qué sucede si pones un punto y coma al final de una sentencia en Julia?
</p>
</li>
<li>
<p>¿Qué pasa si pones un punto al final de una sentencia?</p>
</li>
<li>
<p>En notación matemática puedes multiplicar <code>x</code> e <code>y</code> de esta manera: <code>x y</code>. ¿Qué pasa si intentas eso en Julia? ¿Y qué sucede con 5x?</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="ex02-2">Ejercicio 2-3</h4>
<div class="paragraph">
<p>Practique usando Julia REPL como una calculadora:
</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El volumen de una esfera con radio \(r\) es \(\frac{4}{3} \pi r^3\). ¿Cuál es el volumen de una esfera con radio 5?</p>
</li>
<li>
<p>Supongamos que el precio de venta de un libro es de $ 24.95, pero las librerías obtienen un descuento del 40%. El envío cuesta $3 por la primera copia y 75 centavos por cada copia adicional. ¿Cuál es el costo total al por mayor de 60 copias?</p>
</li>
<li>
<p>Si salgo de mi casa a las 6:52 a.m. y corro 1 milla a un ritmo relajado (8:15 min. por milla), luego 3 millas más rápido (7:12 min. por milla) y 1 milla a ritmo relajado nuevamente, ¿a qué hora llego a casa para desayunar?</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap03">3. Funciones</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En el contexto de la programación, una <em>función</em> es una secuencia de sentencias que ejecuta una operación deseada y tiene un nombre. Cuando se define una función, se especifica su nombre y secuencia de sentencias. Una vez hecho esto, se puede "llamar" a la función por su nombre.
</p>
</div>
<div class="sect2">
<h3 id="_llamada_a_función">Llamada a función</h3>
<div class="paragraph">
<p>Ya hemos visto un ejemplo de una llamada a función:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; println("¡Hola, Mundo!")
¡Hola, Mundo!</code></pre>
</div>
</div>
<div class="paragraph">
<p>El nombre de esta función es <code>println</code>. La expresión entre paréntesis se llama <em>argumento</em> de la función.
</p>
</div>
<div class="paragraph">
<p>Es común decir que una función "toma" un argumento y "devuelve" un resultado. El resultado también se llama <em>valor de retorno</em>.
</p>
</div>
<div class="paragraph">
<p>Julia tiene funciones integradas que convierten valores de un tipo a otro. La función <code>parse</code> toma una cadena y si es posible, la convierte en cualquier tipo de número, en caso contrario arroja error:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; parse(Int64, "32")
32
julia&gt; parse(Float64, "3.14159")
3.14159
julia&gt; parse(Int64, "Hola")
ERROR: ArgumentError: invalid base 10 digit 'H' in "Hola"</code></pre>
</div>
</div>
<div class="paragraph">
<p>(ERROR: ArgumentError: base inválida de 10 dígitos <em>H</em> en "Hola")</p>
</div>
<div class="paragraph">
<p><code>trunc</code> puede convertir valores de punto flotante a enteros, pero no redondea; sino que trunca:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; trunc(Int64, 3.99999)
3
julia&gt; trunc(Int64, -2.3)
-2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>float</code> convierte números enteros en números de punto flotante:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; float(32)
32.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente, <code>string</code> convierte el argumento en una cadena:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; string(32)
"32"
julia&gt; string(3.14159)
"3.14159"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_funciones_matemáticas">Funciones matemáticas</h3>
<div class="paragraph">
<p>En Julia, la mayoría de las funciones matemáticas conocidas están disponibles directamente:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">proporción = potencia_de_señal/potencia_de_ruido
decibelios = 10*log10(proporción)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este primer ejemplo utiliza la función <code>log10</code> para calcular la proporción entre señal y ruido en decibelios (suponiendo que <code>potencia_de_señal</code> y <code>potencia_de_ruido</code> están definidos). También existe la función <code>log</code>, que calcula logaritmo natural.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">radianes = 0.7
altura = sin(radianes)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este segundo ejemplo encuentra la razón seno (en inglés sine) de la variable <code>radianes</code>. El nombre de esta variable es una pista de que la función <code>sin</code> y las otras funciones trigonométricas (<code>cos</code>, <code>tan</code>, etc.) toman argumentos en radianes. Para convertir grados a radianes, se debe dividir por 180 y multiplicar por \(\pi\):
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; grados=45
45
julia&gt; radianes=grados/180*π
0.7853981633974483
julia&gt; sin(radianes)
0.7071067811865475</code></pre>
</div>
</div>
<div class="paragraph">
<p>El valor de la variable <code>π</code> es una aproximación de punto flotante de \(\pi \), con una precisión de aproximadamente 16 dígitos.
</p>
</div>
<div class="paragraph">
<p>Si sabe de trigonometría, puede verificar el resultado anterior comparándolo con la raíz cuadrada de dos dividido por dos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; sqrt(2)/ 2
0.7071067811865476</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_composición">Composición</h3>
<div class="paragraph">
<p>Hasta ahora, hemos analizado los elementos de un programa (variables, expresiones y sentencias) de forma aislada, sin mencionar cómo se combinan.
</p>
</div>
<div class="paragraph">
<p>Una de las características más útiles de los lenguajes de programación es su capacidad para combinar pequeños bloques de código. Por ejemplo, el argumento de una función puede ser cualquier tipo de expresión, incluidos operadores aritméticos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">x = sin(grados/360*2*π)</code></pre>
</div>
</div>
<div class="paragraph">
<p>E incluso llamadas a función:
 </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">x = exp(log(x + 1))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Casi en cualquier lugar donde se pueda colocar un valor, se puede colocar una expresión arbitraria, con una excepción: el lado izquierdo de una sentencia de asignación debe ser un nombre de variable. Cualquier otra expresión en el lado izquierdo genera un error de sintaxis (veremos excepciones a esta regla más adelante).
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; minutos = horas * 60 # derecha
120
julia&gt; horas * 60 = minutos # malo!
ERROR: syntax: "60" is not a valid function argument name</code></pre>
</div>
</div>
<div class="paragraph">
<p>(ERROR: sintaxis: "60" no es un nombre de argumento de función válido)</p>
</div>
</div>
<div class="sect2">
<h3 id="_agregar_nuevas_funciones">Agregar nuevas funciones</h3>
<div class="paragraph">
<p>Hasta ahora, solo hemos usado las funciones integradas en Julia, pero también es posible agregar nuevas funciones. Una <em>definición de función</em> especifica el nombre de una nueva función y la secuencia de sentencias que se ejecutan cuando se llama a la función. A continuación se muestra un ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimirletras()
    println("Jueguemos en el bosque")
    println("mientras el lobo no está.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>function</code> es una palabra reservada que indica que esta es una definición de función. El nombre de la función es <code>imprimirletras</code>. Las reglas para los nombres de funciones son las mismas que para los nombres de variables: pueden contener casi todos los caracteres Unicode (consulte <a href="#caracteres">[caracteres]</a>), pero el primer carácter no puede ser un número. No puede usar una palabra reservada como nombre de una función, y debe evitar tener una variable y una función con el mismo nombre.
</p>
</div>
<div class="paragraph">
<p>Los paréntesis vacíos después del nombre indican que esta función no tiene argumentos.
</p>
</div>
<div class="paragraph">
<p>La primera línea de una definición de función se llama <em>encabezado</em>; el resto se llama <em>cuerpo</em>. El cuerpo termina con la palabra reservada <code>end</code> y puede contener todas las sentencias que desee. Para facilitar la lectura, el cuerpo de la función debería tener sangría.
</p>
</div>
<div class="paragraph">
<p>Las comillas deben ser "comillas rectas" (""), generalmente ubicadas junto a la tecla Enter en el teclado. Las "comillas inglesas" (“”)no son válidas en Julia.
</p>
</div>
<div class="paragraph">
<p>Si escribe una definición de función en modo interactivo, Julia REPL inserta una sangría para informarle que la definición no está completa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; function imprimirletras()
        println("Jueguemos en el bosque")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para finalizar la función, debe escribir <code>end</code>.</p>
</div>
<div class="paragraph">
<p>La sintaxis para llamar a la nueva función es la misma que para las funciones integradas en Julia:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; imprimirletras()
Jueguemos en el bosque
mientras el lobo no está.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una vez que haya definido una función, puede usarla dentro de otra función. Por ejemplo, para repetir el estribillo anterior, podríamos escribir una función llamada <code>repetirletras</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function repetirletras()
    imprimirletras()
    imprimirletras()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Y luego llamamos a <code>repetirletras</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@ julia-repl-test chap03" data-lang="@ julia-repl-test chap03">julia&gt; repetirletras()
Jueguemos en el bosque
mientras el lobo no está.
Jueguemos en el bosque
mientras el lobo no está.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_definiciones_y_usos">Definiciones y usos</h3>
<div class="paragraph">
<p>Al unir los fragmentos de código de la sección anterior, todo el programa se ve así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimirletras()
    println("Jueguemos en el bosque")
    println("mientras el lobo no está.")
end

función repetirletras()
    imprimirletras()
    imprimirletras()
end

repetirletras()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este programa contiene dos definiciones de función: <code>imprimirletras</code> y <code>repetirletras</code>. Las definiciones de función se ejecutan al igual que otras sentencias, pero su ejecución crea nuevas funciones. Las sentencias dentro de la función no se ejecutan hasta que se llama a la función, y la definición de la función no genera salida.</p>
</div>
<div class="paragraph">
<p>Como es de esperar, debe crear una función antes de poder ejecutarla. En otras palabras, la definición de la función tiene que ejecutarse antes de que se llame a la función.</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_3_1">Ejercicio 3-1</h4>
<div class="paragraph">
<p>Mueva la última línea de este programa a la parte superior, de modo que la llamada a función aparezca antes de las definiciones. Ejecute el programa y vea qué mensaje de error obtiene.</p>
</div>
<div class="paragraph">
<p>Ahora mueva la llamada a función hacia abajo y coloque la definición de <code>imprimirletras</code> después de la definición de <code>repetirletras</code>. ¿Qué sucede cuando ejecuta este programa?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_flujo_de_ejecución">Flujo de ejecución</h3>
<div class="paragraph">
<p>Para asegurar de que una función sea definida antes de su primer uso, debe conocer el orden en que se ejecutan las instrucciones, lo que se denomina <em>flujo de ejecución</em>.
</p>
</div>
<div class="paragraph">
<p>La ejecución siempre comienza con la primera sentencia del programa. Las sentencias se ejecutan una a la vez, en orden descendente.</p>
</div>
<div class="paragraph">
<p>Las definiciones de función no alteran el flujo de ejecución del programa, pero se debe recordar que las sentencias dentro de la función no se ejecutan hasta que se llama a la función.</p>
</div>
<div class="paragraph">
<p>Una llamada a función es como un desvío en el flujo de ejecución. En lugar de pasar a la siguiente sentencia, el flujo salta al cuerpo de la función, ejecuta las sentencias que están allí y luego regresa para continuar el código donde lo dejó.</p>
</div>
<div class="paragraph">
<p>Esto suena bastante simple, hasta que tenemos en cuenta que una función puede llamar a otra. Mientras se está ejecutando una función, el programa podría tener que ejecutar las sentencias de otra función. Luego, mientras ejecuta esa nueva función, ¡el programa podría tener que ejecutar otra función más!</p>
</div>
<div class="paragraph">
<p>Afortunadamente, Julia es capaz de hacer el seguimiento de sus movimientos, así que cada vez que una función termina, el programa retoma la función que la llamó justo donde la dejó. Cuando llega al final del programa, la ejecución termina.</p>
</div>
<div class="paragraph">
<p>En resumen, cuando lee un programa, no siempre debe leer de arriba hacia abajo. A veces tiene más sentido seguir el flujo de ejecución.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parámetros_y_argumentos">Parámetros y argumentos</h3>
<div class="paragraph">
<p>Algunas de las funciones que hemos visto requieren argumentos. Por ejemplo, la función <code>cos</code> necesita un número como argumento. Algunas funciones toman más de un argumento; por ejemplo <code>parse</code> toma dos: un número y una cadena.
   </p>
</div>
<div class="paragraph">
<p>Dentro de la función, los argumentos se asignan a variables llamadas <em>parámetros</em>. A continuación se muestra un ejemplo de definición de función que toma un argumento:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@julia-setup chap03" data-lang="@julia-setup chap03">function imprimirdosveces(juan)
    println(juan)
    println(juan)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta función asigna el argumento a un parámetro llamado <code>juan</code>. Cuando se llama a la función, esta imprime el valor del parámetro (cualquiera que sea) dos veces.</p>
</div>
<div class="paragraph">
<p>Esta función funciona con cualquier valor que se pueda imprimir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@julia-repl-test chap03" data-lang="@julia-repl-test chap03">julia&gt; imprimirdosveces("Correo no deseado")
Correo no deseado
Correo no deseado
julia&gt; imprimirdosveces(42)
42
42
julia&gt; imprimirdosveces(π)
π = 3.1415926535897 ...
π = 3.1415926535897 ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las mismas reglas de composición que se aplican a las funciones integradas también se aplican a las funciones definidas por el programador, por lo que podemos usar cualquier tipo de expresión como argumento para <code>imprimirdosveces</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@julia-repl-test chap03" data-lang="@julia-repl-test chap03">julia&gt; imprimirdosveces("Correo no deseado "^4)
Correo no deseado Correo no deseado Correo no deseado Correo no deseado
Correo no deseado Correo no deseado Correo no deseado Correo no deseado
julia&gt; imprimirdosveces(cos(π))
-1.0
-1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>El argumento se evalúa antes de llamar a la función, por lo que en los ejemplos las expresiones <code>"Correo no deseado "^4</code> y <code>cos(π)</code> solo se evalúan una vez.
</p>
</div>
<div class="paragraph">
<p>También puede usar una variable como argumento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@julia-repl-test chap03" data-lang="@julia-repl-test chap03">julia&gt; michael = "La vida es bella."
"La vida es bella."
julia&gt; imprimirdosveces(michael)
La vida es bella.
La vida es bella.</code></pre>
</div>
</div>
<div class="paragraph">
<p>El nombre de la variable que pasamos como argumento (<code>michael</code>) no tiene nada que ver con el nombre del parámetro (<code>juan</code>). Para la función <code>imprimirdosveces</code> todos los parámetros se llaman <code>juan</code>, sin importar el nombre de la variable que pasemos como argumento (en este caso <code>michael</code>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_las_variables_y_los_parámetros_son_locales">Las variables y los parámetros son locales</h3>
<div class="paragraph">
<p>Cuando se crea una variable dentro de una función, esta es <em>local</em>, es decir, solo existe dentro de la función. Por ejemplo:
   </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@julia-setup chap03" data-lang="@julia-setup chap03">function concatenar_dos(parte1, parte2)
    concat = parte1 * parte2
    imprimirdosveces(concat)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta función toma dos argumentos, los concatena e imprime el resultado dos veces. Aquí hay un ejemplo:
 </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@ julia-repl-test chap03" data-lang="@ julia-repl-test chap03">julia&gt; linea1 = "Hola hola"
"Hola hola"
julia&gt; linea2 = "chao chao."
"chao chao".
julia&gt; concatenar_dos(línea1, línea2)
Hola hola chao chao.
Hola hola chao chao.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando <code>concatenar_dos</code> termina, la variable <code>concat</code> es destruida. Si intentamos imprimirla, obtendremos un error:
  </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@ julia-repl-test chap03" data-lang="@ julia-repl-test chap03">julia&gt; println(concat)
ERROR: UndefVarError: concat not defined</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los parámetros también son locales. Por ejemplo, afuera de la función <code>imprimirdosveces</code>, no existe <code>juan</code>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="stack_diagrams">Diagramas de pila</h3>
<div class="paragraph">
<p>Para seguir la pista de qué variables se usan en qué lugares es útil dibujar un <em>diagrama de pila</em>. Al igual que los diagramas de estado, los diagramas de pila muestran el valor de cada variable, pero también muestran la función a la que pertenece cada una.
 </p>
</div>
<div class="paragraph">
<p>Cada función se representa por un <em>marco</em>. Un marco es un recuadro con el nombre de una función a un costado, y los parámetros y variables de la función dentro. El diagrama de pila para el ejemplo anterior se muestra en <a href="#fig03-1">Stack diagram</a>.
</p>
</div>
<div id="fig03-1" class="imageblock">
<div class="content">
<img src="images/fig31.svg" alt="fig31">
</div>
<div class="title">Figura 2. Stack diagram</div>
</div>
<div class="paragraph">
<p>Los marcos se ordenan de tal manera que cada función llama a la función inmediatamente inferior. En este ejemplo, <code>imprimirdosveces</code> fue llamado por <code>concatenar_dos</code>, y <code>concatenar_dos</code> fue llamado por <code>Main</code>, que es un nombre especial para la función de más alto nivel. Cuando se crea una variable afuera de cualquier función, pertenece a <code>Main</code>.</p>
</div>
<div class="paragraph">
<p>Cada parámetro se refiere al mismo valor que su argumento correspondiente. Entonces, <code>parte1</code> tiene el mismo valor que <code>linea1</code>, <code>parte2</code> tiene el mismo valor que <code>linea2</code>, y <code>juan</code> tiene el mismo valor que <code>concat</code>.</p>
</div>
<div class="paragraph">
<p>Si se produce un error durante una llamada a función, Julia imprime el nombre de la función, el nombre de la función que la llamó, el nombre de la función que a su vez llamó a esta otra, y así sucesivamente hasta llegar a la función de más alto nivel <code>Main</code>.
</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si intenta acceder a <code>concat</code> desde <code>imprimirdosveces</code>, obtendrá un <code>UndefVarError</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR: UndefVarError: concat not defined
Stacktrace:
 [1] imprimirdosveces at ./REPL[1]&gt;:2 [inlined]
 [2] concatenar_dos(::String, ::String) at ./REPL[2]&gt;:3</pre>
</div>
</div>
<div class="paragraph">
<p>Esta lista de funciones se llama <em>trazado inverso</em>. Indica en qué archivo de programa se produjo el error, en qué línea y qué funciones se estaban ejecutando en ese momento. También muestra la línea de código que causó el error.
</p>
</div>
<div class="paragraph">
<p>El orden de las funciones en el trazado inverso es el opuesto del orden de los recuadros en el diagrama de pila. La función que se está ejecutando actualmente está en la parte superior.</p>
</div>
</div>
<div class="sect2">
<h3 id="_funciones_productivas_y_funciones_nulas">Funciones productivas y funciones nulas</h3>
<div class="paragraph">
<p>Algunas de las funciones que hemos utilizado, como las funciones matemáticas, devuelven resultados. A este tipo de funciones las llamaremos funciones productivas, a falta de un nombre mejor. Otras funciones como <code>imprimirdosveces</code>, realizan una acción pero no devuelven un valor. Estas se llaman <em>funciones nulas</em>.
 </p>
</div>
<div class="paragraph">
<p>Cuando llamamos a una función productiva, casi siempre queremos hacer algo con el resultado; por ejemplo, asignarlo a una variable o usarlo como parte de una expresión:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">x = cos(radianes)
aurea = (sqrt(5)+1)/2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando se llama a una función en modo interactivo, Julia muestra el resultado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@julia-repl-test" data-lang="@julia-repl-test">julia&gt; sqrt(5)
2.23606797749979</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pero en un script, si se llama a una función productiva, ¡el valor de retorno se pierde para siempre!
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>sqrt (5)</pre>
</div>
</div>
<div class="paragraph">
<p>Este script calcula la raíz cuadrada de 5, pero como no almacena ni muestra el resultado, no es muy útil.</p>
</div>
<div class="paragraph">
<p>Las funciones nulas pueden mostrar algo en la pantalla o tener algún otro efecto, pero no tienen un valor de retorno. Si asigna el resultado a una variable, obtendrá un valor especial llamado <code>nothing</code> (nada en inglés).
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@julia-repl-test chap03" data-lang="@julia-repl-test chap03">julia&gt; resultado = imprimirdosveces("Bing")
Bing
Bing
julia&gt; show(resultado)
nothing</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para imprimir el valor <code>nothing</code>, debe usar la función <code>show</code> que es como la función <code>print</code> pero permite el valor <code>nothing</code>.
 </p>
</div>
<div class="paragraph">
<p>El valor <code>nothing</code> no es lo mismo que la cadena <code>"nothing"</code>. Es un valor especial que tiene su propio tipo:
 </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@julia-repl-test" data-lang="@julia-repl-test">julia&gt; typeof (nothing)
Nothing</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las funciones que hemos escrito hasta ahora son nulas. Comenzaremos a escribir funciones productivas en unos pocos capítulos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_por_qué_se_necesitan_funciones">¿Por qué se necesitan funciones?</h3>
<div class="paragraph">
<p>Puede que no esté claro por qué vale la pena dividir un programa en funciones. Hay varias razones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Crear una nueva función le brinda la oportunidad de darle nombre a un grupo de sentencias, lo que hace que su programa sea más fácil de leer y depurar.</p>
</li>
<li>
<p>Las funciones pueden hacer que un programa sea más corto al eliminar código repetitivo. Además, si realiza un cambio, solo tiene que hacerlo en un solo lugar.</p>
</li>
<li>
<p>Dividir un programa largo en funciones le permite depurar las partes de a una en una, y luego unirlas.</p>
</li>
<li>
<p>Las funciones bien diseñadas pueden ser útiles para muchos programas. Una vez que escribe y depura uno, puede reutilizarla.</p>
</li>
<li>
<p>En Julia, las funciones pueden mejorar mucho el rendimiento.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_3">Depuración</h3>
<div class="paragraph">
<p>Una de las habilidades más importantes que adquirirás es la depuración. Aunque puede ser frustrante, la depuración es una de las partes más intelectualmente gratificantes, desafiantes e interesantes de la programación.
</p>
</div>
<div class="paragraph">
<p>La depuración puede ser vista como un trabajo de detective. Te enfrentas a pistas, y tienes que inferir los procesos y eventos que generaron los resultados que ves.</p>
</div>
<div class="paragraph">
<p>La depuración también es como una ciencia experimental. Una vez que se tiene una idea de lo que está mal, se modifica el programa y se intenta nuevamente. Si la hipótesis era correcta, se puede predecir el resultado de la modificación y así estar un paso más cerca de un programa totalmente funcional. Si la hipótesis era incorrecta, se tiene que encontrar una nueva. Como Sherlock Holmes señaló:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Cuando todo aquello que es imposible ha sido eliminado, lo que quede, por muy improbable que parezca, es la verdad.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; A. Conan Doyle<br>
<cite>El signo de los cuatro</cite>
</div>
</div>
<div class="paragraph">
<p>  </p>
</div>
<div class="paragraph">
<p>Para algunas personas, la programación y la depuración son lo mismo. Es decir, la programación es el proceso de depurar gradualmente un programa hasta que haga lo que desea. Lo ideal es comenzar con un programa que funcione y hacer pequeñas modificaciones, depurándolas a medida que avanza.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, Linux es un sistema operativo que contiene millones de líneas de código, pero comenzó como un programa simple que Linus Torvalds usó para explorar el chip Intel 80386. Según Larry Greenfield, "Uno de los proyectos anteriores de Linus fue un programa que cambiaría entre imprimir" AAAA "y" BBBB ". Esto luego evolucionó a Linux ". (<em>The Linux Users'’ Guide</em> Beta Version 1).
 </p>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_3">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">función</dt>
<dd>
<p>secuencia de sentencias que ejecuta una operación deseada y tiene un nombre. Las funciones pueden tomar o no argumentos, y pueden producir o no un resultado.
</p>
</dd>
<dt class="hdlist1">definición de función</dt>
<dd>
<p>Una sentencia que crea una nueva función, especificando su nombre, parámetros y las sentencias que contiene.
</p>
</dd>
<dt class="hdlist1">objeto de función</dt>
<dd>
<p>Un valor creado por una definición de función. El nombre de la función es una variable que se refiere a un objeto de función.
</p>
</dd>
<dt class="hdlist1">encabezado</dt>
<dd>
<p>La primera línea de una definición de función.
</p>
</dd>
<dt class="hdlist1">cuerpo</dt>
<dd>
<p>Secuencia de sentencias dentro de una definición de función.
</p>
</dd>
<dt class="hdlist1">parámetro</dt>
<dd>
<p>Un nombre usado dentro de una función para referirse al valor pasado como argumento.
</p>
</dd>
<dt class="hdlist1">Llamada a función</dt>
<dd>
<p>Una sentencia que ejecuta una función. Compuesta del nombre de la función seguido por la lista de argumentos que usa entre paréntesis.
</p>
</dd>
<dt class="hdlist1">argumento</dt>
<dd>
<p>Valor que se le pasa a una función cuando se la llama. Este valor se asigna al parámetro correspondiente en la función.
</p>
</dd>
<dt class="hdlist1">variable local</dt>
<dd>
<p>Una variable definida dentro de una función. Una variable local solo puede usarse dentro de su función.
</p>
</dd>
<dt class="hdlist1">valor de retorno</dt>
<dd>
<p>El resultado de una función. Si se utiliza una llamada a función como una expresión, el valor de retorno es el valor de la expresión.
</p>
</dd>
<dt class="hdlist1">función productiva</dt>
<dd>
<p>Una función que devuelve un valor.
</p>
</dd>
<dt class="hdlist1">función vacía</dt>
<dd>
<p>Una función que siempre devuelve <code>nothing</code>.
</p>
</dd>
<dt class="hdlist1"><code>nothing</code></dt>
<dd>
<p>Un valor especial devuelto por las funciones nulas.
</p>
</dd>
<dt class="hdlist1">composición</dt>
<dd>
<p>Usar una expresión como parte de una expresión más grande, o una sentencia como parte de una sentencia más grande.
</p>
</dd>
<dt class="hdlist1">flujo de ejecución</dt>
<dd>
<p>El orden en que las sentencias se ejecutan.
</p>
</dd>
<dt class="hdlist1">diagrama de pila </dt>
<dd>
<p>Una representación gráfica de una pila de funciones, sus variables y los valores a los que se refieren.
</p>
</dd>
<dt class="hdlist1">marco</dt>
<dd>
<p>Un recuadro que en un diagrama de pila representa una llamada de función. Contiene las variables locales y los parámetros de la función.
</p>
</dd>
<dt class="hdlist1">trazado inverso</dt>
<dd>
<p>Una lista de las funciones que se están ejecutando, las cuales son impresas cuando ocurre una excepción.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_3">Ejercicios</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Estos ejercicios deben realizarse utilizando sólo lo que hemos aprendido hasta ahora.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="ex03-1">Ejercicio 3-2</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>justificar_a_la_derecha</code> que tome una cadena <code>s</code> como parámetro y que imprima la cadena con suficientes espacios en blanco para que la última letra de la cadena se encuentre en la columna 70 de la pantalla.
 </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@julia-eval chap03-ex" data-lang="@julia-eval chap03-ex">using PiensaEnJulia</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@julia-repl chap03-ex" data-lang="@julia-repl chap03-ex">justificar_a_la_derecha("Celia")</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Use concatenación de cadenas y repetición. Además, Julia tiene integrada una función llamada <code>length</code> que devuelve la longitud de una cadena, por lo que el valor de <code>length("Celia")</code> es 5.
 </p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ex03-2">Ejercicio 3-3</h4>
<div class="paragraph">
<p>Un objeto de función es un valor que se puede asignar a una variable o ser pasado como argumento. Por ejemplo, <code>dosveces</code> es una función que toma un objeto de función como argumento y lo llama dos veces:
  </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function dosveces(f)
    f()
    f()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A continuación se muestra un ejemplo que usa <code>dosveces</code> para llamar a una función llamada <code>imprimirgato</code> dos veces.
 </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimirpalabra()
    println("palabra")
end

dosveces(imprimirpalabra)</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escriba este ejemplo en un script y pruébelo.</p>
</li>
<li>
<p>Modifique <code>dosveces</code> para que tome dos argumentos: un objeto de función y un valor, y que llame a la función dos veces, pasando el valor como argumento.</p>
</li>
<li>
<p>Copie la definición de <code>imprimirdosveces</code> mencionada antes en este capítulo a su secuencia de comandos.</p>
</li>
<li>
<p>Use la versión modificada de <code>dosveces</code> para llamar a <code>imprimirdosveces</code> dos veces, pasando <code>"palabra"</code> como argumento.</p>
</li>
<li>
<p>5.	Defina una nueva función llamada <code>cuatroveces</code> que tome un objeto de función y un valor, y que llame a la función cuatro veces, pasando el valor como parámetro. Debe haber solo dos sentencias en el cuerpo de esta función, no cuatro.
 </p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="ex03-3">Ejercicio 3-4</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escriba la función <code>imprimircuadricula</code> que dibuje una cuadrícula como la siguiente:
 </p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-@ julia-repl-test chap03-ex" data-lang="@ julia-repl-test chap03-ex">julia&gt; imprimircuadricula()
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +</code></pre>
</div>
</div>
</li>
<li>
<p>Escriba una función que dibuje una cuadrícula similar con cuatro filas y cuatro columnas.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Créditos: Este ejercicio se basa en un ejercicio en Oualline, <em>Practical C Programming</em>, Third Edition, O’Reilly Media, 1997.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Para imprimir más de un valor por línea, se puede imprimir una secuencia de valores separados por comas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">println ("+", "-")</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>print</code> no avanza a la siguiente línea:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">print("+")
println("-")</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado de estas sentencias es <code>"+ -"</code> en la misma línea. El resultado de una siguiente sentencia de impresión comenzaría en la siguiente línea.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>  </p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap04">4. Estudio de Caso: Diseño de Interfaz</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo presenta un segundo estudio de caso, que muestra el proceso de diseñar funciones que trabajen en conjunto.</p>
</div>
<div class="paragraph">
<p>Se presentan gráficos turtle, que es una forma de crear dibujos a través de la programación. Los gráficos turtle no están incluidos en la Biblioteca Estándar, por lo que se debe agregar el módulo PiensaEnJulia a su configuración de Julia.</p>
</div>
<div class="paragraph">
<p>Los ejemplos de este capítulo se pueden ejecutar en un notebook gráfico en JuliaBox, el cual combina código, texto formateado, matemáticas y multimedia en un solo documento (vea <a href="#juliabox">JuliaBox</a>).
</p>
</div>
<div class="sect2">
<h3 id="_turtles">Turtles</h3>
<div class="paragraph">
<p>Un <em>modulo</em> es un archivo que contiene una colección de funciones relacionadas. Julia proporciona algunos módulos en su Biblioteca Estándar. Además, es posible agregar más funciones a una gran cantidad de <em>paquetes</em> (<a href="https://juliaobserver.com" class="bare">https://juliaobserver.com</a>).
</p>
</div>
<div class="paragraph">
<p>Los paquetes se pueden instalar en REPL ingresando al modo Pkg REPL con la tecla <code>]</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">(v1.2) pkg&gt; add https://github.com/PiensaEnJulia/PiensaEnJulia.jl</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto puede demorar un poco.</p>
</div>
<div class="paragraph">
<p>Antes de que podamos usar las funciones de un módulo, tenemos que importarlo con una sentencia <code>using</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; using PiensaEnJulia

julia&gt; 🐢 = Turtle()
Luxor.Turtle(0.0, 0.0, true, 0.0, (0.0, 0.0, 0.0))</code></pre>
</div>
</div>
<div class="paragraph">
<p>El módulo <code>PiensaEnJulia</code> proporciona una función llamada <code>Turtle</code> (tortuga en español) que crea un objeto <code>Luxor.Turtle</code>, el cual asignamos a una variable llamada <code>🐢</code> (<strong><code>\:turtle: TAB</code></strong>).
</p>
</div>
<div class="paragraph">
<p>Una vez que crea una tortuga, puede llamar a una función para "moverla", y así hacer un dibujo con ella. Por ejemplo, para mover la tortuga hacia adelante (forward en inglés):
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">@svg begin
    forward(🐢, 100)
end</code></pre>
</div>
</div>
<div id="fig04-1" class="imageblock">
<div class="content">
<img src="images/fig41.svg" alt="fig41">
</div>
<div class="title">Figura 3. Moving the turtle forward</div>
</div>
<div class="paragraph">
<p>La palabra reservada <code>@svg</code> ejecuta una macro que dibuja una imagen SVG. Las macros son una característica importante pero avanzada de Julia.
</p>
</div>
<div class="paragraph">
<p>Los argumentos de <code>forward</code> son la tortuga y una distancia en píxeles, por lo que el tamaño real depende de su pantalla.</p>
</div>
<div class="paragraph">
<p>También es posible hacer girar a la tortuga con la función <code>turn</code>. Los argumentos de esta función son la tortuga y un ángulo en grados.
</p>
</div>
<div class="paragraph">
<p>Además, cada tortuga está sosteniendo un lápiz, que puede estar hacia arriba o hacia abajo; si el lápiz está hacia abajo, la tortuga deja un rastro cuando se mueve. <a href="#fig04-1">Moving the turtle forward</a> muestra el rastro dejado por la tortuga. Las funciones <code>penup</code> y <code>pendown</code> significan "lápiz hacia arriba" y "lápiz hacia abajo".
</p>
</div>
<div class="paragraph">
<p>Para dibujar un ángulo recto, modifique la llamada a la macro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicio_4_1">Ejercicio 4-1</h4>
<div class="paragraph">
<p>Ahora modifique la macro para que dibuje un cuadrado. ¡No sigas hasta haberlo terminado!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="simple_repetition">Repetición Simple</h3>
<div class="paragraph">
<p>Es probable que hayas escrito algo como esto:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Podemos hacer lo mismo de manera más concisa con una sentencia <code>for</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; for i in 1:4
          println("¡Hola!")
       end
¡Hola!
¡Hola!
¡Hola!
¡Hola!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este es el uso más simple de la sentencia <code>for</code>; veremos más usos después. Pero esto debería ser suficiente para reescribir su programa que dibuja un cuadrado. No continúes hasta que lo hagas.</p>
</div>
<div class="paragraph">
<p>Aquí hay una sentencia <code>for</code> que dibuja un cuadrado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">🐢 = Turtle()
@svg begin
    for i in 1:4
        forward(🐢, 100)
        turn(🐢, -90)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La sintaxis de una sentencia <code>for</code> es similar a la definición de una función. Tiene un encabezado y un cuerpo que termina con la palabra reservada <code>end</code>. El cuerpo puede contener el número de sentencias que desee.
</p>
</div>
<div class="paragraph">
<p>Una sentencia <code>for</code> también es llamada <em>bucle</em> porque el flujo de ejecución recorre el cuerpo y luego vuelve a la parte superior. En este caso, ejecuta el cuerpo cuatro veces.
</p>
</div>
<div class="paragraph">
<p>Esta versión es en realidad un poco diferente del código anterior que dibujaba un cuadrado porque hace otro giro después de dibujar el último lado del cuadrado. El giro adicional lleva más tiempo, pero simplifica el código si hacemos lo mismo en cada iteración del ciclo. Esta versión también tiene el efecto de dejar a la tortuga nuevamente en la posición inicial, mirando hacia la dirección inicial.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_4">Ejercicios</h3>
<div class="paragraph">
<p>Los siguientes ejercicios usan tortugas. Son divertidos, pero también tienen un trasfondo. Mientras trabaja en ellos, piense cuál es este trasfondo.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Las siguientes secciones muestran las soluciones para estos ejercicios, así que no mire hasta que haya terminado (o al menos lo haya intentado).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="ex04-1">Ejercicio 4-2</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>cuadrado</code> que tome como parámetro a un turtle <code>t</code>. Debería usar este turtle para dibujar un cuadrado.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex04-2">Ejercicio 4-3</h4>
<div class="paragraph">
<p>Escriba una llamada a función que pase <code>t</code> como argumento a <code>cuadrado</code>, y luego vuelva a ejecutar la macro.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex04-3">Ejercicio 4-4</h4>
<div class="paragraph">
<p>Agregue otro parámetro, llamado <code>lon</code>, a cuadrado. Modifique el cuerpo para que la longitud de los lados sea <code>lon</code>, y luego modifique la llamada a función agregando este segundo argumento. Ejecute la macro nuevamente. Prueba con un rango de valores para <code>lon</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex04-4">Ejercicio 4-5</h4>
<div class="paragraph">
<p>Haga una copia de <code>cuadrado</code> y cambie su nombre a <code>polígono</code>. Agregue otro parámetro llamado <code>n</code> y modifique el cuerpo para que dibuje un polígono regular de \(n\)-lados.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Los ángulos exteriores de un polígono regular de \(n\)-lados son \(\frac{360}{n}\) grados.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ex04-5">Ejercicio 4-6</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>círculo</code> que tome un turtle <code>t</code>, y un radio <code>r</code> como parámetros, y que dibuje un círculo aproximado llamando a <code>polígono</code> con una longitud y número de lados apropiados. Pruebe su función con un rango de valores de <code>r</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Calcule la circunferencia del círculo y asegúrese de que <code>len * n == circunferencia</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ex04-6">Ejercicio 4-7</h4>
<div class="paragraph">
<p>Haga una versión más general de <code>circulo</code> llamada <code>arco</code> que tome un parámetro adicional <code>angulo</code>, que determina qué fracción de un círculo dibujar. <code>angulo</code> está en grados, entonces cuando <code>angulo= 360</code>, <code>arco</code> debería dibujar un círculo completo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_encapsulación">Encapsulación</h3>
<div class="paragraph">
<p>El primer ejercicio le pide que coloque el código que permite dibujar un cuadrado en una definición de función, y que luego llame a la función, pasando a turtle como parámetro. Aquí hay una solución:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function cuadrado(t)
    for i in 1:4
        forward(t, 100)
        turn(t, -90)
    end
end
🐢 = Turtle()
@svg begin
    cuadrado(🐢)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las sentencias más internas, <code>forward</code> y <code>turn</code> tienen doble sangría para mostrar que están dentro del bucle <code>for</code>, que a su vez está dentro de la definición de función.
</p>
</div>
<div class="paragraph">
<p>Dentro de la función, <code>t</code> se refiere a la misma tortuga <code>🐢</code>, entonces <code>turn(t, -90)</code> tiene el mismo efecto que <code>turn(🐢, -90)</code>. En ese caso, ¿por qué no llamar al parámetro <code>🐢</code>? La razón es que <code>t</code> puede ser cualquier tortuga, no solo <code>🐢</code>, por lo que podríamos crear una segunda tortuga y pasarla como argumento a <code>cuadrado</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">🐫 = Turtle()
@svg begin
    cuadrado(🐫)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Colocar una porción de código en una función se denomina <em>encapsulación</em>. Uno de los beneficios de la encapsulación es que al ponerle un nombre al código, esto sirve como una especie de documentación. Otra ventaja es que si reutiliza el código, ¡es más conciso llamar a una función dos veces que copiar y pegar el cuerpo!
</p>
</div>
</div>
<div class="sect2">
<h3 id="_generalización">Generalización</h3>
<div class="paragraph">
<p>El siguiente paso es agregar un parámetro <code>lon</code> a <code>cuadrado</code>. Aquí hay una solución:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function cuadrado(t, lon)
    for i in 1:4
        forward(t, lon)
        turn(t, -90)
    end
end
🐢 = Turtle()
@svg begin
    cuadrado(🐢, 100)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agregar un parámetro a una función se llama <em>generalización</em> porque hace que la función sea más general: en la versión anterior, el cuadrado siempre tenía el mismo tamaño; en esta versión puede ser de cualquier tamaño.
</p>
</div>
<div class="paragraph">
<p>El siguiente paso también es una generalización. En vez de dibujar cuadrados, <code>poligono</code> dibuja polígonos regulares con cualquier número de lados. Aquí hay una solución:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function poligono(t, n, lon)
    angulo = 360 / n
    for i in 1:n
        forward(t, lon)
        turn(t, -angulo)
    end
end
🐢 = Turtle()
@svg begin
    poligono(🐢, 7, 70)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este ejemplo dibuja un polígono de 7 lados, con una longitud de 70 por lado.</p>
</div>
</div>
<div class="sect2">
<h3 id="_diseño_de_interfaz">Diseño de Interfaz</h3>
<div class="paragraph">
<p>El siguiente paso es escribir <code>circulo</code>, que toma un radio <code>r</code> como parámetro. Aquí hay una solución simple que usa <code>poligono</code> para dibujar un polígono de 50 lados:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function circulo(t, r)
    circunferencia = 2 * π * r
    n = 50
    len = circunferencia / n
    poligono(t, n, lon)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La primera línea calcula la circunferencia de un círculo con radio \(r\) usando la fórmula \(2 \pi r\). <code>n</code> es el número de segmentos de línea de nuestra aproximación a un círculo, y <code>len</code> es la longitud de cada segmento. Por lo tanto, <code>polígono</code> dibuja un polígono de 50 lados que se aproxima a un círculo de radio <code>r</code>.</p>
</div>
<div class="paragraph">
<p>Una limitante de esta solución es que <code>n</code> es constante, lo que significa que para círculos muy grandes, los segmentos de línea son demasiado largos, y para círculos pequeños, perdemos tiempo dibujando segmentos muy pequeños. Una solución sería generalizar la función tomando <code>n</code> como parámetro. Esto le daría al usuario (quien llama a círculo) más control, pero la interfaz sería menos pulcra.</p>
</div>
<div class="paragraph">
<p>La <em>interfaz</em> de una función es un resumen de cómo se usa: ¿cuáles son los parámetros? ¿Qué hace la función? ¿Y cuál es el valor de retorno? Una interfaz es "pulcra" si le permite al usuario que la llama hacer lo que quiera sin tener que lidiar con detalles innecesarios.
</p>
</div>
<div class="paragraph">
<p>En este ejemplo, <code>r</code> pertenece a la interfaz porque especifica el círculo a dibujar. <code>n</code> es menos apropiado porque se refiere a los detalles de cómo se debe representar el círculo.</p>
</div>
<div class="paragraph">
<p>En lugar de saturar la interfaz, es mejor elegir un valor apropiado de <code>n</code> dependiendo de la <code>circunferencia</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function circulo(t, r)
    circunferencia = 2 * π * r
    n = trunc(circunferencia / 3) + 3
    len = circunferencia / n
    poligono(t, n, len)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora, el número de segmentos es un número entero cercano a <code>circunferencia/3</code>, por lo que la longitud de cada segmento es aproximadamente 3, que es lo suficientemente pequeño como para que los círculos se vean bien, pero lo suficientemente grandes como para ser eficientes y aceptables para cualquier círculo.</p>
</div>
<div class="paragraph">
<p>Agregar 3 a <code>n</code> garantiza que el polígono tenga al menos 3 lados.</p>
</div>
</div>
<div class="sect2">
<h3 id="refactoring">Refactorización</h3>
<div class="paragraph">
<p>Cuando escribimos <code>circulo</code>, pudimos reutilizar <code>poligono</code> ya que un polígono de muchos lados es una buena aproximación de un círculo. Pero <code>arco</code> no es tan versatil; no podemos usar <code>poligono</code> o <code>circulo</code> para dibujar un arco.</p>
</div>
<div class="paragraph">
<p>Una alternativa es comenzar con una copia de <code>poligono</code> y transformarla en <code>arco</code>. El resultado podría verse así:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function arco(t, r, angulo)
    arco_lon = 2 * π * r * angulo / 360
    n = trunc(arco_lon / 3) + 1
    paso_lon = arco_lon / n
    paso_angulo = angulo / n
    for i in 1:n
        forward(t, paso_lon)
        turn(t, -paso_angulo)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La segunda mitad de esta función se parece a <code>poligono</code>, pero no podemos reutilizar <code>poligono</code> sin cambiar la interfaz. Podríamos generalizar <code>poligono</code> para tomar un <code>angulo</code> como tercer argumento, ¡pero entonces <code>poligono</code> ya no sería un nombre apropiado! En su lugar, llamemos a esta función más general <code>polilinea</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function polilinea(t, n, lon, angulo)
    for i in 1:n
        forward(t, lon)
        turn(t, -angulo)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora podemos reescribir <code>poligono</code> y <code>arco</code> usando <code>polilinea</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function poligono(t, n, lon)
    angulo = 360 / n
    polilinea(t, n, lon, angulo)
end

function arco(t, r, angulo)
    arco_lon = 2 * π * r * angulo / 360
    n = trunc(arco_lon / 3) + 1
    paso_lon = arco_lon / n
    paso_angulo = angulo / n
    polilinea(t, n, paso_lon, paso_angulo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente, podemos reescribir <code>circulo</code> usando <code>arco</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function circle(t, r)
    arc(t, r, 360)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este proceso, que reorganiza un programa para mejorar las interfaces y facilitar la reutilización del código, se denomina <em>refactorización</em>. En este caso, notamos que había un código similar en <code>arco</code> y <code>poligono</code>, por lo que lo "factorizamos" en <code>polilinea</code>.
(refactorización</p>
</div>
<div class="paragraph">
<p>Si hubiéramos planeado con anticipación, podríamos haber escrito <code>polilinea</code> primero y haber evitado la refactorización, pero a menudo no se sabe lo suficiente al comienzo de un proyecto para diseñar todas las interfaces. Una vez que se comienza a programar, se comprende mejor el problema. A veces, refactorizar es una señal de que has aprendido algo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_un_plan_de_desarrollo">Un Plan de Desarrollo</h3>
<div class="paragraph">
<p>Un <em>plan de desarrollo de programa</em> es un proceso para escribir programas. El proceso que utilizamos en este estudio de caso es "encapsulado y generalización". Los pasos de este proceso son:
</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Comience escribiendo un pequeño programa sin definiciones de funciones.</p>
</li>
<li>
<p>Una vez que el programa funcione, identifique una porción de código que tenga un objetivo específico, encapsule esta porción en una función y asígnele un nombre.</p>
</li>
<li>
<p>Generalice la función agregando los parámetros apropiados.</p>
</li>
<li>
<p>Repita los pasos 1–3 hasta que tenga un conjunto de funciones. De ser posible, copie y pegue código para evitar volver a escribir (y volver a depurar).</p>
</li>
<li>
<p>Busque oportunidades para mejorar el programa refactorizando. Por ejemplo, si tiene un código similar en varios lugares, considere factorizarlo en una función general apropiada.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Este proceso tiene algunos inconvenientes, veremos alternativas más adelante, pero puede ser útil si no sabe de antemano cómo dividir el programa en funciones. Este enfoque permite diseñar conforme avancemos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_docstring">Docstring</h3>
<div class="paragraph">
<p>Un <em>docstring</em> es una cadena que va antes de una función, y que explica la interfaz ("doc" es la abreviatura de "documentación"). Aquí hay un ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">"""
polilinea(t, n, lon, angulo)

Dibuja n segmentos de línea de la longitud dada y con
ángulo entre ellos (en grados) dado. t es una tortuga.
"""
function polilinea(t, n, lon, angulo)
    for i in 1:n
        forward(t, lon)
        turn(t, -angulo)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se puede acceder a la documentación en REPL o en un notebook escribiendo ? seguido del nombre de una función o macro, y presionando <code>ENTER</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>help?&gt; polilinea
search:

  polilinea(t, n, lon, angulo)

  Dibuja n segmentos de línea de la longitud dada y con ángulo entre ellos (en grados) dado. t es una tortuga.</pre>
</div>
</div>
<div class="paragraph">
<p>Los docstring generalmente son cadenas de comillas triples, también conocidas como cadenas de líneas múltiples ya que las comillas triples permiten que la cadena abarque más de una línea.</p>
</div>
<div class="paragraph">
<p>Un docstring contiene la información esencial que alguien necesitaría para usar esta función. Explica de manera concisa lo que hace la función (sin entrar en detalles sobre cómo lo hace). Explica qué efecto tiene cada parámetro en el comportamiento de la función y de qué tipo debe ser cada parámetro (si no es obvio).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Escribir este tipo de documentación es una parte importante del diseño de la interfaz. Una interfaz bien diseñada debe ser simple de explicar; si tiene dificultades para explicar una de sus funciones, tal vez la interfaz podría mejorarse.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_4">Depuración</h3>
<div class="paragraph">
<p>Una interfaz es como un contrato entre una función y el usuario. El usuario acepta proporcionar ciertos parámetros y la función acepta hacer cierto trabajo.
</p>
</div>
<div class="paragraph">
<p>Por ejemplo, <code>polilinea</code> requiere cuatro argumentos: <code>t</code> tiene que ser una tortuga; <code>n</code> tiene que ser un número entero; <code>lon</code> debería ser un número positivo; y <code>angulo</code> tiene que ser un número, en grados.</p>
</div>
<div class="paragraph">
<p>Estos requisitos se llaman <em>precondiciones</em> porque se supone que son verdaderos antes de que la función comience a ejecutarse. Por el contrario, las condiciones al final de la función son <em>postcondiciones</em>. Las <em>postcondiciones</em> incluyen el efecto deseado de la función (como dibujar segmentos de línea) y cualquier efecto secundario (como mover la tortuga o hacer otros cambios).
</p>
</div>
<div class="paragraph">
<p>Las condiciones previas son responsabilidad del usuario. Si el usuario viola una precondición (¡debidamente documentada!) y la función no funciona correctamente, el error está en el usuario, no en la función.</p>
</div>
<div class="paragraph">
<p>Si se cumplen las precondiciones pero no las postcondiciones, el error está en la función. Si sus pre y postcondiciones son claras, pueden ayudar con la depuración.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_4">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">modulo</dt>
<dd>
<p>Un archivo que contiene una colección de funciones relacionadas y otras definiciones.
</p>
</dd>
<dt class="hdlist1">paquete</dt>
<dd>
<p>Una biblioteca externa con más funcionalidades.
</p>
</dd>
<dt class="hdlist1">sentencia using</dt>
<dd>
<p>Una sentencia que lee un archivo de módulo y crea un objeto de módulo.
</p>
</dd>
<dt class="hdlist1">bucle</dt>
<dd>
<p>Una parte de un programa que puede ejecutarse repetidamente.
</p>
</dd>
<dt class="hdlist1">encapsulado</dt>
<dd>
<p>El proceso de transformar una secuencia de sentencias en una definición de función.
</p>
</dd>
<dt class="hdlist1">generalización</dt>
<dd>
<p>El proceso de reemplazar algo innecesariamente específico (como un número) con algo más general (como una variable o parámetro).
</p>
</dd>
<dt class="hdlist1">interfaz</dt>
<dd>
<p>Una descripción de cómo usar una función, incluido el nombre y las descripciones de los argumentos y el valor de retorno.
</p>
</dd>
<dt class="hdlist1">refactorización</dt>
<dd>
<p>El proceso de modificar un programa para mejorar las interfaces de las funciones y otras cualidades del código.
</p>
</dd>
<dt class="hdlist1">plan de desarrollo de programa</dt>
<dd>
<p>Un proceso para escribir programas.
</p>
</dd>
<dt class="hdlist1">docstring</dt>
<dd>
<p>Una cadena que aparece en la parte superior de una definición de función para documentar la interfaz de la función.
</p>
</dd>
<dt class="hdlist1">precondición</dt>
<dd>
<p>Un requisito que debe cumplir el usuario antes de que comience una función.
</p>
</dd>
<dt class="hdlist1">postcondición</dt>
<dd>
<p>Un requisito que debe cumplir la función antes de que finalice.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_5">Ejercicios</h3>
<div class="sect3">
<h4 id="ex04-7">Ejercicio 4-8</h4>
<div class="paragraph">
<p>Copie y pegue el código de este capítulo en un notebook.
Enter the code in this chapter in a notebook.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Dibuje un diagrama de pila que muestre el estado del programa mientras ejecuta <code>circulo(🐢,radio)</code>. Puede hacer la aritmética a mano o agregar sentencias de impresión al código.</p>
</li>
<li>
<p>La versión de <code>arco</code> en <a href="#refactoring">Refactorización</a> no es muy precisa ya que la aproximación lineal del círculo siempre queda por afuera del círculo verdadero. Como resultado, la tortuga termina a unos pocos píxeles del destino correcto. La siguiente solución muestra una forma de reducir el efecto de este error. Lea el código y vea si tiene sentido. Si dibuja un diagrama, es posible que entienda mejor cómo funciona.
</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">"""
arco(t, r, angulo)

Dibuja un arco con el radio y el ángulo dados:

    t: tuortuga
    r: radio
    angulo: ángulo subtendido por el arco, en grados
"""
function arco(t, r, angulo)
    arco_lon = 2 * π * r * abs(angulo) / 360
    n = trunc(arco_lon / 4) + 3
    paso_lon = arco_lon / n
    paso_angulo = angulo / n

    # haciendo un ligero giro a la izquierda antes de comenzar se reduce
    # el error causado por la aproximación lineal del arco
    turn(t, -paso_angulo/2)
    polilinea(t, n, paso_lon, paso_angulo)
    turn(t, paso_angulo/2)
end</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ex04-8">Ejercicio 4-9</h4>
<div class="paragraph">
<p>Escriba un conjunto de funciones generales que permitan dibujar flores como en <a href="#fig04-2">Turtle flowers</a>.</p>
</div>
<div id="fig04-2" class="imageblock">
<div class="content">
<img src="images/fig42.svg" alt="fig42">
</div>
<div class="title">Figura 4. Turtle flowers</div>
</div>
</div>
<div class="sect3">
<h4 id="ex04-9">Ejercicio 4-10</h4>
<div class="paragraph">
<p>Escriba un conjunto de funciones generales que puedan dibujar formas como en <a href="#fig04-3">Turtle pies</a>.</p>
</div>
<div id="fig04-3" class="imageblock">
<div class="content">
<img src="images/fig43.svg" alt="fig43">
</div>
<div class="title">Figura 5. Turtle pies</div>
</div>
</div>
<div class="sect3">
<h4 id="ex04-10">Ejercicio 4-11</h4>
<div class="paragraph">
<p>Las letras del alfabeto se pueden construir a partir de un número pequeño de elementos básicos, como líneas verticales y horizontales, y algunas curvas. Diseñe un alfabeto que se pueda dibujar con un número mínimo de elementos básicos y luego escriba funciones que dibujen las letras.</p>
</div>
<div class="paragraph">
<p>Debería escribir una función para cada letra, con nombres <code>dibujar_a</code>, <code>dibujar_b</code>, etc., y colocar sus funciones en un archivo llamado <em>letras.jl</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex04-11">Ejercicio 4-12</h4>
<div class="paragraph">
<p>Lea sobre espirales en <a href="https://es.wikipedia.org/wiki/Espiral" class="bare">https://es.wikipedia.org/wiki/Espiral</a>; luego escriba un programa que dibuje una espiral de Arquímedes como en <a href="#fig04-4">Archimedan spiral</a>.</p>
</div>
<div id="fig04-4" class="imageblock">
<div class="content">
<img src="images/fig44.svg" alt="fig44">
</div>
<div class="title">Figura 6. Archimedan spiral</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap05">5. Condicionales y recursividad</h2>
<div class="sectionbody">
<div class="paragraph">
<p>El tema principal de este capítulo es la sentencia <code>if</code>, la cual permite ejecutar diferentes acciones dependiendo del estado del programa. Inicialmente se presentan dos nuevos operadores: división entera de tipo piso y módulo.</p>
</div>
<div class="sect2">
<h3 id="_división_entera_de_tipo_piso_y_módulo">División entera de tipo piso y Módulo</h3>
<div class="paragraph">
<p>El operador <em>división entera de tipo piso</em>, <code>÷</code> (<strong><code>\div TAB</code></strong>), divide dos números y redondea hacia abajo el resultado. Por ejemplo, suponga que la duración de una película es de 105 minutos. Es posible que desee saber la duración en horas. La división convencional devuelve un número de punto flotante:
  </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; minutos = 105
105
julia&gt; minutos / 60
1.75</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pero normalmente las horas no se escriben con decimales. La división entera de tipo piso devuelve el número entero de horas, redondeado hacia abajo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; horas = minutos ÷ 60
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para obtener el resto de la división, se puede restar una hora (en minutos) a la duración total de la película:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; resto = minutos - horas * 60
45</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otra alternativa es usar el <em>operador módulo</em>, <code>%</code>, que divide dos números y devuelve el resto.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; resto = minutos % 60
45</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>El operador módulo es más útil de lo que parece. Por ejemplo, permite verificar si un número es divisible por otro: si <code>x%y</code> es cero, entonces <code>x</code> es divisible por <code>y</code>.</p>
</div>
<div class="paragraph">
<p>Además, puede extraer el (o los) dígito(s) más a la derecha de un número. Por ejemplo, <code>x%10</code> devuelve el dígito más a la derecha de un entero <code>x</code> (en base 10). Del mismo modo, <code>x%100</code> devuelve los dos últimos dígitos.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_expresiones_booleanas">Expresiones booleanas</h3>
<div class="paragraph">
<p>Una <em>expresión booleana</em> es una expresión que es verdadera o falsa. Los siguientes ejemplos usan el operador <code>==</code>, que compara dos operandos, y devuelve el valor <code>true</code> (verdadero en español) si son iguales, y el valor <code>false</code> (falso) de lo contrario.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 5 == 5
true
julia&gt; 5 == 6
false</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>true</code> y <code>false</code> son valores especiales que pertenecen al tipo <code>Bool</code>; no son cadenas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; typeof(true)
Bool
julia&gt; typeof(false)
Bool</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador <code>==</code> es un operador relacional. El resto de operadores relacionales son:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">      x != y               # x no es igual a y
      x ≠ y                # (\ne TAB)
      x &gt; y                # x es mayor que y
      x &lt; y                # x es menor que y
      x &gt;= y               # x es mayor o igual que y
      x ≥ y                # (\ge TAB)
      x &lt;= y               # x es menor o igual que y
      x ≤ y                # (\le TAB)</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>Aunque estas operaciones probablemente le sean familiares, los símbolos de Julia son diferentes de los símbolos matemáticos. Un error común es usar un solo signo igual (<code>=</code>) en vez de un doble signo igual (<code>==</code>). Recuerde que <code>=</code> es un operador de asignación y <code>==</code> es un operador relacional. No existe <code>=&lt;</code> o <code>=></code>.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_operadores_lógicos">Operadores Lógicos</h3>
<div class="paragraph">
<p>Hay tres operadores lógicos: <code>&amp;&amp;</code> (y), <code>||</code> (o) y <code>!</code> (no). La semántica (significado) de estos operadores es similar a su significado en español. Por ejemplo, <code>x&gt;0 &amp;&amp; x&lt;10</code> es verdadero solo si <code>x</code> es mayor que <code>0</code> <em>y</em> menor que <code>10</code>.
</p>
</div>
<div class="paragraph">
<p><code>n%2==0 || n%3 == 0</code> es verdadero si <em>una o ambas</em> condiciones son verdaderas, es decir, si el número es divisible por 2 <em>o</em> por 3.</p>
</div>
<div class="paragraph">
<p>Tanto <code>&amp;&amp;</code> como <code>||</code> se asocian en primer lugar con el objeto a su derecha, pero <code>&amp;&amp;</code> tiene preferencia por sobre <code>||</code>.</p>
</div>
<div class="paragraph">
<p>Finalmente, el operador <code>!</code> niega una expresión booleana, entonces <code>!(x&gt;y)</code> es verdadero si <code>x&gt;y</code> es falso, es decir, si <code>x</code> es menor o igual que <code>y</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ejecución_condicional">Ejecución Condicional</h3>
<div class="paragraph">
<p>Para escribir programas útiles, generalmente necesitamos poder verificar condiciones y cambiar el comportamiento del programa acorde a ellas. Las sentencias condicionales nos permiten hacer esto. La forma más simple es la sentencia <code>if</code> ("si" en inglés):
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if x &gt; 0
    println("x es positivo")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La expresión booleana después de <code>if</code> se llama <em>condición</em>. Si es verdadera, se ejecuta la instrucción con sangría. Si no, nada ocurre.
</p>
</div>
<div class="paragraph">
<p>Las sentencias <code>if</code> tienen la misma estructura que las definiciones de función: un encabezado seguido del cuerpo, terminado con la palabra reservada <code>end</code> (en español "fin"). Las sentencias como este se denominan <em>sentencias compuestas</em>.
</p>
</div>
<div class="paragraph">
<p>No hay límite en el número de sentencias que pueden aparecer en el cuerpo. A veces es útil tener un cuerpo sin sentencias (por lo general, como un marcador de posición para el código que aún no se ha escrito).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if x &lt; 0
    # TODO: se necesita realizar alguna acción con los valores negativos!
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejecución_alternativa">Ejecución alternativa</h3>
<div class="paragraph">
<p>Una segunda forma de la sentencia <code>if</code> es la "ejecución alternativa", en la que hay dos posibilidades y la condición determina cuál se ejecuta. La sintaxis se ve así:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if x % 2 == 0
    println("x es par")
else
    println("x es impar")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si el resto de <code>x</code> dividido por 2 es 0, entonces <code>x</code> es par, y el programa muestra un mensaje acorde. Si la condición es falsa, se ejecuta el segundo conjunto de sentencias. Como la condición debe ser verdadera o falsa, se ejecutará exactamente una de las alternativas. Las alternativas se llaman <em>ramas</em>, porque son ramas en el flujo de ejecución.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_condicionales_encadenadas">Condicionales encadenadas</h3>
<div class="paragraph">
<p>A veces hay más de dos posibilidades y necesitamos más de dos ramas. Una manera de expresar este cómputo es a través de una <em>condicional encadenada</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if x &lt; y
    println("x es menor que y")
elseif x &gt; y
    println("x es mayor que y")
else
    println("x e y son iguales")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>De nuevo, sólo se ejecutará una rama. No hay límite al número de sentencias <code>elseif</code>. Si hay una sentencia <code>else</code>, debe estar al final (aunque no es necesario que esté).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if alternativa == "a"
    dibujar_a()
elseif alternativa == "b"
    dibujar_b()
elseif alternativa == "c"
    dibujar_c()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cada condición se comprueba en orden. Si la primera es falsa, se comprueba la siguiente, y así se sigue con las demás. Si una de ellas es verdadera, se ejecuta la rama correspondiente y la sentencia se termina. Si es verdadera más de una condición, sólo se ejecuta la primera rama verdadera.</p>
</div>
</div>
<div class="sect2">
<h3 id="_condicionales_anidadas">Condicionales anidadas</h3>
<div class="paragraph">
<p>Una condicional puede estar anidada dentro de otra. Podríamos haber escrito el ejemplo de la sección anterior de la siguiente manera:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if x == y
    println("x e y son iguales")
else
    if x &lt; y
        println("x es menor a y")
    else
        println("x es mayor a y")
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La condicional externa contiene dos ramas. La primera rama contiene una sentencia simple. La segunda rama contiene otra sentencia if, que tiene dos ramas propias. Estas dos ramas son ambas sentencias simples, aunque podrían ser sentencias condicionales.</p>
</div>
<div class="paragraph">
<p>Aunque la sangría no obligatoria de las sentencias hace evidente su estructura, las condicionales anidadas muy pronto se vuelven difíciles de leer. Se recomienda evitarlas cuando pueda.
</p>
</div>
<div class="paragraph">
<p>Los operadores lógicos a menudo proporcionan una forma de simplificar las sentencias condicionales anidadas. Por ejemplo, podemos reescribir el siguiente código usando un solo condicional:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if 0 &lt; x
    if x &lt; 10
        println("x es un número positivo de un solo dígito.")
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La sentencia <code>print</code> sólo se ejecuta si conseguimos superar ambas condicionales, de modo que podemos obtener el mismo efecto con el operador <code>&amp;&amp;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if 0 &lt; x &amp;&amp; x &lt; 10
    println("x es un número positivo de un solo dígito.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para este tipo de condición, Julia proporciona una sintaxis más concisa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if 0 &lt; x &lt; 10
    println("x es un número positivo de un solo dígito.")
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="recursividad">Recursividad</h3>
<div class="paragraph">
<p>Está permitido que una función llame a otra; también está permitido que una función se llame a si misma. Puede no parecer útil, pero resulta que sí lo es. Por ejemplo, mira la siguiente función:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function cuentaregresiva(n)
    if n ≤ 0
        println("Despegue!")
    else
        print(n, " ")
        cuentaregresiva(n-1)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si <code>n</code> es 0 o negativo, muestra la palabra <code>"Despegue!"</code>. En otro caso, muestra el valor <code>n</code> y luego llama a la función <code>cuentaregresiva</code>, pasándole <code>n-1</code> como argumento.</p>
</div>
<div class="paragraph">
<p>Qué sucede si llamamos a una función como esta?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; cuentaregresiva(3)
3 2 1 Despegue!</code></pre>
</div>
</div>
<div class="paragraph">
<p>La ejecución de <code>cuentaregresiva</code> empieza con <code>n = 3</code>, y como <code>n</code> es mayor que 0, muestra el valor 3, y luego se llama a si misma&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;La ejecución de <code>cuentaregresiva</code> empieza con <code>n = 2</code>, y como <code>n</code> es mayor que 0, <br/>&#8193;&#8193;muestra el valor 2, y luego se llama a si misma&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;La ejecución de <code>cuentaregresiva</code> empieza con <code>n = 1</code>, y como <code>n</code> es mayor que 0, <br/>&#8193;&#8193;&#8193;muestra el valor 1, y luego se llama a si misma&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;&#8193;La ejecución de <code>cuentaregresiva</code> empieza con <code>n = 0</code>, y como <code>n</code> no es mayor que 0, <br/>&#8193;&#8193;&#8193;&#8193;muestra la palabra <code>"Despegue!"</code>, y luego termina.</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;La <code>cuentaregresiva</code> cuyo argumento es <code>n = 1</code> termina.</p>
</div>
<div class="paragraph">
<p>&#8193;La <code>cuentaregresiva</code> cuyo argumento es <code>n = 2</code> termina.</p>
</div>
<div class="paragraph">
<p>La <code>cuentaregresiva</code> cuyo argumento es <code>n = 3</code> termina.</p>
</div>
<div class="paragraph">
<p>Y volvemos a <code>Main</code>.</p>
</div>
<div class="paragraph">
<p>Una función que se llama a si misma es <em>recursiva</em>; el proceso de ejecución se llama <em>recursividad</em>.
</p>
</div>
<div class="paragraph">
<p>Como otro ejemplo, podemos escribir una función que imprima una cadena \(n\) veces.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function printn(s, n)
    if n ≤ 0
        return
    end
    println(s)
    printn(s, n-1)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si <code>n &lt;= 0</code>, se usa la sentencia <code>return</code> para salir de la función. El flujo de la ejecución vuelve inmediatamente a la sentencia de llamada a función y no se ejecutan las líneas restantes de la función.
</p>
</div>
<div class="paragraph">
<p>El resto de la función es similar a <code>cuenta regresiva</code>: muestra <code>s</code> y luego se llama a si mismo para mostrar <code>s</code> \(n-1\) veces más. Así que el número de lineas mostradas es \(1 + (n - 1)\), es decir \(n\).</p>
</div>
<div class="paragraph">
<p>Para ejemplos simples como este, es más fácil usar un ciclo <code>for</code>. Veremos ejemplos que son difíciles de escribir con un ciclo <code>for</code>, y fáciles de escribir con recursividad.</p>
</div>
</div>
<div class="sect2">
<h3 id="_diagramas_de_pila_para_funciones_recursivas">Diagramas de pila para funciones recursivas</h3>
<div class="paragraph">
<p>En <a href="#stack_diagrams">Diagramas de pila</a>, se usó un diagrama de pila para representar el estado de un programa durante una llamada de función. El mismo tipo de diagrama puede ser de utilidad para interpretar una función recursiva.
</p>
</div>
<div class="paragraph">
<p>Cada vez que se llama a una función, Julia crea un marco que contiene las variables locales de la función y los parámetros. En una función recursiva, puede haber más de un marco en el diagrama de pila al mismo tiempo.
</p>
</div>
<div id="fig05-1" class="imageblock">
<div class="content">
<img src="images/fig51.svg" alt="fig51">
</div>
<div class="title">Figura 7. Stack diagram</div>
</div>
<div class="paragraph">
<p><a href="#fig05-1">Stack diagram</a> muestra un diagrama de pila para <code>cuentaregresiva</code> utilizando <code>n=3</code>.</p>
</div>
<div class="paragraph">
<p>Como siempre, la parte superior de la pila es el marco para <code>Main</code>. Está vacío pues no se crearon variables en <code>Main</code>, ni tampoco se pasaron argumentos.</p>
</div>
<div class="paragraph">
<p>Los cuatro marcos de <code>cuentaregresiva</code> tienen diferentes valores del parámetro <code>n</code>. La parte inferior del diagrama de pila, donde <code>n = 0</code>, es llamado <em>caso base</em>. No hace una llamada recursiva, así que no hay más marcos.
</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_5_1">Ejercicio 5-1</h4>
<div class="paragraph">
<p>Como ejercicio, dibuje un diagrama de pila para <code>printn</code>, llamada con <code>s = "Hola"</code> y <code>n = 2</code>. Luego escriba una función llamada <code>hacer_n</code>, que tome como argumentos una función y un número <code>n</code>, y que luego llame a la función dada \(n\) veces.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_recursión_infinita">Recursión infinita</h3>
<div class="paragraph">
<p>Si una recursión nunca alcanza un caso base, continúa haciendo llamadas recursivas para siempre, y el programa nunca termina. Esto se conoce como <em>recursión infinita</em>, y generalmente no es una buena idea. Aquí hay un código con una recursión infinita:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function recursion()
    recursion()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>En la mayoría de los entornos de programación, un programa con recursión infinita realmente no se ejecuta para siempre. Julia entrega un mensaje de error cuando se alcanza la profundidad de recursión máxima:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; recursion()
ERROR: StackOverflowError:
Stacktrace:
 [1] recursion() at ./REPL[1]:2 (repeats 80000 times)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este stacktrace es un poco más grande que el que vimos en el capítulo anterior. Cuando se produce el error, ¡hay 80000 marcos de <code>recursion</code> en el diagrama de pila!
</p>
</div>
<div class="paragraph">
<p>Si por accidente encuentra una recursión infinita en su código, revise su función para confirmar que hay un caso base que no realiza una llamada recursiva. Si hay un caso base, verifique si realmente puede ocurrir.</p>
</div>
</div>
<div class="sect2">
<h3 id="_entrada_por_teclado">Entrada por teclado</h3>
<div class="paragraph">
<p>Los programas que hemos escrito hasta ahora no aceptan entradas del usuario. Simplemente hacen lo mismo cada vez.</p>
</div>
<div class="paragraph">
<p>Julia tiene una función incorporada llamada <code>readline</code> que detiene el programa y espera a que el usuario escriba algo. Cuando el usuario presiona <code>RETURN</code> o <code>ENTER</code>, el programa se reanuda y <code>readline</code> devuelve lo que el usuario escribió como una cadena.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; text = readline()
¿Qué estás esperando?
"¿Qué estás esperando?"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Antes de recibir una entrada por teclado del usuario, es una buena idea imprimir un mensaje que le diga al usuario qué escribir:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; print("¿Cuál... es tu nombre? "); readline()
¿Cuál... es tu nombre? ¡Arturo, Rey de los Bretones!
"¡Arturo, Rey de los Bretones!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un punto y coma <code>;</code> permite colocar varias sentencias en la misma línea. En el REPL solo la última sentencia devuelve su valor.
</p>
</div>
<div class="paragraph">
<p>Si espera que el usuario escriba un número entero, puede intentar convertir el valor de retorno a <code>Int64</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; println("¿Cuántos dejaron su casa, su tierra o su posesión?"); numero = readline()
¿Cuántos dejaron su casa, su tierra o su posesión?
115
"115"
julia&gt; parse(Int64, numero)
115</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pero si el usuario no escribe una cadena, obtendrá un error:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; println("¿Cuántos dejaron su casa, su tierra o su posesión?"); numero = readline()
¿Cuántos dejaron su casa, su tierra o su posesión?
Más de ciento quince son.
"Más de ciento quince son."
julia&gt; parse(Int64, speed)
ERROR: ArgumentError: invalid base 10 digit 'M' in "Más de ciento quince son."
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Veremos qué hacer con este tipo de error más adelante.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_5">Depuración</h3>
<div class="paragraph">
<p>Cuando se produce un error de sintaxis o de tiempo de ejecución, el mensaje de error contiene mucha información, lo cual puede ser abrumador. Las partes más útiles suelen ser:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Qué tipo de error fue, y</p>
</li>
<li>
<p>Dónde ocurrió.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los errores de sintaxis suelen ser fáciles de encontrar, pero hay algunos trucos. En general, los mensajes de error indican dónde se descubrió el problema, pero el error real podría estar antes en el código, a veces en una línea anterior.</p>
</div>
<div class="paragraph">
<p>Lo mismo aplica para los errores de tiempo de ejecución. Suponga que está tratando de calcular una relación señal/ruido en decibelios. La formula es</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{S/R_{\mathrm{db}} = 10 \log_{10} \frac{P_{\mathrm{señal}}}{P_{\mathrm{ruido}}}\ .}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>En Julia, se podría escribir algo como esto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">intensidad_señal = 9
intendidad_ruido = 10
relacion = intensidad_señal ÷ intendidad_ruido
decibeles = 10 * log10(relacion)
print(decibeles)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obteniendo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">-Inf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este no es el resultado que esperábamos.</p>
</div>
<div class="paragraph">
<p>Para encontrar el error, puede ser útil imprimir el valor de la variable "relacion", que resulta ser 0. El problema está en la línea 3, que usa la división de tipo piso en lugar de la división de punto flotante.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>Debes tomarte el tiempo de leer los mensajes de error cuidadosamente, pero no asumas que todo lo que dicen es correcto.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_5">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">División de tipo piso</dt>
<dd>
<p>Un operador, denotado por <code>÷</code>, que divide dos números y redondea hacia abajo (hacia el infinito negativo) a un entero.
</p>
</dd>
<dt class="hdlist1">operador módulo</dt>
<dd>
<p>Un operador, denotado con el signo de porcentaje (%), que se utiliza con enteros y devuelve el resto cuando un número se divide por otro.
</p>
</dd>
<dt class="hdlist1">expresión booleana</dt>
<dd>
<p>Una expresión cuyo valor es <code>verdadero</code> o <code>falso</code>.
</p>
</dd>
<dt class="hdlist1">operador relacional</dt>
<dd>
<p>Uno de los operadores que compara sus operandos: <code>==</code>, <code>≠</code> (<code>!=</code>), <code>&gt;</code>, <code>&lt;</code>, <code>≥</code> (<code>&gt;=</code>), and <code>≤</code> (<code>&lt;=</code>).
</p>
</dd>
<dt class="hdlist1">operador lógico</dt>
<dd>
<p>Uno de los operadores que combina expresiones booleanas: <code>&amp;&amp;</code> (and), <code>||</code> (or), and <code>!</code> (not).
</p>
</dd>
<dt class="hdlist1">sentencia condicional</dt>
<dd>
<p>Una sentencia que controla el flujo de ejecución dependiendo de alguna condición.
</p>
</dd>
<dt class="hdlist1">condición</dt>
<dd>
<p>La expresión booleana en una sentencia condicional que determina qué rama se ejecuta.
</p>
</dd>
<dt class="hdlist1">sentencia compuesta</dt>
<dd>
<p>Una sentencia que consta de un encabezado y un cuerpo. El cuerpo termina con la palabra reservada <code>end</code>.
</p>
</dd>
<dt class="hdlist1">rama</dt>
<dd>
<p>Una de las secuencias alternativas de sentencias en una sentencia condicional.
</p>
</dd>
<dt class="hdlist1">condicional encadenada</dt>
<dd>
<p>Una sentencia condicional con una serie de ramas alternativas.
A conditional statement with a series of alternative branches.
</p>
</dd>
<dt class="hdlist1">condicional anidada</dt>
<dd>
<p>Una sentencia condicional que aparece en una de las ramas de otra sentencia condicional.
</p>
</dd>
<dt class="hdlist1">sentencia return</dt>
<dd>
<p>Una sentencia que hace que una función finalice de inmediato y que vuelva a la sentencia de llamada a función.
</p>
</dd>
<dt class="hdlist1">recursividad o recursión</dt>
<dd>
<p>El proceso de llamar a la función que se está ejecutando actualmente.
</p>
</dd>
<dt class="hdlist1">caso base</dt>
<dd>
<p>Una rama condicional en una función recursiva que no realiza una llamada recursiva.
</p>
</dd>
<dt class="hdlist1">recursión infinita</dt>
<dd>
<p>Una recursión que no tiene un caso base, o que nunca llega a él. Eventualmente, una recursión infinita provoca un error de tiempo de ejecución.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_6">Ejercicios</h3>
<div class="sect3">
<h4 id="ex05-1">Ejercicio 5-2</h4>
<div class="paragraph">
<p>La función <code>time</code> devuelve el tiempo medio de Greenwich actual en segundos desde "la época", que es un tiempo arbitrario utilizado como punto de referencia. En sistemas UNIX, la época es el 1 de enero de 1970.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; time()
1.582059889961293e9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Escriba un script que lea la hora actual y la convierta a una hora del día en horas, minutos y segundos, más el número de días transcurridos desde la época.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex05-2">Ejercicio 5-3</h4>
<div class="paragraph">
<p>El último teorema de Fermat dice que no hay enteros positivos \(a\), \(b\), and \(c\) tal que
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{a^n + b^n = c^n}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>para cualquier valor de latexmath: [\ (n \)] mayor que 2.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escriba una función llamada <code>verificarfermat</code> que tome cuatro parámetros—<code>a</code>, <code>b</code>, <code>c</code> and <code>n</code>— y que verifique si el teorema de Fermat es válido. Si <code>n</code> es mayor que 2 y <code>a^n + b^n == c^n</code> el programa debería imprimir, "¡Santo cielo, Fermat estaba equivocado!" De lo contrario, el programa debería imprimir, "No, eso no funciona".
</p>
</li>
<li>
<p>Escriba una función que solicite al usuario ingresar valores para <code>a</code>, <code>b</code>, <code>c</code> and <code>n</code>, que los convierta en enteros y que use <code>verificarfermat</code> para verificar si violan el teorema de Fermat.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="ex05-3">Ejercicio 5-4</h4>
<div class="paragraph">
<p>Si tienes tres barras, estas podrían o no formar un triángulo. Por ejemplo, si una de las barras tiene 12 centimetros de largo y las otras dos tienen un centimetro de largo, no es posible que las barras pequeñas puedan juntarse al medio. Para cualquier trío de longitudes, hay una prueba simple para ver si es posible formar un triángulo:</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Si cualquiera de las tres longitudes es mayor que la suma de las otras dos, entonces no se puede formar un triángulo. De lo contrario, se puede. (Si la suma de dos longitudes es igual a la tercera, forman lo que se llama un triángulo "degenerado").</p>
</div>
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escriba una función llamada <code>estriangulo</code> que tome tres enteros como argumentos, y que imprima “Sí” o “No”, dependiendo de si se puede o no formar un triángulo a partir de barras de las longitudes dadas.
</p>
</li>
<li>
<p>Escriba una función que solicite al usuario ingresar tres longitudes de barras, que las convierta en enteros y use <code>estriangulo</code> para verificar si las barras con las longitudes dadas pueden formar un triángulo.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="ex05-4">Ejercicio 5-5</h4>
<div class="paragraph">
<p>¿Cuál es el resultado del siguiente programa? Dibuje un diagrama de pila que muestre el estado del programa cuando imprime el resultado.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function recursion(n, s)
    if n == 0
        println(s)
    else
        recursion(n-1, n+s)
    end
end

recursion(3, 0)</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>¿Qué pasaría si llamaras a esta función así: <code>recursion(-1, 0)</code>?</p>
</li>
<li>
<p>Escriba una documento que explique todo lo que alguien necesitaría saber para usar esta función (y nada más).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Los siguientes ejercicios utilizan el módulo <code>PiensaEnJulia</code>, descrito en <a href="#chap04">Estudio de Caso: Diseño de Interfaz</a>:</p>
</div>
</div>
<div class="sect3">
<h4 id="ex05-5">Ejercicio 5-6</h4>
<div class="paragraph">
<p>Lea la siguiente función y vea si puede averiguar qué hace (vea los ejemplos en <a href="#chap04">Estudio de Caso: Diseño de Interfaz</a>). Luego ejecútelo y vea si lo hizo bien.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function dibujar(t, distancia, n)
    if n == 0
        return
    end
    angulo = 50
    adelante(t, distancia*n)
    girar(t, -angulo)
    dibujar(t, distancia, n-1)
    girar(t, 2*angulo)
    dibujar(t, distancia, n-1)
    girar(t, -angulo)
    adelante(t, -distancia*n)
end</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ex05-6">Ejercicio 5-7</h4>
<div id="fig05-2" class="imageblock">
<div class="content">
<img src="images/fig52.svg" alt="fig52">
</div>
<div class="title">Figura 8. Una curva de Koch</div>
</div>
<div class="paragraph">
<p>La curva de Koch es un fractal que luce como <a href="#fig05-2">Una curva de Koch</a>. Para dibujar una curva de Koch con longitud latexmath: [\(x\)], todo lo que tiene que hacer es
</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Dibuje una curva de Koch con longitud \(\frac{x}{3}\).</p>
</li>
<li>
<p>Gire a la izquierda 60 grados.</p>
</li>
<li>
<p>Dibuje una curva de Koch con longitud \(\frac{x}{3}\).</p>
</li>
<li>
<p>Gire a la derecha 120 grados.</p>
</li>
<li>
<p>Dibuje una curva de Koch con longitud \(\frac{x}{3}\).</p>
</li>
<li>
<p>Gire a la izquierda 60 grados.</p>
</li>
<li>
<p>Dibuje una curva de Koch con longitud \(\frac{x}{3}\).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>La excepción es cuando \(x\) es menor que 3: en ese caso, puede dibujar una línea recta con una longitud \(x\).</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escribe una función llamada <code>koch</code> que tome una tortuga y una longitud como parámetros, y que use la tortuga para dibujar una curva de Koch con la longitud dada.
</p>
</li>
<li>
<p>Escriba una función llamada <code>copodenieve</code> que dibuje tres curvas de Koch para hacer el contorno de un copo de nieve.
</p>
</li>
<li>
<p>La curva de Koch se puede generalizar de varias maneras. Consulte <a href="https://en.wikipedia.org/wiki/Koch_snowflake" class="bare">https://en.wikipedia.org/wiki/Koch_snowflake</a> para ver ejemplos e implementar su favorito.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap06">6. Funciones productivas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Muchas de las funciones de Julia que hemos utilizado, como las funciones matemáticas, producen valores de retorno. Todas las funciones que hemos escrito hasta ahora son nulas, es decir, tienen un efecto (como imprimir un valor) pero devuelven el valor <code>nothing</code>. En este capítulo aprenderemos a escribir funciones productivas.
</p>
</div>
<div class="sect2">
<h3 id="_valores_de_retorno">Valores de retorno</h3>
<div class="paragraph">
<p>Llamar a la función genera un valor de retorno, que generalmente asignamos a una variable o usamos como parte de una expresión.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">e = exp(1.0)
altura = radio * sin(radio)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las funciones que hemos escrito hasta ahora son nulas. Coloquialmente hablando, no tienen valor de retorno; de manera formal, su valor de retorno es <code>nothing</code>. En este capítulo, (finalmente) vamos a escribir funciones productivas. El primer ejemplo es <code>area</code>, que devuelve el área de un círculo dado un radio:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function area(radio)
    a = π * radio^2
    return a
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hemos visto la sentencia <code>return</code> antes, pero en una función productiva la sentencia <code>return</code> incluye una expresión. Esta sentencia significa: "Retorne inmediatamente de esta función y use la siguiente expresión como valor de retorno". La expresión dada puede ser arbitrariamente complicada; así pues, podríamos haber escrito esta función más concisamente:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function area(radio)
    π * radio^2
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El valor devuelto por una función es el valor de la última expresión evaluada, que, por defecto, es la última expresión en el cuerpo de la definición de la función.</p>
</div>
<div class="paragraph">
<p>Por otro lado, las <em>variables temporales</em> como <code>a</code>, y las sentencias <code>return</code> explícitas pueden facilitar la depuración.
</p>
</div>
<div class="paragraph">
<p>A veces es útil tener múltiples sentencias <code>return</code>, una en cada rama de una sentencia condicional:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function valorabsoluto(x)
    if x &lt; 0
        return -x
    else
        return x
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dado que estas sentencias return están en una condicional alternativa, solo se ejecuta una.
</p>
</div>
<div class="paragraph">
<p>En cuanto se ejecuta una sentencia return, la función termina sin ejecutar ninguna de las sentencias siguientes. El código que aparezca después de la sentencia return, o en cualquier otro lugar al que el flujo de ejecución nunca llegará, se llama código muerto.
</p>
</div>
<div class="paragraph">
<p>En una función productiva, es una buena idea asegurarse que cualquier posible recorrido del programa llegue a una sentencia return. Por ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function valorabsoluto(x)
    if x &lt; 0
        return -x
    end
    if x &gt; 0
        return x
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta versión no es correcta porque si <code>x</code> es igual a 0, ninguna de las condiciones es verdadera, y la función termina sin alcanzar una sentencia return. Si el flujo de ejecución llega al final de la función, el valor de retorno es <code>nothing</code>, que claramente no es el valor absoluto de 0.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; show(valorabsoluto(0))
nothing</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Julia tiene una función incorporada llamada <code>abs</code> que calcula los valores absolutos.
</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_ejercicio_6_1">Ejercicio 6-1</h4>
<div class="paragraph">
<p>Escriba la función <code>comparar</code> que tome dos valores, <code>x</code> y <code>y</code>, y que devuelva <code>1</code> si <code>x &gt; y</code>, <code>0</code> si <code>x == y</code>, y <code>-1</code> si <code>x &lt; y</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="incremental_development">Desarrollo incremental</h3>
<div class="paragraph">
<p>Conforme vaya escribiendo funciones más extensas puede empezar a dedicar más tiempo a la depuración.
</p>
</div>
<div class="paragraph">
<p>Para lidiar con programas de complejidad creciente, se sugiere una técnica llamada desarrollo incremental. El objetivo del desarrollo incremental es evitar largas sesiones de depuración, adicionando y probando solamente pequeñas porciones de código cada vez.
</p>
</div>
<div class="paragraph">
<p>Por ejemplo, suponga que desea encontrar la distancia entre dos puntos dados por las coordenadas \(\left(x_1, y_1\right)\) y \(\left(x_2, y_2\right)\). Por el teorema de Pitágoras, la distancia es:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>El primer paso es considerar qué aspecto tendría la función distancia en Julia. En otras palabras, ¿cuáles son las entradas (parámetros) y cuál es la salida (valor de retorno)?</p>
</div>
<div class="paragraph">
<p>En este caso las entradas son los dos puntos, que podemos representar usando cuatro números. El valor devuelto es la distancia, que es un valor de punto flotante.</p>
</div>
<div class="paragraph">
<p>Escribamos una primera versión de la función:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function distancia(x₁, y₁, x₂, y₂)
    0.0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviamente esta versión de la función no calcula distancias; siempre devuelve cero. Pero es correcta sintácticamente y se ejecutará, lo que implica que la podemos probar antes de hacerla más compleja. Los números de subíndice están disponibles en la codificación de caracteres Unicode (<strong><code>\_1 TAB</code></strong>, <strong><code>\_2 TAB</code></strong>, etc.).
</p>
</div>
<div class="paragraph">
<p>Para probar la nueva función, la llamamos con una muestra de valores:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">distance(1, 2, 4, 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se eligen estos valores de tal forma que la distancia horizontal sea igual a 3 y la distancia vertical sea igual a 4; de esa manera el resultado es 5 (la hipotenusa del triángulo 3-4-5). Cuando se comprueba una función, es útil conocer la respuesta correcta.</p>
</div>
<div class="paragraph">
<p>Hasta el momento hemos confirmado que la función es sintácticamente correcta, por lo que podemos empezar a agregar líneas de código. El paso lógico siguiente es encontrar las diferencias \(x_2 - x_1\) y \(y_2 - y_1\). En la siguiente versión de la función almacenaremos estos valores en variables temporales y las mostraremos con el macro <code>@show</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function distancia(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    @show dx dy
    0.0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si la función trabaja bien, las salidas deben ser <code>dx = 3</code> y <code>dy = 4</code>. Si es así, sabemos que la función está obteniendo los parámetros correctos y realizando el primer cálculo correctamente. Si no, entonces sólo hay unas pocas líneas que revisar.</p>
</div>
<div class="paragraph">
<p>A continuación calculamos la suma de los cuadrados de <code>dx</code> y <code>dy</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function distancia(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    d² = dx^2 + dy^2
    @show d²
    0.0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>De nuevo queremos ejecutar el programa en esta etapa y comprobar la salida (que debería ser 25). Los números en superíndice también están disponibles (<strong><code>\^2 TAB</code></strong>). Finalmente, se puede usar <code>sqrt</code> para calcular y devolver el resultado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function distancia(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    d² = dx^2 + dy^2
    sqrt(d²)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si esto funciona correctamente, habremos terminado. Si no, podríamos mostrar el valor de la variable resultado antes de la sentencia de retorno.</p>
</div>
<div class="paragraph">
<p>La versión final de la función no muestra nada cuando se ejecuta; sólo retorna un valor. Las sentencias print que escribimos son útiles para la depuración, pero una vez que el programa esté funcionando correctamente, se deben eliminar. El código eliminado se llama <em>andamiaje</em> porque es útil para construir el programa pero no es parte del producto final.
</p>
</div>
<div class="paragraph">
<p>Al principio, debería añadir solamente una o dos líneas de código cada vez. Conforme vaya ganando experiencia, puede que se encuentre escribiendo y depurando fragmentos mayores de código. Sin embargo, el proceso de desarrollo incremental puede ahorrarle mucho tiempo de depuración.</p>
</div>
<div class="paragraph">
<p>Los aspectos clave del proceso son:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Inicie con un programa que funcione y hágale pequeños cambios incrementales. En cualquier momento, si hay un error, sabrá exactamente dónde está.</p>
</li>
<li>
<p>Use variables temporales para guardar valores intermedios para que pueda mostrarlos y verificarlos.</p>
</li>
<li>
<p>Una vez que el programa está funcionando, tal vez prefiera eliminar parte del andamiaje o consolidar múltiples sentencias en expresiones compuestas, pero sólo si eso no hace que el programa sea difícil de leer.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_ejercicio_6_2">Ejercicio 6-2</h4>
<div class="paragraph">
<p>Use la técnica de desarrollo incremental para escribir una función llamada <code>hipotenusa</code> que retorne el largo de la hipotenusa de un triángulo rectángulo dado el largo de las otras dos aristas. Registre cada etapa del proceso de desarrollo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_composición_2">Composición</h3>
<div class="paragraph">
<p>Ahora, como usted esperaría, se puede llamar a una función desde otra. Como ejemplo, escribiremos una función que tome dos puntos, el centro del círculo y un punto del perímetro, y calcule el área del círculo.
</p>
</div>
<div class="paragraph">
<p>Suponga que el punto central está almacenado en las variables <code>xc</code> y <code>yc</code>, y que el punto del perímetro lo está en <code>xp</code> y <code>yp</code>. El primer paso es hallar el radio del círculo, que es la distancia entre los dos puntos. Hemos escrito la función distancia que realiza esta tarea:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">radio = distancia(xc, yc, xp, yp)</code></pre>
</div>
</div>
<div class="paragraph">
<p>El siguiente paso es encontrar el área del círculo usando este radio. De nuevo usaremos una de las funciones definidas previamente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">resultado = area(radio)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Envolviendo todo en una función, obtenemos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function areacirculo(xc, yc, xp, yp)
    radio = distancia(xc, yc, xp, yp)
    resultado = area(radio)
    return resultado
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las variables temporales <code>radio</code> y <code>resultado</code> son útiles para el desarrollo y la depuración, pero una vez que el programa está funcionando, podemos hacerlo más conciso componiendo las llamadas a función:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function areacirculo(xc, yc, xp, yp)
    area(distancia(xc, yc, xp, yp))
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boolean_functions">Funciones Booleanas</h3>
<div class="paragraph">
<p>Las funciones pueden devolver valores booleanos, lo que a menudo es conveniente para ocultar complicadas comprobaciones dentro de funciones. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function esdivisible(x, y)
    if x % y == 0
        return true
    else
        return false
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Es común dar a las funciones booleanas nombres que suenan como preguntas que tienen como respuesta un si ó un no; es_divisible devuelve <code>true</code> o <code>false</code> para indicar si <code>x</code> es o no divisible por <code>y</code>.</p>
</div>
<div class="paragraph">
<p>Por ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; esdivisible(6, 4)
false
julia&gt; esdivisible(6, 3)
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado del operador <code>==</code> es booleano, por lo tanto podemos escribir la función de una manera más concisa devolviendo el resultado directamente:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function esdivisible(x, y)
    x % y == 0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las funciones booleanas se usan a menudo en las sentencias condicionales:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if esdivisible(x, y)
    println("x es divisible por y")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puede parecer tentador escribir algo como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if esdivisible(x, y) == true
    println("x es divisible por y")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pero la comparación extra con <code>true</code> es innecesaria.</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_6_3">Ejercicio 6-3</h4>
<div class="paragraph">
<p>Escriba la función <code>entremedio(x,y,z)</code> que devuelva <code>true</code> si <code>x ≤ y ≤ z</code>, o <code>false</code> en otro caso.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_más_recursividad">Más recursividad</h3>
<div class="paragraph">
<p>Solo hemos cubierto una pequeña parte de Julia, pero le puede interesar saber que esta parte ya es un lenguaje de programación <em>completo</em>, lo que significa que cualquier cómputo puede expresarse en este lenguaje. Cualquier programa que se haya escrito podría reescribirse usando solo lo que ha aprendido hasta ahora (en realidad, necesitaría algunos comandos para controlar dispositivos como el mouse, discos, etc., pero eso es todo).
</p>
</div>
<div class="paragraph">
<p>Probar esa afirmación es un ejercicio no trivial realizado por primera vez por Alan Turing, uno de los primeros científicos de la computación (algunos argumentarían que era matemático, pero muchos de los primeros científicos informáticos comenzaron como matemáticos). En consecuencia, esto se conoce como la Tesis de Turing. Para una discusión más completa (y precisa) de la Tesis de Turing, se recomienda el libro de Michael Sipser <em>Introducción a la Teoría de la Computación</em>.
</p>
</div>
<div class="paragraph">
<p>Para darle una idea de lo que puede hacer con las herramientas que ha aprendido hasta ahora, evaluaremos algunas funciones matemáticas definidas recursivamente. Una definición recursiva es similar a una definición circular, en el sentido de que la definición contiene una referencia a lo que está siendo definido. Una definición verdaderamente circular no es muy útil:
</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">vorpal</dt>
<dd>
<p>Un adjetivo usado para describir algo que es vorpal.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Si ves esta definición en el diccionario, podrías molestarte. Por otro lado, si buscas la definición de la función factorial, denotada con el símbolo \(!\), podrías encontrar algo como esto:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{n! =
\begin{cases}
  1&amp; \textrm{if}\  n = 0 \\
  n (n-1)!&amp; \textrm{if}\  n &gt; 0
\end{cases}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Esta definición dice que el factorial de 0 es 1, y el factorial de cualquier otro valor \(n\), es \(n\)  multiplicado por el factorial de \(n-1\).</p>
</div>
<div class="paragraph">
<p>Entonces \(3!\) es 3 veces \(2!\), que es 2 veces \(1!\), que es 1 vez \(0!\). Es decir, \(3!\) es igual a 3 por 2 por 1 por 1, que es 6.</p>
</div>
<div class="paragraph">
<p>Si se puede escribir una definición recursiva, se puede escribir un programa de Julia para evaluarlo. El primer paso es decidir cuáles deberían ser los parámetros. En este caso, debe quedar claro que factorial toma valores enteros:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fact(n) end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si el argumento es <code>0</code>, la función debe devolver <code>1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fact(n)
    if n == 0
        return 1
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>De lo contrario, y esto es lo interesante, tenemos que hacer una llamada recursiva para encontrar el factorial de <code>n-1</code> y luego multiplicarlo por <code>n</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fact(n)
    if n == 0
        return 1
    else
        recursion = fact(n-1)
        resultado = n * recursion
        return resultado
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El flujo de ejecución de este programa es similar al flujo de <code>cuentaregresiva</code> en <a href="#recursion">[recursion]</a>. Si llamamos a <code>fact</code> con el valor <code>3</code>:
</p>
</div>
<div class="openblock small">
<div class="content">
<div class="paragraph">
<p>Como <code>3</code> no es <code>0</code>, tomamos la segunda rama y calculamos el factorial de <code>n-1</code> &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;Como <code>2</code> no es <code>0</code>, tomamos la segunda rama y calculamos el factorial de <code>n-1</code> &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;Como <code>1</code> no es <code>0</code>, tomamos la segunda rama y calculamos el factorial de + n-1 + &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;&#8193;Como <code>0</code> es igual a <code>0</code>, tomamos la primera rama y devolvemos <code>1</code> sin realizar <br/>&#8193;&#8193;&#8193;&#8193; más llamadas recursivas.</p>
</div>
<div class="paragraph">
<p>&#8193;&#8193;El valor de retorno, <code>1</code>, se multiplica por <code>n</code>, que es <code>1</code>, y se devuelve el <code>resultado</code>.</p>
</div>
<div class="paragraph">
<p>&#8193;El valor de retorno, <code>1</code>, se multiplica por <code>n</code>, que es <code>2</code>, y se devuelve el <code>resultado</code>.</p>
</div>
<div class="paragraph">
<p>El valor de retorno <code>2</code> se multiplica por <code>n</code>, que es <code>3</code>, y el resultado, <code>6</code>, se convierte en el valor de retorno de la llamada a  función que inició todo el proceso.</p>
</div>
</div>
</div>
<div id="fig06-1" class="imageblock">
<div class="content">
<img src="images/fig61.svg" alt="fig61">
</div>
<div class="title">Figura 9. Stack diagram</div>
</div>
<div class="paragraph">
<p><a href="#fig06-1">Stack diagram</a>  muestra cómo se ve el diagrama de pila para esta secuencia de llamadas a funciones.
</p>
</div>
<div class="paragraph">
<p>Los valores de retorno se pasan de nuevo a la pila. En cada marco, el valor de retorno es el valor de <code>resultado</code>, que es el producto de <code>n</code> y <code>recursion</code>.</p>
</div>
<div class="paragraph">
<p>En el último marco, las variables locales <code>recursion</code> y <code>resultado</code> no existen, porque la rama que las crea no se ejecuta.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Julia tiene la función <code>factorial</code> para calcular el factorial de un número entero.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_salto_de_fe">Salto de fe</h3>
<div class="paragraph">
<p>Seguir el flujo de ejecución es una forma de leer programas, pero puede llegar a ser abrumador. Una alternativa es lo que llamamos el "salto de fe". Cuando llega a una llamada de función, en lugar de seguir el flujo de ejecución, asume que la función funciona correctamente y devuelve el resultado correcto.
</p>
</div>
<div class="paragraph">
<p>De hecho, ya estás haciendo este salto de fe cuando usas funciones integradas de Julia. Cuando llamas a <code>cos</code> o <code>exp</code>, no examinas los cuerpos de esas funciones. Simplemente asumes que funcionan porque las personas que las escribieron eran buenos programadores.</p>
</div>
<div class="paragraph">
<p>Lo mismo ocurre cuando llamas a una de tus propias funciones. Por ejemplo, en <a href="#boolean_functions">Funciones Booleanas</a>, escribimos una función llamada <code>esdivisible</code> que determina si un número es divisible por otro. Una vez que nos hayamos convencido de que esta función es correcta —al examinar y probar el código—, podemos usar la función sin mirar nuevamente el cuerpo.</p>
</div>
<div class="paragraph">
<p>Lo mismo aplica a los programas recursivos. Cuando llegue a la llamada recursiva, en lugar de seguir el flujo de ejecución, debe suponer que la llamada recursiva funciona (devuelve el resultado correcto) y luego preguntarse: "Suponiendo que pueda encontrar el factorial de \(n-1\), ¿puedo calcular el factorial de \(n\)? ”Está claro que puedes, multiplicando por \(n\).</p>
</div>
<div class="paragraph">
<p>Por supuesto, es un poco extraño suponer que la función funciona correctamente cuando no ha terminado de escribirla, ¡pero por eso se llama un salto de fe!</p>
</div>
</div>
<div class="sect2">
<h3 id="one_more_example">Un Ejemplo Más</h3>
<div class="paragraph">
<p>Después de los factoriales, el ejemplo más común de una función matemática definida de manera recursiva es fibonacci, que tiene la siguiente definición (ver <a href="https://en.wikipedia.org/wiki/Fibonacci_number" class="bare">https://en.wikipedia.org/wiki/Fibonacci_number</a>):
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{fib(n) =
\begin{cases}
    0&amp; \textrm{if}\  n = 0 \\
    1&amp; \textrm{if}\  n = 1 \\
    fib(n-1) + fib(n-2)&amp; \textrm{if}\  n &gt; 1
\end{cases}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Traducido a Julia, se ve así:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fib(n)
    if n == 0
        return 0
    elseif n == 1
        return 1
    else
        return fib(n-1) + fib(n-2)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si intentas seguir el flujo de ejecución en esta función, incluso para valores bastante pequeños de <code>n</code>, su cabeza podría estallar. Haciendo un salto de fe, es decir, asumiendo que las dos llamadas recursivas funcionan correctamente, entonces está claro que se obtiene el resultado correcto al sumarlas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tipos_de_comprobación">Tipos de Comprobación</h3>
<div class="paragraph">
<p>¿Qué pasa si llamamos a <code>fact</code> con <code>1.5</code> como argumento?
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fact(1.5)
ERROR: StackOverflowError:
Stacktrace:
 [1] fact(::Float64) at ./REPL[3]:2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parece una recursión infinita. ¿Como es esto posible? La función tiene un caso base (cuando <code>n == 0</code>). Pero si <code>n</code> no es un número entero, podemos <em>perdernos</em> el caso base y hacer recursión para siempre.
</p>
</div>
<div class="paragraph">
<p>En la primera llamada recursiva, el valor de <code>n</code> es <code>0.5</code>. En el siguiente, es <code>-0.5</code>. A partir de ahí, se vuelve más pequeño (más negativo), pero nunca será <code>0</code>.</p>
</div>
<div class="paragraph">
<p>Tenemos dos opciones. Podemos intentar generalizar la función factorial para trabajar con números de punto flotante, o podemos hacer que <code>fact</code> verifique el tipo del argumento. La primera opción se llama función gamma, y está un poco más allá del alcance de este libro. Entonces intentaremos con la segunda.
</p>
</div>
<div class="paragraph">
<p>Podemos usar el operador integrado <code>isa</code> para verificar el tipo de argumento. También podemos asegurarnos de que el argumento sea positivo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fact(n)
    if !(n isa Int64)
        error("Factorial is only defined for integers.")
    elseif n &lt; 0
        error("Factorial is not defined for negative integers.")
    elseif n == 0
        return 1
    else
        return n * fact(n-1)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El primer caso base se hace cargo de números no enteros; el segundo de enteros negativos. En ambos casos, el programa imprime un mensaje de error y devuelve <code>nothing</code> para indicar que algo salió mal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fact("fred")
ERROR: Factorial is only defined for integers.
julia&gt; fact(-2)
ERROR: Factorial is not defined for negative integers.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si superamos ambas verificaciones, sabemos que <code>n</code> es positivo o cero, por lo que podemos probar que la recursión termina.</p>
</div>
<div class="paragraph">
<p>Este programa muestra un patrón a veces llamado <em>guardian</em>. Los dos primeros condicionales actúan como guardianes, protegiendo el código que sigue de los valores que pueden causar un error. Los guardianes hacen posible demostrar que el código es correcto.
</p>
</div>
<div class="paragraph">
<p>En <a href="#catching_exceptions">Captura de Excepciones</a> veremos una alternativa más flexible para imprimir un mensaje de error: generar una excepción.</p>
</div>
</div>
<div class="sect2">
<h3 id="deb06">Depuración</h3>
<div class="paragraph">
<p>Dividir un código extenso en pequeñas funciones crea naturalmente puntos de control para la depuración. Si un programa no está funcionando, existen tres posibilidades a considerar:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hay algo incorrecto en los argumentos de la función; se viola una condición previa.
</p>
</li>
<li>
<p>Hay algo incorrecto en la función; se viola una condición posterior.
</p>
</li>
<li>
<p>Hay algo incorrecto en el valor de retorno o la forma en que se está utilizando.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para descartar la primera posibilidad, puedes agregar una sentencia de impresión al comienzo de la función para mostrar los valores de los parámetros (y tal vez sus tipos). O puedes escribir líneas de código que verifiquen las condiciones previas de manera explícita.</p>
</div>
<div class="paragraph">
<p>Si los parámetros están bien, agregue una sentencia de impresión antes de cada sentencia return y muestre el valor de retorno. Si es posible, verifique el resultado a mano. Considere llamar a la función con valores que faciliten la verificación del resultado (como en <a href="#incremental_development">Desarrollo incremental</a>).</p>
</div>
<div class="paragraph">
<p>Si la función parece estar funcionando, revise la llamada a función para asegurarse de que el valor de retorno se está utilizando correctamente (¡o incluso si se está utilizando!).</p>
</div>
<div class="paragraph">
<p>Agregar sentencias de impresión al principio y al final de una función puede ayudar a que el flujo de ejecución sea más transparente. Por ejemplo, aquí hay una versión de <code>fact</code> con sentencias de impresión:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fact(n)
    espacio = " " ^ (4 * n)
    println(espacio, "factorial ", n)
    if n == 0
        println(espacio, "returning 1")
        return 1
    else
        recursion = fact(n-1)
        resultado = n * recursion
        println(espacio, "devolviendo ", resultado)
        return resultado
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>espacio</code> es una cadena de caracteres de espacio que permite generar sangría en la salida:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fact(4)
                factorial 4
            factorial 3
        factorial 2
    factorial 1
factorial 0
returning 1
    devolviendo 1
        devolviendo 2
            devolviendo 6
                devolviendo 24
24</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si estás confundido con el flujo de ejecución, este tipo de salida puede ser útil. Desarrollar un buen andamiaje toma tiempo, pero un poco de andamiaje puede evitarnos mucha depuración.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossary">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">variable temporal</dt>
<dd>
<p>Variable usada para almacenar un valor intermedio en un cálculo complejo.
</p>
</dd>
<dt class="hdlist1">código muerto</dt>
<dd>
<p>Parte de un programa que nunca puede ser ejecutado, a menudo porque aparece después de una sentencia return.
</p>
</dd>
<dt class="hdlist1">desarrollo incremental</dt>
<dd>
<p>Plan de desarrollo de un programa que intenta evitar la depuración agregando y probando solamente una pequeña porción de código a la vez.
</p>
</dd>
<dt class="hdlist1">andamiaje</dt>
<dd>
<p>Código que se usa durante el desarrollo de un programa pero que no es parte de la versión final del mismo.
</p>
</dd>
<dt class="hdlist1">guardián</dt>
<dd>
<p>Un patrón de programación que usa una sentencia condicional para verificar y manejar circunstancias que puedan causar un error.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_7">Ejercicios</h3>
<div class="sect3">
<h4 id="ex06-1">Ejercicio 6-4</h4>
<div class="paragraph">
<p>Dibuje un diagrama de pila para el siguiente programa. ¿Qué imprime el programa?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function b(z)
    prod = a(z, z)
    println(z, " ", prod)
    prod
end

function a(x, y)
    x = x + 1
    x * y
end

function c(x, y, z)
    total = x + y + z
    cuadrado = b(total)^2
    cuadrado
end

x = 1
y = x + 1
println(c(x, y+3, x+y))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ex06-2">Ejercicio 6-5</h4>
<div class="paragraph">
<p>La función de Ackermann, \(A(m, n)\), se define:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{A(m, n) =
\begin{cases}
              n+1&amp; \textrm{si}\ m = 0 \\
        A(m-1, 1)&amp; \textrm{si}\ m &gt; 0\ \textrm{y}\ n = 0 \\
A(m-1, A(m, n-1))&amp; \textrm{si}\ m &gt; 0\ \textrm{y}\ n &gt; 0.
\end{cases}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Vea <a href="https://en.wikipedia.org/wiki/Ackermann_function" class="bare">https://en.wikipedia.org/wiki/Ackermann_function</a>. Escriba una función llamada <code>ack</code> que evalúe la función de Ackermann. Use su función para evaluar <code>ack(3, 4)</code>, que debería ser 125. ¿Qué sucede para valores mayores de <code>m</code> y <code>n</code>?
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex06-3">Ejercicio 6-6</h4>
<div class="paragraph">
<p>Un palíndromo es una palabra que se escribe igual en un sentido que en otro, como "ana" y "radar". De manera recursiva, una palabra es un palíndromo si la primera y la última letra son iguales y lo que está entre ellas es un palíndromo.
</p>
</div>
<div class="paragraph">
<p>Las siguientes son funciones que toman un argumento de tipo cadena y devuelven la primera letra, la última, y las intermedias:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function primera(palabra)
    primera = firstindex(palabra)
    palabra[primera]
end

function ultima(palabra)
    ultima = lastindex(palabra)
    palabra[ultima]
end

function medio(palabra)
    primera = firstindex(palabra)
    ultima = lastindex(palabra)
    palabra[nextind(palabra, primera) : prevind(palabra, ultima)]
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Veremos cómo funcionan en <a href="#chap08">Cadenas</a>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Prueba estas funciones. ¿Qué sucede si llamas a la función medio con una cadena de dos letras? ¿Y con una cadena de una letra? ¿Qué pasa con la cadena vacía <code>""</code>, que no contiene letras?</p>
</li>
<li>
<p>Escriba una función llamada <code>espalindromo</code> que tome un argumento de tipo cadena y devuelva <code>true</code> si es un palíndromo y <code>false</code> de lo contrario. Recuerde que puede usar la función integrada <code>length</code> para verificar la longitud de una cadena.
</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="ex06-4">Ejercicio 6-7</h4>
<div class="paragraph">
<p>Un número, \(a\), es una potencia de \(b\) si es divisible por \(b\) y \(\frac{a}{b}\) es una potencia de \(b\). Escriba una función llamada <code>espotencia</code> que tome los parámetros <code>a</code> y <code>b</code> y devuelva <code>true</code> si <code>a</code> es una potencia de <code>b</code>.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Tendrás que pensar en el caso base.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ex06-5">Ejercicio 6-8</h4>
<div class="paragraph">
<p>El máximo común divisor (MCD) de \(a\) y \(b\) es el número más grande que los divide a ambos con resto 0.</p>
</div>
<div class="paragraph">
<p>Una forma de encontrar el MCD de dos números se basa en la observación de que si \(r\) es el resto cuando \(a\) se divide por \(b\), entonces <code>mcd(a, b) = mcd(b, r)</code>. Como caso base, podemos usar <code>mcd(a, 0) = a</code>.</p>
</div>
<div class="paragraph">
<p>Escriba una función llamada <code>mcd</code> que tome los parámetros <code>a</code> y <code>b</code> y devuelva su máximo divisor común.
</p>
</div>
<div class="paragraph">
<p>Créditos: Este ejercicio se basa en un ejemplo del libro <em>Estructura e interpretación de programas informáticos</em> de Abelson y Sussman.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap07">7. Iteración</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo se centra en la iteración, que es la capacidad de ejecutar repetidamente un bloque de sentencias. Hemos visto dos tipos de iteración: usando recursión en <a href="#recursion">[recursion]</a>, y usando ciclos <code>for</code>, en <a href="#simple_repetition">Repetición Simple</a>. En este capítulo veremos otro tipo más: usando sentencias <code>while</code>. Primeramente, se introducirán algunos términos sobre asignación de variables.
</p>
</div>
<div class="sect2">
<h3 id="_asignación_múltiple">Asignación múltiple</h3>
<div class="paragraph">
<p>Puede que ya haya descubierto que está permitido realizar más de una asignación a la misma variable. Una nueva asignación hace que la variable existente se refiera a un nuevo valor (y deje de referirse al viejo valor).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = 5
5
julia&gt; x = 7
7</code></pre>
</div>
</div>
<div class="paragraph">
<p>La primera vez que se muestra <code>x</code> su valor es 5, y la segunda vez su valor es 7</p>
</div>
<div id="fig07-1" class="imageblock">
<div class="content">
<img src="images/fig71.svg" alt="fig71">
</div>
<div class="title">Figura 10. State diagram</div>
</div>
<div class="paragraph">
<p><a href="#fig07-1">State diagram</a> muestra el aspecto de una <em>asignación múltiple</em> en un diagrama de estado.
</p>
</div>
<div class="paragraph">
<p>Es necesario aclarar algo que puede causar confusión. Puesto que Julia usa el signo igual (<code>=</code>) para la asignación, es tentador interpretar una sentencia <code>a = b</code> como una sentencia de igualdad. Pero esta interpretación es incorrecta.
</p>
</div>
<div class="paragraph">
<p>Para empezar, la igualdad es simétrica y la asignación no lo es. Por ejemplo, en matemáticas, si \(a=7\) entonces \(7=a\). Pero en Julia la sentencia <code>a = 7</code> es válida, y <code>7 = a</code> no lo es.</p>
</div>
<div class="paragraph">
<p>Además, en matemáticas, una sentencia de igualdad es verdadera o falsa siempre. Si \(a=b\) ahora, entonces \(a\) siempre será igual a \(b\). En Julia, una sentencia de asignación puede hacer que dos variables sean iguales, pero no tienen por qué quedarse así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = 5
5
julia&gt; b = a    # a y b son iguales
5
julia&gt; a = 3    # a y b ya no son iguales
3
julia&gt; b
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>La tercera línea cambia el valor de <code>a</code> pero no cambia el valor de <code>b</code>, por lo tanto ya dejan de ser iguales.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>Reasignar variables puede ser útil, pero se debe tener precaución. Si los valores cambian frecuentemente, la reasignación puede hacer que el código sea difícil de leer y depurar.</p>
</div>
<div class="paragraph">
<p>Está permitido definir una función con el mismo nombre de una variable definida anteriormente.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_actualización_de_variables">Actualización de variables</h3>
<div class="paragraph">
<p>Una de las formas más comunes de asignación múltiple es la actualización, donde el nuevo valor de la variable depende del anterior.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = x + 1
8</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto significa “tome el valor actual de <code>x</code>, súmele uno, y después actualice <code>x</code> con el nuevo valor.”</p>
</div>
<div class="paragraph">
<p>Si intenta actualizar una variable que no existe obtendrá un error, puesto que Julia evalúa la expresión del lado derecho antes de asignar un valor a <code>x</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; y = y + 1
ERROR: UndefVarError: y not defined</code></pre>
</div>
</div>
<div class="paragraph">
<p>Antes de actualizar una variable tiene que inicializarla, usualmente con una asignación simple:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; y = 0
0
julia&gt; y = y + 1
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Actualizar una variable sumándole 1 de denomina un <em>incremento</em>; y restándole 1 de llama un <em>decremento</em>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_la_sentencia_while">La Sentencia <code>while</code></h3>
<div class="paragraph">
<p>Las computadoras se usan a menudo para automatizar tareas repetitivas. Realizar repetidamente tareas idénticas o similares sin cometer errores es algo que las computadoras hacen bien y que los seres humanos hacemos limitadamente. La ejecución repetida de un conjunto de sentencias se llama <em>iteración</em>.
</p>
</div>
<div class="paragraph">
<p>Ya hemos visto dos funciones, <code>cuenta regresiva</code> y <code>printn</code>, que iteran usando recursividad. Por ser la iteración tan común, Julia proporciona varias características que la hacen más fácil. Una es la sentencia <code>for</code> que vimos en <a href="#simple_repetition">Repetición Simple</a>, a la cual volveremos más adelante.
</p>
</div>
<div class="paragraph">
<p>Otra característica es la <em>sentencia</em> <code>while</code>. Aquí hay una versión de <code>cuentaregresiva</code> que muestra el uso de la sentencia <code>while</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function cuentaregresiva(n)
    while n &gt; 0
        print(n, " ")
        n = n - 1
    end
    println("¡Despegue!")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Casi podría leer la sentencia while como si fuera Español. La función anterior significa: “Mientras <code>n</code> sea mayor que 0, continúe mostrando el valor de <code>n</code> y luego reduciendo el valor de <code>n</code> en 1. Cuando llegue a 0, muestre la palabra ¡Despegue!“
</p>
</div>
<div class="paragraph">
<p>Más formalmente, el flujo de ejecución de una sentencia <code>while</code> es el siguiente:
</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se determina si la condición es verdadera o falsa.</p>
</li>
<li>
<p>Si es falsa, se sale de la sentencia while y continúa la ejecución con la siguiente sentencia.</p>
</li>
<li>
<p>Si es verdadera, ejecuta cada una de las sentencias en el cuerpo y regresa al paso 1.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Este tipo de flujo de llama bucle porque el tercer paso vuelve a la parte superior.
</p>
</div>
<div class="paragraph">
<p>El cuerpo del bucle debería cambiar el valor de una o más variables de manera que, en algún momento, la condición sea falsa y el bucle termine. En caso contrario, el bucle se repetirá indefinidamente, lo cual se llama <em>bucle infinito</em>. Una interminable fuente de diversión para los informáticos es la observación de que las instrucciones del champú “Enjabone, enjuague, repita”, son un bucle infinito.
</p>
</div>
<div class="paragraph">
<p>En el caso de <code>cuentaregresiva</code>, podemos probar que el bucle termina: si <code>n</code> es cero o negativo, el ciclo no se produce. En otro caso, el valor de <code>n</code> se hace más pequeño cada vez que pasa por el bucle, así en cierto momento llegaremos a 0.</p>
</div>
<div class="paragraph">
<p>En otros casos no es tan fácil decirlo. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function seq(n)
    while n != 1
        println(n)
        if n % 2 == 0        # n is par
            n = n / 2
        else                 # n is impar
            n = n*3 + 1
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La condición de este bucle es <code>n != 1</code>, de manera que el bucle continuará hasta que <code>n</code> sea 1, que hará que la condición sea falsa.</p>
</div>
<div class="paragraph">
<p>Cada vez que pasa por el bucle, el programa muestra como salida el valor de <code>n</code> y luego comprueba si es par o impar. Si es par, el valor de <code>n</code> se divide por dos. Si es impar, el valor de <code>n</code> se sustituye por <code>n*3 + 1</code>. Por ejemplo, si el argumento pasado a la función seq es 3, los valores resultantes <code>n</code> son 3, 10, 5, 16, 8, 4, 2, 1.</p>
</div>
<div class="paragraph">
<p>Puesto que n a veces aumenta y a veces disminuye, no hay una prueba obvia de que <code>n</code> alcanzará alguna vez el valor 1, o de que el programa vaya a terminar. Para algunos valores particulares de <code>n</code>, podemos probar que sí termina. Por ejemplo, si el valor de inicio es una potencia de dos, entonces el valor de <code>n</code> será par cada vez que se pasa por el bucle, hasta que llegue a 1. El ejemplo anterior produce dicha secuencia si se inicia con 16.</p>
</div>
<div class="paragraph">
<p>Lo díficil es preguntarnos si se puede probar que este programa termina para todos los valores positivos de <code>n</code>. Hasta ahora, nadie ha sido capaz de probar que lo hace o ¡que no lo hace! (Vea <a href="https://es.wikipedia.org/wiki/Conjetura_de_Collatz." class="bare">https://es.wikipedia.org/wiki/Conjetura_de_Collatz.</a>)
</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_7_1">Ejercicio 7-1</h4>
<div class="paragraph">
<p>Reescribe la función <code>printn</code> de <a href="#recursion">[recursion]</a> utilizando iteración en vez de recursión.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_break"><code>break</code></h3>
<div class="paragraph">
<p>A veces no se sabe que un ciclo debe terminar hasta que se llega al cuerpo. En ese caso, se puede usar la <em>sentencia break</em> para salir del bucle.
</p>
</div>
<div class="paragraph">
<p>Por ejemplo, suponga que se desea recibir entradas del usuario hasta que este escriba "listo". Podríamos escribir:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">while true
    print("&gt; ")
    linea = readline()
    if line == "listo"
        break
    end
    println(linea)
end
println("¡Listo!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>La condición del bucle es <code>true</code>, que siempre es verdadero, por lo que el bucle se ejecuta hasta que llega a la sentencia break.</p>
</div>
<div class="paragraph">
<p>En cada iteración, se le pide al usuario (con el símbolo "&gt; ") una entrada. Si el usuario escribe <code>listo</code>, la sentencia break sale del bucle. De lo contrario, el programa repite lo que escriba el usuario y vuelve a la parte superior del bucle. A continuación se muestra cómo funciona este programa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&gt; no listo
no listo
&gt; listo
¡Listo!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta forma de escribir bucles while es común porque permite verificar la condición en cualquier parte del bucle (no solo en la parte superior) y puede expresar la condición de término de manera afirmativa ("detenerse cuando esto suceda"), en vez de negativamente ("continuar hasta que esto suceda").</p>
</div>
</div>
<div class="sect2">
<h3 id="_continue"><code>continue</code></h3>
<div class="paragraph">
<p>La sentencia break permite terminar el bucle. Cuando aparece una <em>sentencia continue</em> dentro de un bucle, se regresa al comienzo del bucle, ignorando todos las sentencias que quedan en la iteración actual del bucle e inicia la siguiente iteración. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for i in 1:10
    if i % 3 == 0
        continue
    end
    print(i, " ")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1 2 4 5 7 8 10</pre>
</div>
</div>
<div class="paragraph">
<p>Si <code>i</code> es divisible por 3, la sentencia continue detiene la iteración actual y comienza la siguiente iteración. Solo se imprimen los números en el rango de 1 a 10 no divisibles por 3.</p>
</div>
</div>
<div class="sect2">
<h3 id="square_roots">Raíces Cuadradas</h3>
<div class="paragraph">
<p>Los bucles son comúnmente utilizados en programas que calculan resultados numéricos, que comienzan con una respuesta aproximada, y que es iterativamente mejorada.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, una forma de calcular raíces cuadradas es el método de Newton. Suponga que desea conocer la raíz cuadrada de \(a\). Si comienza con casi cualquier estimación \(x\), puede calcular una mejor aproximación con la siguiente fórmula:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{y = \frac{1}{2}\left(x + \frac{a}{x}\right)}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Por ejemplo, si \(a\) es 4 y \(x\) es 3:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = 4
4
julia&gt; x = 3
3
julia&gt; y = (x + a/x) / 2
2.1666666666666665</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado está más cerca de la respuesta correcta (\(\sqrt 4 = 2\)). Si repetimos el proceso con la nueva estimación, se acerca aún más:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = y
2.1666666666666665
julia&gt; y = (x + a/x) / 2
2.0064102564102564</code></pre>
</div>
</div>
<div class="paragraph">
<p>Después de algunas actualizaciones, la estimación es casi exacta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = y
2.0064102564102564
julia&gt; y = (x + a/x) / 2
2.0000102400262145
julia&gt; x = y
2.0000102400262145
julia&gt; y = (x + a/x) / 2
2.0000000000262146</code></pre>
</div>
</div>
<div class="paragraph">
<p>En general, no sabemos de antemano cuántos pasos se necesitan para llegar a la respuesta correcta, pero sabemos que hemos llegado a ella cuando la estimación deja de cambiar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = y
2.0000000000262146
julia&gt; y = (x + a/x) / 2
2.0
julia&gt; x = y
2.0
julia&gt; y = (x + a/x) / 2
2.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando <code>y == x</code>, podemos detenernos. A continuación se muestra un ciclo que comienza con una estimación inicial, <code>x</code>, la cual mejora hasta que deja de cambiar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">while true
    println(x)
    y = (x + a/x) / 2
    if y == x
        break
    end
    x = y
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para la mayoría de los valores de a esto funciona bien, aunque en general no se recomienda probar igualdad entre números de punto flotante. Los números de punto flotante son aproximadamente correctos: la mayoría de los números racionales, como \(\frac{1}{3}\), e irracionales, como \(\sqrt 2\), no pueden ser representados exactamente con un <code>Float64</code>.</p>
</div>
<div class="paragraph">
<p>En lugar de verificar si <code>x</code> e <code>y</code> son exactamente iguales, es más seguro usar la función integrada <code>abs</code> para calcular el valor absoluto o la magnitud de la diferencia entre ellos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if abs(y-x) &lt; ε
    break
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Donde <code>ε</code> (<strong><code>\varepsilon TAB</code></strong>) toma un valor como <code>0.0000001</code>, y representa el error que estamos dispuestos a aceptar entre la estimación y el valor real.</p>
</div>
</div>
<div class="sect2">
<h3 id="_algoritmos">Algoritmos</h3>
<div class="paragraph">
<p>El método de Newton es un ejemplo de un <em>algoritmo</em>: es un proceso mecánico que permite resolver una categoría de problemas (en este caso, el cálculo de raíces cuadradas).
</p>
</div>
<div class="paragraph">
<p>Para comprender qué es un algoritmo, podría ayudar empezar con algo que no es un algoritmo. Cuando aprendiste a multiplicar números de un solo dígito, probablemente memorizaste la tabla de multiplicar. En efecto, memorizaste 100 soluciones específicas. Ese tipo de conocimiento no es un algoritmo.</p>
</div>
<div class="paragraph">
<p>Pero si fueras "flojo", podrías haber aprendido algunos trucos. Por ejemplo, para encontrar el producto de \(n\) y 9, puedes escribir \(n-1\) como el primer dígito y \(10-n\) como el segundo dígito. Este truco es una solución general para multiplicar cualquier número de un solo dígito por 9. ¡Este es un algoritmo!</p>
</div>
<div class="paragraph">
<p>Del mismo modo, las técnicas que aprendió para la suma con “llevamos tanto”, la resta con “pedimos prestado tanto”, y la división “larga o con galera o de casita” son todas ellas algoritmos. Una de las características de los algoritmos es que no requieren inteligencia para realizarlos. Son procesos mecánicos donde cada paso se sigue de acuerdo com un conjunto simple de reglas.</p>
</div>
<div class="paragraph">
<p>Ejecutar algoritmos es aburrido, pero diseñarlos es interesante, intelectualmente desafiante y son una parte central de la informática.</p>
</div>
<div class="paragraph">
<p>Algunas de las cosas que las personas hacen naturalmente, sin dificultad o conscientemente, son las más difíciles de expresar en algoritmos. Comprender el lenguaje natural es un buen ejemplo. Todos lo hacemos, pero hasta ahora nadie ha podido explicar <em>cómo</em> lo hacemos, al menos no en forma de algoritmo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_6">Depuración</h3>
<div class="paragraph">
<p>A medida que comienzas a escribir programas más extensos, es posible que pases más tiempo depurando. Más código significa más posibilidades de cometer un error y más lugares en dónde se pueden esconder los errores.
</p>
</div>
<div class="paragraph">
<p>Una forma de reducir el tiempo de depuración es "depurar por bisección". Por ejemplo, si hay 100 líneas en su programa y las revisas una a la vez, serían 100 revisiones.
</p>
</div>
<div class="paragraph">
<p>Es mejor tratar de dividir el problema en dos. Busque en la mitad del programa, o cerca, un valor intermedio que pueda verificar. Agregue una sentencia de impresión (o algo que permita verificar) y ejecute el programa.
</p>
</div>
<div class="paragraph">
<p>Si esta verificación es incorrecta, debe haber un problema en la primera mitad del programa. Si es correcta, el problema está en la segunda mitad.</p>
</div>
<div class="paragraph">
<p>Cada vez que realiza una verificación como esta, reduce a la mitad el número de líneas que debe revisar. Después de seis pasos (que es mucho menos que 100), se reduciría a una o dos líneas de código, al menos en teoría.</p>
</div>
<div class="paragraph">
<p>En la práctica, no siempre se conoce dónde está la "mitad del programa", y no siempre es posible verificarlo. No tiene sentido contar líneas y encontrar el punto medio exacto. En su lugar, piense en los lugares del programa donde puede haber errores y en los lugares donde es fácil verificar. Luego, elija un lugar en donde usted crea que las posibilidades de encontrar un error antes o después de esta verificación son más o menos las mismas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_6">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">asignación múltiple</dt>
<dd>
<p>Asignar un nuevo valor a una variable que ya existe.
</p>
</dd>
<dt class="hdlist1">actualización</dt>
<dd>
<p>Asignación donde el nuevo valor de la variable depende del antiguo.
</p>
</dd>
<dt class="hdlist1">inicialización</dt>
<dd>
<p>Asignación que le da un valor inicial a una variable que será actualizada.
An assignment that gives an initial value to a variable that will be updated.
</p>
</dd>
<dt class="hdlist1">incremento</dt>
<dd>
<p>Actualización que incrementa el valor de la variable (usualmente en 1)
</p>
</dd>
<dt class="hdlist1">decremento</dt>
<dd>
<p>Actualización que disminuye el valor de la variable.
</p>
</dd>
<dt class="hdlist1">iteración</dt>
<dd>
<p>Ejecución repetida de un conjunto de sentencias, usando una función recursiva o un bucle.
</p>
</dd>
<dt class="hdlist1">sentencia while</dt>
<dd>
<p>Sentencia que permite iteraciones controladas por una condición.
</p>
</dd>
<dt class="hdlist1">sentencia break</dt>
<dd>
<p>Sentencia que permite salir de un bucle.
</p>
</dd>
<dt class="hdlist1">sentencia continue</dt>
<dd>
<p>Sentencia localizada dentro de un bucle, que obliga a iniciar una nueva iteración desde el inicio del bucle.
</p>
</dd>
<dt class="hdlist1">bucle infinito</dt>
<dd>
<p>Un bucle cuya condición de término no es satisfecha.
</p>
</dd>
<dt class="hdlist1">algoritmo</dt>
<dd>
<p>Proceso general para resolver una categoría de problemas.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_8">Ejercicios</h3>
<div class="sect3">
<h4 id="ex07-1">Ejercicio 7-2</h4>
<div class="paragraph">
<p>Copie el bucle de <a href="#square_roots">Raíces Cuadradas</a> e insértelo en una función llamada <code>miraiz</code>, que tome <code>a</code> como parámetro, elija un valor razonable de <code>x</code> y devuelva una estimación de la raíz cuadrada de <code>a</code>.
</p>
</div>
<div class="paragraph">
<p>Para probarla, escriba una función llamada <code>probarraiz</code> que imprima una tabla como esta:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a   mysqrt             sqrt               diff
-   ------             ----               ----
1.0 1.0                1.0                0.0
2.0 1.414213562373095  1.4142135623730951 2.220446049250313e-16
3.0 1.7320508075688772 1.7320508075688772 0.0
4.0 2.0                2.0                0.0
5.0 2.23606797749979   2.23606797749979   0.0
6.0 2.449489742783178  2.449489742783178  0.0
7.0 2.6457513110645907 2.6457513110645907 0.0
8.0 2.82842712474619   2.8284271247461903 4.440892098500626e-16
9.0 3.0                3.0                0.0</pre>
</div>
</div>
<div class="paragraph">
<p>La primera columna es un número, <code>a</code>; la segunda columna es la raíz cuadrada de <code>a</code> calculada con <code>miraiz</code>; la tercera columna es la raíz cuadrada calculada con la función integrada <code>sqrt</code>; la cuarta columna es el valor absoluto de la diferencia entre las dos estimaciones.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex07-2">Exercise 7-3</h4>
<div class="paragraph">
<p>La función integrada <code>Meta.parse</code> toma una cadena y la transforma en una expresión. Esta expresión se puede evaluar en Julia con la función <code>Core.eval</code>. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; expr = Meta.parse("1+2*3")
:(1 + 2 * 3)
julia&gt; eval(expr)
7
julia&gt; expr = Meta.parse("sqrt(π)")
:(sqrt(π))
julia&gt; eval(expr)
1.7724538509055159</code></pre>
</div>
</div>
<div class="paragraph">
<p>Escriba una función llamada <code>evalbucle</code> que iterativamente solicite una entrada al usuario, tome la entrada resultante y la evalúe usando <code>eval</code>, pasa posteriormente imprimir el resultado. Debe continuar hasta que el usuario ingrese <code>listo</code>, y luego devolver el valor de la última expresión que evaluó.
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex07-3">Exercise 7-4</h4>
<div class="paragraph">
<p>El matemático Srinivasa Ramanujan encontró una serie infinita que puede usarse para generar una aproximación numérica de \(\frac{1}{\pi}\):</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{\frac{1}{\pi}=\frac{2\sqrt2}{9801}\sum_{k=0}^\infty\frac{(4k)!(1103+26390k)}{(k!)^4 396^{4k}}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Escriba una función llamada <code>estimarpi</code> que utilice esta fórmula para calcular y devolver una estimación de π. Debe usar un ciclo while para calcular los términos de la suma hasta que el último término sea menor que <code>1e-15</code> (que es la notación de Julia para \(10^{-15}\)). Puede verificar el resultado comparándolo con <code>π</code>.
</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap08">8. Cadenas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Las cadenas son diferentes de los números enteros, flotantes y booleanos. Una cadena es una <em>secuencia</em>, es decir, es una colección ordenada de valores. En este capítulo veremos cómo acceder a los caracteres que forman una cadena, y conoceremos algunas funciones integradas en Julia relacionadas con cadenas.
</p>
</div>
<div class="sect2">
<h3 id="characters">Caracteres</h3>
<div class="paragraph">
<p>Los hispanohablantes están familiarizados con algunos caracteres, tales como las letras del alfabeto (A, B, C, &#8230;&#8203;), los números y los signos de puntuación comunes. Estos caracteres están estandarizados en el código <em>ASCII</em> (Código Estándar Estadounidense para el Intercambio de Información).
</p>
</div>
<div class="paragraph">
<p>Por supuesto hay muchos otros caracteres utilizados en idiomas distintos del español que no están en el código <em>ASCII</em>, tales como aquellos usados en los idiomas griego, árabe, chino, hebreo, hindi, japonés y coreano.</p>
</div>
<div class="paragraph">
<p>Definir qué es un carácter es altamente complejo. La <em>norma Unicode</em> permite abordar este problema, y se considera como el estándar definitivo para ello. Esta norma funciona asignando un número único para cada carácter a nivel global.
</p>
</div>
<div class="paragraph">
<p>Un valor <code>Char</code> representa un único carácter y está entre comillas simples:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
julia&gt; '🍌'
'🍌': Unicode U+01f34c (category So: Symbol, other)
julia&gt; typeof('x')
Char</code></pre>
</div>
</div>
<div class="paragraph">
<p>Incluso los emojis son parte del estándar Unicode. (<strong><code>\:banana: TAB</code></strong>)
</p>
</div>
</div>
<div class="sect2">
<h3 id="_una_cadena_es_una_secuencia">Una Cadena es una Secuencia</h3>
<div class="paragraph">
<p>Una cadena es una secuencia de caracteres. Se puede acceder a un carácter con el operador corchete:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fruta = "banana"
"banana"
julia&gt; letra = fruta[1]
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>La segunda sentencia selecciona el carácter número 1 de <code>fruta</code> y la asigna a la variable <code>letra</code>.</p>
</div>
<div class="paragraph">
<p>La expresión entre corchetes se llama <em>indice</em>. El índice indica el carácter de la secuencia a obtener (de ahí el nombre).
</p>
</div>
<div class="paragraph">
<p>La indexación en Julia es base 1, es decir, el primer elemento de cualquier objeto indexado con enteros está en el índice 1, y el último en el índice <code>end</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fruta[end]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como índice se pueden usar expresiones que contengan variables y operadores:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; i = 1
1
julia&gt; fruta[i+1]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia&gt; fruta[end-1]
'n': ASCII/Unicode U+006e (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pero el valor del índice tiene que ser un número entero. De lo contrario se obtiene:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; letra = fruta[1.5]
ERROR: MethodError: no method matching getindex(::String, ::Float64)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_length"><code>length</code></h3>
<div class="paragraph">
<p><code>length</code> es una función integrada que devuelve el número de caracteres de una cadena:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; frutas = "🍌 🍎 🍐"
"🍌 🍎 🍐"
julia&gt; len = length(frutas)
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para obtener la última letra de una cadena, puede sentirse tentado a probar algo como esto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; last = frutas[len]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pero con esto no se obtiene el resultado esperado.</p>
</div>
<div class="paragraph">
<p>Las cadenas se codifican usando <em>codificación UTF-8</em>. UTF-8 es una codificación de longitud variable, lo que significa que no todos los caracteres están codificados con el mismo número de bytes.
</p>
</div>
<div class="paragraph">
<p>La función <code>sizeof</code> devuelve el número de bytes de una cadena:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; sizeof("🍌")
4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dado que un emoji está codificado en 4 bytes y la indexación de cadenas está basada en bytes, el quinto elemento de <code>frutas</code> es un <code>ESPACIO</code>.
</p>
</div>
<div class="paragraph">
<p>Esto significa que no todos los índices de byte de una cadena UTF-8 son necesariamente índices válidos para un carácter. Si en una cadena se indexa con un índice de bytes no válido, se genera un error:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; frutas[2]
ERROR: StringIndexError("🍌 🍎 🍐", 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el caso de <code>frutas</code>, el carácter <code>🍌</code> es un carácter de cuatro bytes, por lo que los índices 2, 3 y 4 no son válidos y el índice del siguiente carácter es 5; el siguiente índice válido se puede calcular con <code>nextind(frutas, 1)</code>, el subsiguiente con <code>nextind(frutas,5)</code> y así sucesivamente.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_recorrido">Recorrido</h3>
<div class="paragraph">
<p>Muchos cálculos implican procesar una cadena carácter por carácter. A menudo empiezan por el principio, seleccionan cada carácter por turno, hacen algo con él y continúan hasta el final. Este patrón de proceso se llama <em>recorrido</em>. Una forma de escribir un recorrido es con una sentencia while:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">indice = firstindex(frutas)
while indice &lt;= sizeof(frutas)
    letra = frutas[indice]
    println(letra)
    global indice = nextind(frutas, indice)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este bucle recorre la cadena y muestra cada letra en una línea distinta. La condición del bucle es <code>index &lt;= sizeof(fruta)</code>, de modo que cuando el indice es mayor al número de bytes en la cadena, la condición es <code>falsa</code>, y no se ejecuta el cuerpo del bucle.</p>
</div>
<div class="paragraph">
<p>La función <code>firstindex</code> devuelve el primer índice de bytes válido. La palabra reservada <code>global</code> antes de <code>indice</code> indica que queremos reasignar la variable <code>indice</code> definida en <code>Main</code> (ver <a href="#variables_globales">[variables_globales]</a>).
</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_8_1">Ejercicio 8-1</h4>
<div class="paragraph">
<p>Escriba una función que tome una cadena como argumento y que muestre las letras desde la última a la primera, una por línea.</p>
</div>
<div class="paragraph">
<p>Otra forma de escribir un recorrido es con un bucle <code>for</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for letra in frutas
    println(letra)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cada vez que recorremos el bucle, se asigna a la variable <code>letra</code> el siguiente carácter de la cadena. El bucle continúa hasta que no quedan más caracteres.</p>
</div>
<div class="paragraph">
<p>El ejemplo siguiente muestra cómo usar la concatenación (multiplicación de cadenas) y un bucle for para generar una serie abecedaria (es decir, una serie con elementos en orden alfabético). Por ejemplo, en el libro de Robert McCloskey <em>Make Way for Ducklings</em>, los nombres de los patitos son Jack, Kack, Lack, Mack, Nack, Ouack, Pack, y Quack. Este bucle muestra esos nombres en orden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">prefijos = "JKLMNOPQ"
sufijo = "ack"

for letra in prefijos
    println(letra * sufijo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack</pre>
</div>
</div>
<div class="paragraph">
<p>Por supuesto, esto no es del todo correcto, porque “Ouack” y “Quack” no están correctamente escritos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicio_8_2">Ejercicio 8-2</h4>
<div class="paragraph">
<p>Modifique este programa para solucionar este error.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_porciones_de_cadenas">Porciones de Cadenas</h3>
<div class="paragraph">
<p>A la subcadena de una cadena se le llama <em>porción</em>. La selección de una porción es similar a la selección de un carácter:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; str = "Julio Cesar";

julia&gt; str[1:5]
"Julio"</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador <code>[n:m]</code> devuelve la parte de la cadena desde el <code>n</code>-ésimo byte hasta el <code>m</code>-ésimo. Por lo tanto, se siguen las mismas reglas que para la indexación simple.
</p>
</div>
<div class="paragraph">
<p>La palabra reservada <code>end</code> se puede usar para indicar al último byte de la cadena:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; str[7:end]
"Cesar"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si el primer índice es mayor que el segundo, el resultado es una <em>cadena vacía</em>, representada por dos comillas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; str[8:7]
""</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una cadena vacía no contiene caracteres y tiene una longitud de 0, pero aparte de eso es igual a cualquier otra cadena.</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_8_3">Ejercicio 8-3</h4>
<div class="paragraph">
<p>Continuando este ejemplo, ¿qué crees que significa <code>str[:]</code>? Prueba y verás.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_las_cadenas_son_inmutables">Las Cadenas son Inmutables</h3>
<div class="paragraph">
<p>Es tentador usar el operador <code>[]</code> en el lado izquierdo de una asignación, con la intención de cambiar un carácter en una cadena. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; saludo = "¡Hola, mundo!"
"¡Hola, mundo!"
julia&gt; saludo[3] = 'J'
ERROR: MethodError: no method matching setindex!(::String, ::Char, ::Int64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nota del traductor: De acuerdo con la codificación de caracteres en utf-8 ó latin-1, el carácter de exclamación ‘¡’, en la variable saludo ocupa dos posiciones, de ahí que la letra ‘H’ esté localizada en el índice 3.</p>
</div>
<div class="paragraph">
<p>La razón del error es que las cadenas son <em>inmutables</em>, lo que significa que no se puede cambiar una cadena existente. Lo más que puedes hacer es crear una nueva cadena que sea una variación de la original:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; saludo = "¡J" * saludo[4:end]
"¡Jola, mundo!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este ejemplo concatena la apertura del signo de exclamación y una nueva primera letra a una porción de saludo. Esta operación no tiene efecto sobre la cadena original.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interpolación_de_cadenas">Interpolación de Cadenas</h3>
<div class="paragraph">
<p>Construir cadenas usando concatenación puede ser un poco engorroso. Para disminuir la necesidad de las llamadas a <code>string</code> o multiplicaciones repetidas, Julia permite la <em>interpolación de cadenas</em> usando <code>$</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; saludo = "¡Hola"
"¡Hola"
julia&gt; paraquien = "mundo"
"mundo"
julia&gt; "$saludo, $(paraquien)!"
"¡Hola, mundo!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto es más entendible y conveniente que la concatenación de cadenas: <code>saludo * ", " * paraquien * "!"</code></p>
</div>
<div class="paragraph">
<p>La expresión inmediatamente siguiente a <code>$</code> se toma como la expresión cuyo valor se va a interpolar en la cadena. Por lo tanto, puedes interpolar cualquier expresión en una cadena usando paréntesis:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; "1 + 2 = $(1 + 2)"
"1 + 2 = 3"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="searching">Búsqueda</h3>
<div class="paragraph">
<p>¿Qué hace la siguiente función?
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function busqueda(palabra, letra)
    indice = primerindice(palabra)
    while indice &lt;= sizeof(palabra)
        if palabra[indice] == letra
            return indice
        end
        indice = nextind(palabra, indice)
    end
    -1
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>En cierto sentido, la funcion busqueda es lo contrario del operador <code>[]</code>. En lugar de tomar un índice y extraer el carácter correspondiente, toma un carácter y encuentra el índice donde aparece el carácter. Si el carácter no se encuentra, la función devuelve -1.</p>
</div>
<div class="paragraph">
<p>Este es el primer ejemplo que hemos visto de una sentencia return dentro de un bucle. Si <code>palabra[indice] == letra</code>, la función devuelve inmediatamente el índice, escapando del bucle prematuramente.</p>
</div>
<div class="paragraph">
<p>Si el carácter no aparece en la cadena, entonces el programa sale del bucle normalmente y devuelve -1.</p>
</div>
<div class="paragraph">
<p>Este patrón de computación se llama a veces un recorrido <em>eureka</em> porque tan pronto como encontramos lo que buscamos, podemos gritar “¡Eureka! ” y dejar de buscar.
</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_8_4">Ejercicio 8-4</h4>
<div class="paragraph">
<p>Modifique la función <code>busqueda</code> para que tenga un tercer parámetro: el índice de <code>palabra</code> donde debería comenzar a buscar.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="looping_and_counting">Iterando y contando</h3>
<div class="paragraph">
<p>El siguiente programa cuenta el número de veces que aparece la letra <code>a</code> en una cadena:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">palabra = "banana"
contador = 0
for letra in palabra
    if letra == 'a'
        global contador = contador + 1
    end
end
println(contador)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este programa es otro ejemplo del patrón de computación llamado <em>conteo</em>.  La variable <code>contador</code> se inicializa en 0 y se incrementa cada vez que encuentra la letra <code>a</code>. Cuando termina el bucle, <code>contador</code> contiene el resultado (el número total de letras <code>a</code>).
</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_8_5">Ejercicio 8-5</h4>
<div class="paragraph">
<p>Coloque este código en una función llamada <code>conteo</code>, y generalícelo de tal manera que tome como argumentos una cadena y una letra.</p>
</div>
<div class="paragraph">
<p>Luego, vuelva a escribir la función para que, en vez de revisar toda la cadena, utilice la función <code>busqueda</code> de tres parámetros de la sección anterior.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_librería_con_cadenas">Librería con cadenas</h3>
<div class="paragraph">
<p>Julia tiene funciones integradas que realizan una variedad de operaciones útiles en cadenas. Por ejemplo, la función <code>uppercase</code> toma una cadena y devuelve una nueva cadena con todas las letras mayúsculas.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; uppercase("¡Hola, mundo!")
"¡HOLA, MUNDO!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Existe una función llamada <code>findfirst</code> que es notablemente similar a la función <code>busqueda</code> que escribimos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; findfirst("a", "banana")
2:2</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>findfirst</code> es más general que nuestra función; puede encontrar subcadenas, no solo caracteres:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; findfirst("na", "banana")
3:4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por defecto, <code>findfirst</code> comienza la búsqueda al comienzo de la cadena, pero la función <code>findnext</code> toma un tercer argumento: el <code>indice</code> donde debería comenzar:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; findnext("na", "banana", 4)
5:6</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_el_operador">El operador <code>∈</code></h3>
<div class="paragraph">
<p>El operador <code>∈</code> (<strong><code>\in TAB</code></strong>) es un operador booleano que toma un carácter y una cadena, y devuelve <code>true</code> si el primero aparece en el segundo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 'a' ∈ "banana"    # 'a' en "banana"
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por ejemplo, la siguiente función imprime todas las letras de palabra1 que también aparecen en palabra2:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function ambas(palabra1, palabra2)
    for letra in palabra1
        if letra ∈ palabra2
            print(letra, " ")
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una  buena elección de nombres de variables permite que Julia se pueda leer como el español. Este bucle puede leerse como: "para (cada) letra en (la primera) palabra, si (la) letra es un elemento de (la segunda) palabra, imprima (la) letra".</p>
</div>
<div class="paragraph">
<p>Esto es lo que se obtiene si se compara <code>"manzanas"</code> y <code>"naranjas"</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ambas("manzanas", "naranjas")
a n a n a s</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_comparación_de_cadenas">Comparación de Cadenas</h3>
<div class="paragraph">
<p>Los operadores de comparación trabajan sobre cadenas. Para ver si dos cadenas son iguales:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">palabra = "Piña"
if palabra == "banana"
    println("¡Tenemos bananas!")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otras operaciones de comparación son útiles para ordenar alfabeticamente palabras:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">if palabra &lt; "banana"
    println("Su palabra, $palabra, va antes de banana.")
elseif word &gt; "banana"
    println("Su palabra, $palabra, va antes de banana.")
else
    println("¡Tenemos bananas!")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Julia no maneja las letras mayúsculas y minúsculas como nosotros. Todas las letras mayúsculas van antes de las letras minúsculas. Por lo tanto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia chap08" data-lang="julia chap08">"Su palabra, Piña, va antes de banana."</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Una forma común de abordar este problema es convertir las cadenas a un formato estándar, como por ejemplo a minúsculas, antes de realizar la comparación.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="deb08">Depuración</h3>
<div class="paragraph">
<p>Cuando se usan índices para recorrer los valores en una secuencia, es difícil acceder al principio y al final del recorrido. Aquí hay una función que compara dos palabras y devuelve <code>true</code> si una de las palabras es el reverso de la otra, pero contiene dos errores:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function esreverso(palabra1, palabra2)
    if length(palabra1) != length(palabra2)
        return false
    end
    i = firstindex(palabra1)
    j = lastindex(palabra2)
    while j &gt;= 0
        j = prevind(palabra2, j)
        if palabra1[i] != palabra2[j]
            return false
        end
        i = nextind(palabra1, i)
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La primera sentencia <code>if</code> verifica si las palabras tienen la misma longitud. Si no, se devuelve <code>false</code> inmediatamente. De lo contrario, para el resto de la función, podemos suponer que las palabras tienen la misma longitud. Este es un ejemplo del patrón guardián.</p>
</div>
<div class="paragraph">
<p><code>i</code> y <code>j</code> son índices: <code>i</code> recorre <code>palabra1</code> de derecha a izquierda mientras que <code>j</code> recorre <code>palabra2</code> de izquierda a derecha. Si dos letras no coinciden, se devuelve <code>false</code> inmediatamente. Si el ciclo termina y todas las letras coinciden, se devuelve <code>true</code>.</p>
</div>
<div class="paragraph">
<p>La función <code>lastindex</code> devuelve el último índice de bytes válido de una cadena y <code>prevind</code> el índice válido anterior a un carácter.</p>
</div>
<div class="paragraph">
<p>Si probamos esta función con las palabras "amor" y "roma", esperamos el valor de retorno <code>true</code>, pero obtenemos <code>false</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; esreverso("amor", "roma")
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para depurar este tipo de error, primeramente imprimamos los valores de los índices:</p>
</div>
<div class="paragraph">
<p>Ahora, al ejecutar el programa, se obtiene más información:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; esreverso("amor", "roma")
i = 1
j = 3
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>En la primera iteración del bucle, el valor de <code>j</code> es 3, pero tendría que ser 4. Esto se puede solucionar trasladando la línea <code>j = prevind (palabra2, j)</code> al final del ciclo <code>while</code>.</p>
</div>
<div class="paragraph">
<p>Si se soluciona ese error y se ejecuta el programa nuevamente, se obtiene:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; esreverso("amor", "roma")
i = 1
j = 4
i = 2
j = 3
i = 3
j = 2
i = 4
j = 1
i = 5
j = 0
ERROR: BoundsError: attempt to access String
  at index [5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta vez se ha producido un <code>BoundsError</code>. El valor de <code>i</code> es 5, que está fuera del rango de la cadena <code>"amor"</code>.
</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_8_6">Ejercicio 8-6</h4>
<div class="paragraph">
<p>Ejecute el programa en papel, cambiando los valores de <code>i</code> y <code>j</code> durante cada iteración. Encuentre y arregle el segundo error en esta función.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_7">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">secuencia</dt>
<dd>
<p>Una colección ordenada de valores donde cada valor se identifica mediante un índice entero.
</p>
</dd>
<dt class="hdlist1">código ASCII</dt>
<dd>
<p>Código de caracteres estándar para el intercambio de información.
</p>
</dd>
<dt class="hdlist1">norma Unicode</dt>
<dd>
<p>Un estándar en la industria informática para la codificación, representación y manejo consistentes de texto en la mayoría de los sistemas de escritura del mundo.
</p>
</dd>
<dt class="hdlist1">índice</dt>
<dd>
<p>Un valor entero usado para seleccionar un miembro de un conjunto ordenado, como puede ser un carácter de una cadena. En Julia los índices comienzan en 1.
</p>
</dd>
<dt class="hdlist1">codificación UTF-8</dt>
<dd>
<p>Una codificación de caracteres de longitud variable capaz de codificar todos los 1112064 puntos de código válidos en Unicode utilizando de uno a cuatro bytes de 8 bits.
</p>
</dd>
<dt class="hdlist1">recorrer</dt>
<dd>
<p>Iterar sobre los elementos de un conjunto, realizando una operación similar en cada uno de ellos.
</p>
</dd>
<dt class="hdlist1">porción</dt>
<dd>
<p>Una parte de una cadena especificada mediante un rango de índices.
</p>
</dd>
<dt class="hdlist1">cadena vacía</dt>
<dd>
<p>Una cadena sin caracteres y longitud 0, representada por dos comillas.
</p>
</dd>
<dt class="hdlist1">immutable</dt>
<dd>
<p>La propiedad de una secuencia que hace que a sus elementos no se les pueda asignar nuevos valores.
</p>
</dd>
<dt class="hdlist1">interpolación de cadenas</dt>
<dd>
<p>El proceso de evaluar una cadena que contiene uno o más marcadores de posición, produciendo un resultado en el que los marcadores de posición se reemplazan con sus valores correspondientes.
</p>
</dd>
<dt class="hdlist1">búsqueda</dt>
<dd>
<p>Un patrón de recorrido que se detiene cuando encuentra lo que está buscando.
</p>
</dd>
<dt class="hdlist1">contador</dt>
<dd>
<p>Una variable utilizada para contar algo, generalmente inicializada en cero y luego incrementada.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_9">Ejercicios</h3>
<div class="sect3">
<h4 id="ex08-1">Ejercicio 8-7</h4>
<div class="paragraph">
<p>Lea la documentación de las funciones relacionadas con cadenas en <a href="https://docs.julialang.org/en/v1/manual/strings/" class="bare">https://docs.julialang.org/en/v1/manual/strings/</a>. Es posible que desee probar algunas de ellas para asegurarse de comprender cómo funcionan. <code>strip</code> y <code>replace</code> son particularmente útiles.</p>
</div>
<div class="paragraph">
<p>La documentación utiliza una sintaxis que puede ser confusa. Por ejemplo, en <code>search(cadena::AbstractString, caracter::Chars, [comienzo::Integer])</code>, los corchetes indican argumentos opcionales. Por lo tanto, <code>cadena</code> y <code>caracter</code> son obligatorios, pero <code>comienzo</code> es opcional.
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex08-2">Ejercicio 8-8</h4>
<div class="paragraph">
<p>Hay una función integrada llamada <code>count</code> que es similar a la función en <a href="#looping_and_counting">Iterando y contando</a>. Lea la documentación de esta función y úsela para contar el número de letras <code>a</code> en "banana".
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex08-3">Ejercicio 8-9</h4>
<div class="paragraph">
<p>Una porción de cadena puede tomar un tercer índice. El primero especifica el inicio, el tercero el final y el segundo el "tamaño del paso"; es decir, el número de espacios entre caracteres sucesivos. Un tamaño de paso de 2 significa cada un caracter; 3 significa cada dos, etc.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fruta = "banana"
"banana"
julia&gt; fruta[1:2:6]
"bnn"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un tamaño de paso de -1 recorre la palabra hacia la izquierda, por lo que la porción <code>[end:-1:1]</code> genera una cadena invertida.</p>
</div>
<div class="paragraph">
<p>Use esto para escribir una versión de una línea de código de <code>espalindromo</code> de <a href="#ex06-3">Ejercicio 6-6</a>.
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex08-4">Exercise 8-10</h4>
<div class="paragraph">
<p>Las siguientes funciones están <em>destinadas</em> a verificar si una cadena contiene letras minúsculas, pero algunas de ellas son incorrectas. Para cada función, describa qué hace realmente la función (suponiendo que el parámetro es una cadena).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function cualquierminuscula1(s)
    for c in s
        if islowercase(c)
            return true
        else
            return false
        end
    end
end

function cualquierminuscula2(s)
    for c in s
        if islowercase('c')
            return "true"
        else
            return "false"
        end
    end
end

function cualquierminuscula3(s)
    for c in s
        bandera = islowercase(c)
    end
    flag
end

function cualquierminuscula4(s)
    bandera = false
    for c in s
        bandera = bandera || islowercase(c)
    end
    flag
end

function cualquierminuscula5(s)
    for c in s
        if !islowercase(c)
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ex08-5">Exercise 8-11</h4>
<div class="paragraph">
<p>Un cifrado César es una forma simple de cifrado que implica desplazar cada letra un número fijo de lugares. Desplazar una letra significa reemplazarla por otra letra que se encuentra un número fijo de posiciones más adelante en el alfabeto. Es posible desplazarse hasta el principio del abecedario si fuera necesario. De esta manera, con un desplazamiento de 3, <code><em>A</em></code> es <code><em>D</em></code>, y con un desplazamiento de 1, <code><em>Z</em></code> es <code><em>A</em></code> .
</p>
</div>
<div class="paragraph">
<p>Para desplazar una palabra, desplace cada letra en la misma cantidad. Por ejemplo, con un desplazamiento de 6, <code>"ABCDEF"</code> es <code>"GHIJKL"</code> y con un desplazamiento de -6, <code>"BCDE"</code> es <code>"VWXY"</code>. En la película <em>2001: Una odisea del espacio</em>, la computadora de la nave se llama HAL, que es IBM desplazada por -1.</p>
</div>
<div class="paragraph">
<p>Escriba una función llamada <code>desplazarpalabra</code> que tome una cadena y un número entero como parámetros, y devuelva una nueva cadena que contenga las letras de la cadena original desplazadas por la cantidad dada.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Es posible que desee utilizar la función integrada <code>Int</code>, que convierte un carácter en un código numérico, y <code>Char</code>, que convierte los códigos numéricos en caracteres. Las letras del alfabeto están codificadas en orden alfabético, por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Int('c') - Int('a')
2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Porque <code><em>c</em></code> es la tercera letra del alfabeto. Pero cuidado: los códigos numéricos para las letras mayúsculas son diferentes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Char(Int('A') + 32)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Algunos chistes ofensivos en Internet están codificados en ROT13, que es un cifrado César con desplazamiento 13. Si no te ofendes fácilmente, encuentra y decodifica algunos de ellos.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap09">9. Estudio de Caso: Juego de Palabras</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo presenta un segundo estudio de caso, que consiste en resolver puzzles buscando palabras que tengan ciertas propiedades. Por ejemplo, buscaremos palabras cuyas letras aparezcan en orden alfabético. Además, se presentará otra forma de desarrollar programas: la reducción a un problema previamente resuelto.</p>
</div>
<div class="sect2">
<h3 id="reading_word_lists">Leer listas de palabras</h3>
<div class="paragraph">
<p>Para los ejercicios de este capítulo necesitamos una lista de palabras en español. Hay muchas listas de palabras disponibles en la Web, pero la más adecuada para nuestro propósito es una de las listas de palabras recopiladas y contribuidas al dominio público por Ismael Olea (see <a href="http://olea.org/proyectos/lemarios/" class="bare">http://olea.org/proyectos/lemarios/</a>). Esta lista de 87900 palabras se encuentra en la página de Olea con el nombre de archivo <em>lemario-general-del-espanol.txt</em>. También es posible descargar una copia desde <a href="https://github.com/PiensaEnJulia/PiensaEnJulia.jl/blob/master/data/palabras.txt" class="bare">https://github.com/PiensaEnJulia/PiensaEnJulia.jl/blob/master/data/palabras.txt</a>.
</p>
</div>
<div class="paragraph">
<p>Este archivo es un archivo de texto simple, por lo que puede ser abierto con un editor de texto o leído con Julia. La función integrada <code>open</code> toma el nombre del archivo como parámetro y devuelve un objeto archivo que puede ser usado para la lectura del archivo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fin = open("palabras.txt")
IOStream(&lt;file palabras.txt&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fin</code> es un objeto archivo que puede ser utilizado como entrada y cuando se deja de utilizar, debe cerrarse con <code>close(fin)</code>.</p>
</div>
<div class="paragraph">
<p>Julia tiene integrada varias funciones de lectura, entre ellas <code>readline</code>, que lee los caracteres del archivo hasta que llega a un <code>salto de línea</code>, devolviendo el resultado como una cadena:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; readline(fin)
"a"</code></pre>
</div>
</div>
<div class="paragraph">
<p>La primera palabra en esta lista particular es "a", que indica dirección, intervalo de tiempo, finalidad, entre otros.</p>
</div>
<div class="paragraph">
<p>El objeto archivo lleva registro de dónde quedó por última vez, por lo que si llama a readline nuevamente, se obtendrá la siguiente palabra:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; readline(fin)
"a-"</code></pre>
</div>
</div>
<div class="paragraph">
<p>La siguiente palabra es "a-", que es un prefijo que indica privación.</p>
</div>
<div class="paragraph">
<p>También se puede usar un archivo como parte de un bucle <code>for</code>. El siguiente programa lee <code>palabras.txt</code> e imprime cada palabra, una por línea:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for line in eachline("palabras.txt")
    println(line)
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_10">Ejercicios</h3>
<div class="sect3">
<h4 id="ex09-1">Ejercicio 9-1</h4>
<div class="paragraph">
<p>Escriba un programa que lea <code>palabras.txt</code> e imprima solo las palabras con más de 20 caracteres (sin contar espacios en blanco).</p>
</div>
</div>
<div class="sect3">
<h4 id="ex09-2">Ejercicio 9-2</h4>
<div class="paragraph">
<p>En 1927 Enrique Jardiel Poncela publicó cinco historias cortas, omitiendo en cada una de ellas una vocal. Estas historias incluyen "El Chofer Nuevo", narración escrita sin la letra <code><em>a</em></code>, y "Un marido sin vocación", sin la letra <code><em>e</em></code>. Dado que la letra <code><em>e</em></code> es la más frecuente del español, esto no es fácil de lograr.
</p>
</div>
<div class="paragraph">
<p>De hecho, es difícil pensar oraciones que no utilicen esta letra. Intentarlo es complicado, pero con la práctica se vuelve más fácil.</p>
</div>
<div class="paragraph">
<p>Bueno, a lo que vinimos.</p>
</div>
<div class="paragraph">
<p>Escriba una función llamada <code>notiene_e</code> que devuelva <code>true</code> si una palabra dada no tiene la letra <code><em>e</em></code>.
</p>
</div>
<div class="paragraph">
<p>Modifique su programa de la sección anterior para que imprima solo las palabras que no tienen <code><em>e</em></code>, y que además calcule el porcentaje de palabras en la lista que no tengan <code><em>e</em></code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex09-3">Ejercicio 9-3</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>evitar</code> que tome como argumentos una palabra y una cadena de letras prohibidas, y que devuelva <code>true</code> si la palabra no usa ninguna de las letras prohibidas.
</p>
</div>
<div class="paragraph">
<p>Modifique su programa de la sección anterior para solicitar al usuario que ingrese una cadena de letras prohibidas, y que luego imprima el número de palabras que no contengan ninguna de ellas. ¿Es posible encontrar una combinación de 5 letras prohibidas que excluya la menor cantidad de palabras?</p>
</div>
</div>
<div class="sect3">
<h4 id="ex09-4">Ejercicio 9-4</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>usasolo</code> que tome una palabra y una cadena de letras, y que devuelva <code>true</code> si la palabra contiene solo letras de la lista. ¿Puedes hacer una oración usando solo las letras <code>oneacmil</code>? Aparte de <code>"¿El camino?"</code>
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex09-5">Ejercicio 9-5</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>usatodo</code> que tome una palabra y una cadena de letras, y que devuelva <code>true</code> si la palabra usa todas las letras requeridas al menos una vez. ¿Cuántas palabras usan todas las vocales <code>aeiou</code>?
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex09-6">Ejercicio 9-6</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>esabecedaria</code> que devuelva <code>true</code> si las letras de una palabra aparecen en orden alfabético. ¿Cuántas palabras de este tipo hay?
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search">Búsqueda</h3>
<div class="paragraph">
<p>Todos los ejercicios en la sección anterior tienen algo en común: se pueden resolver con el patrón de búsqueda. El ejemplo más simple es:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function notiene_e(palabra)
    for letra in palabra
        if letra == 'e'
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El bucle <code>for</code> recorre los caracteres de palabra. Si encontramos la letra <code><em>e</em></code>, podemos devolver inmediatamente <code>false</code>; de lo contrario tenemos que pasar a la siguiente letra. Si salimos del bucle normalmente, eso significa que no encontramos una <code><em>e</em></code>, por lo que devolvemos <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Esta función podría ser escrita de manera más concisa usando el operador <code>∉</code> (<strong><code>\notin TAB</code></strong>), pero se comienza con esta versión porque muestra la lógica del patrón de búsqueda.
</p>
</div>
<div class="paragraph">
<p><code>evita</code> es una versión más general de <code>notiene_e</code> pero tiene la misma estructura:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function evita(palabra, prohibidas)
    for letra in palabra
        if letter ∈ prohibidas
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se devuelve <code>false</code> tan pronto como se encuentre una letra prohibida; si llegamos al final del ciclo, se devuelve <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>usasolo</code> es similar, excepto que el sentido de la condición se invierte:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function usasolo(palabra, disponibles)
    for letra in palabra
        if letra ∉ disponibles
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>En vez de un conjunto de letras prohibidas, se tiene un conjunto de letras disponibles. Si encontramos una letra en <code>palabra</code> que no está en <code>disponible</code>, se devuelve <code>false</code>.</p>
</div>
<div class="paragraph">
<p><code>usatodo</code> es similar, excepto que se invierte el papel de la palabra y la cadena de letras:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function usatodo(palabra, requeridas)
    for letra in requeridas
        if letra ∉ palabra
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>En lugar de recorrer las letras de la palabra, el bucle recorre las letras requeridas. Si alguna de las letras requeridas no aparece en la palabra, se devuelve <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Si pensáramos como un informático reconoceríamos que <code>usatodo</code> es una instancia de un problema previamente resuelto, y podríamos haber escrito:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function usatodo(palabra, requeridas)
    usasolo(requeridas, palabra)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este es un ejemplo de una forma de desarrollar programas llamada <em>reducción a un problema resuelto previamente</em>, lo que significa que se reconoce el problema en el que se está trabajando como una instancia de un problema ya resuelto y se aplica la solución existente.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_bucle_con_índices">Bucle con índices</h3>
<div class="paragraph">
<p>Las funciones de la sección anterior fueron escritas con ciclos <code>for</code> porque solo se necesitaban los caracteres en las cadenas, no hubo necesidad de trabajar con los índices.</p>
</div>
<div class="paragraph">
<p>Para <code>esabecedaria</code> tenemos que comparar letras adyacentes, lo cual es un poco complicado con un ciclo <code>for</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function esabecedaria(palabra)
    i = firstindex(palabra)
    previa = palabra[i]
    j = nextind(palabra, i)
    for c in palabra[j:end]
        if c &lt; previa
            return false
        end
        previa = c
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otra alternativa es usar recursividad:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function esabecedaria(palabra)
    if length(palabra) &lt;= 1
        return true
    end
    i = firstindex(palabra)
    j = nextind(palabra, i)
    if palabra[i] &gt; palabra[j]
        return false
    end
    esabecedaria(palabra[j:end])
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una tercera opción es usar un ciclo <code>while</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function esabecedaria(palabra)
    i = firstindex(palabra)
    j = nextind(palabra, 1)
    while j &lt;= sizeof(palabra)
        if palabra[j] &lt; palabra[i]
            return false
        end
        i = j
        j = nextind(palabra, i)
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El ciclo comienza en <code>i=1</code> y <code>j=nextind(palabra, 1)</code> y termina cuando <code>j&gt;sizeof(palabra)</code>. En cada iteración, se compara el carácter <code>i</code>ésimo (que se puede considerar como el carácter actual) con el carácter <code>j</code>ésimo (que se puede considerar como el siguiente).</p>
</div>
<div class="paragraph">
<p>Si el siguiente carácter es menor (va antes en el alfabeto) que el actual, entonces la palabra no tiene sus letras en orden alfabético, y se devuelve <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Si llegamos al final del ciclo sin encontrar letras que imposibiliten el orden alfabético, entonces la palabra pasa la prueba. Para convencerse de que el ciclo termina correctamente, considere como ejemplo la palabra <code>"Abel"</code>.</p>
</div>
<div class="paragraph">
<p>A continuación se muestra una versión de <code>espalindromo</code> que usa dos índices; uno comienza al principio de la palabra y aumenta su valor; el otro comienza al final y disminuye su valor.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function espalindromo(palabra)
    i = firstindex(palabra)
    j = lastindex(palabra)
    while i&lt;j
        if palabra[i] != palabra[j]
            return false
        end
        i = nextind(palabra, i)
        j = prevind(palabra, j)
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O podríamos reducir este problema a uno previamente resuelto y escribir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function espalindromo(palabra)
    isreverse(palabra, palabra)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usando <code>esreverso</code> de <a href="#deb08">Depuración</a>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_7">Depuración</h3>
<div class="paragraph">
<p>Comprobar el correcto funcionamiento de los programas es difícil. Las funciones de este capítulo son relativamente fáciles de probar porque se pueden verificar los resultados a mano. Aun así, es casi imposible elegir un conjunto de palabras que permitan evaluar todos los posibles errores.
</p>
</div>
<div class="paragraph">
<p>Tomando <code>notiene_e</code> como ejemplo, hay dos casos obvios que verificar: las palabras que tienen una <code><em>e</em></code> deberían devolver <code>false</code>, y las palabras que no, deberían devolver <code>true</code>. No deberían haber problemas para encontrar un ejemplo de cada uno.</p>
</div>
<div class="paragraph">
<p>Dentro de cada caso, hay algunos subcasos menos obvios. Entre las palabras que tienen una "e", se deben probar las palabras con una "e" al principio, al final y al medio. Además, se deben probar palabras largas, cortas y muy cortas, como una cadena vacía. La cadena vacía es un ejemplo de un "caso especial" no obvio donde pueden originarse errores.
</p>
</div>
<div class="paragraph">
<p>Además de las instancias de prueba generadas, también puede probar su programa con una lista de palabras como <code>palabras.txt</code>. Al escanear el resultado, es posible que pueda detectar errores, pero tenga cuidado: puede detectar un tipo de error (palabras que no deberían incluirse, pero lo están) y no otro (palabras que deberían incluirse, pero no lo están).</p>
</div>
<div class="paragraph">
<p>Por lo general, las pruebas pueden ayudarlo a encontrar errores, pero no es fácil generar un buen conjunto de instancias de prueba, e incluso si lo hace, no puede estar seguro de que su programa sea correcto. Según un informático muy famoso:
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Las pruebas de programa se pueden usar para mostrar la presencia de errores, ¡pero nunca para mostrar su ausencia!</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Edsger W. Dijkstra
</div>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_8">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">objeto archivo o file stream</dt>
<dd>
<p>Un valor que representa un archivo abierto.
</p>
</dd>
<dt class="hdlist1">reducción a un problema previamente resuelto</dt>
<dd>
<p>Una manera de resolver un problema expresándolo como una instancia de un problema previamente resuelto.
</p>
</dd>
<dt class="hdlist1">caso especial</dt>
<dd>
<p>Una instancia de prueba que es atípica o no obvia (y por lo tanto, menos probable que se maneje correctamente).
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_11">Ejercicios</h3>
<div class="sect3">
<h4 id="ex09-7">Ejercicio 9-7</h4>
<div class="paragraph">
<p>Esta pregunta se basa en un Puzzle que se transmitió en el programa de radio <em>Car Talk</em> (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Se tiene una secuencia de números y se desea saber cuál es el siguiente. Los números son: 4, 6, 12, 18, 30, 42, 60 y luego X.</p>
</div>
<div class="paragraph">
<p>Pista 1: Todos los números de la secuencia son pares.
Pista 2: El número que va después del que estoy buscando es 102.</p>
</div>
<div class="paragraph">
<p>¿Cuál es el número?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Primero, piense el patrón que busca, y luego escriba un programa que le permita encontrar el número que sigue este patrón, que se encuentra entre 60 y 102.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex09-8">Ejercicio 9-8</h4>
<div class="paragraph">
<p>A continuación se muestra otro puzzle de <em>Car Talk</em> (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Estaba conduciendo por la autopista el otro día y vi mi odómetro. Como la mayoría de los odómetros, muestra seis dígitos y solo en kilómetros enteros. Entonces, si mi automóvil tuviera un kilometraje de 300000, por ejemplo, sería 3-0-0-0-0-0.</p>
</div>
<div class="paragraph">
<p>Ahora, lo que vi ese día fue muy interesante. Noté que los últimos 4 dígitos eran palindrómicos; es decir, se leían igual hacia adelante que hacia atrás. Por ejemplo, 5-4-4-5 es un palíndromo, por lo que mi odómetro podría haberse leído 3-1-5-4-4-5.</p>
</div>
<div class="paragraph">
<p>Un kilómetro después, los últimos 5 números fueron palindrómicos. Por ejemplo, podría haberse leído 3-6-5-4-5-6. Un kilómetro después de eso, los 4 números del medio eran palindrómicos. ¿Y&#8230;&#8203; estás listo para esto? ¡Un kilómetro después, los 6 eran palindrómicos!</p>
</div>
<div class="paragraph">
<p>La pregunta es, ¿qué número estaba en el odómetro cuando miré por primera vez?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Escriba un programa de Julia que pruebe todos los números de seis dígitos e imprima cualquier número que satisfaga estos requisitos.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex09-9">Ejercicio 9-9</h4>
<div class="paragraph">
<p>Aquí hay otro puzzle de <em>Car Talk</em> que puede resolver con una búsqueda (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Hace poco visité a mi madre y nos dimos cuenta de que los dos dígitos que componen mi edad cuando se invertían daban como resultado su edad. Por ejemplo, si tiene 73 años, yo tengo 37. Nos preguntamos con qué frecuencia esto ha sucedido a lo largo de los años, pero nos desviamos de otros temas y nunca obtuvimos una respuesta.</p>
</div>
<div class="paragraph">
<p>Cuando llegué a casa descubrí que los dígitos de nuestras edades han sido reversibles seis veces hasta ahora. También descubrí que si teníamos suerte, volvería a suceder en unos años, y si tenemos mucha suerte, sucedería una vez más después de eso. En otras palabras, habría sucedido 8 veces. Entonces la pregunta es, ¿cuántos años tengo ahora?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Escriba un programa de Julia que busque soluciones para este puzzle.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Puede encontrar la función <code>lpad</code> útil.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap10">10. Arreglos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo presenta uno de los tipos más útiles de Julia: los arreglos. También aprenderemos sobre objetos y lo que puede suceder cuando se tiene más de un nombre para el mismo objeto.</p>
</div>
<div class="sect2">
<h3 id="_un_arreglo_es_una_secuencia">Un arreglo es una secuencia</h3>
<div class="paragraph">
<p>Al igual que una cadena de texto, un <em>arreglo</em> es una secuencia de valores. En una cadena los valores son caracteres, en un arreglo pueden ser de cualquier tipo. Los valores en un arreglo se denominan <em>elementos</em> o, a veces, <em>items</em>.
</p>
</div>
<div class="paragraph">
<p>Hay varias formas de crear un nuevo arreglo; la más sencilla es encerrar los elementos entre corchetes (<code>[ ]</code>):
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">[10, 20, 30, 40]
["abadejo", "falsía", "estrambote"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>El primer ejemplo es un arreglo de cuatro enteros. El segundo es un arreglo de tres cadenas de texto. Los elementos de un arreglo no tienen por qué ser del mismo tipo. El siguiente arreglo contiene una cadena, un número de punto flotante, un entero y otro arreglo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">["spam", 2.0, 5, [10, 20]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se dice que un arreglo dentro de otro arreglo está <em>anidado</em>.
</p>
</div>
<div class="paragraph">
<p>Un arreglo que no contiene elementos se llama arreglo vacío; se puede crear uno con corchetes vacíos, <code>[]</code>.
</p>
</div>
<div class="paragraph">
<p>Como es de esperar, se pueden asignar valores de arreglos a variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; quesos = ["Cheddar", "Edam", "Gouda"];

julia&gt; numeros = [42, 123];

julia&gt; vacio = [];

julia&gt; print(quesos, " ", numeros, " ", vacio)
["Cheddar", "Edam", "Gouda"] [42, 123] Any[]</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>typeof</code> se puede usar para conocer el tipo del arreglo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; typeof(quesos)
Array{String,1}
julia&gt; typeof(numeros)
Array{Int64,1}
julia&gt; typeof(vacio)
Array{Any,1}</code></pre>
</div>
</div>
<div class="paragraph">
<p>El tipo del arreglo se especifica entre llaves, y se compone de un tipo y un número. El número indica las dimensiones. El conjunto <code>vacío</code> contiene valores de tipo <code>Any</code>, es decir, puede contener valores de todos los tipos.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_los_arreglos_son_mutables">Los arreglos son mutables</h3>
<div class="paragraph">
<p>La sintaxis para acceder a los elementos de un arreglo es el mismo que para acceder a los caracteres de una cadena: el operador corchete. La expresión dentro de los corchetes especifica el índice. Recuerde que los índices comienzan en 1:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; quesos[1]
"Cheddar"</code></pre>
</div>
</div>
<div class="paragraph">
<p>A diferencia de las cadenas, los arreglos son <em>mutables</em>, lo que significa que podemos cambiar sus elementos. Se puede modificar uno de sus elementos usando el operador corchetes en el lado izquierdo de una asignación:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; numeros[2] = 5
5
julia&gt; print(numeros)
[42, 5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>El segundo elemento de <code>numeros</code>, que era 123, ahora es 5.</p>
</div>
<div class="paragraph">
<p><a href="#fig10-1">State diagram</a> muestra los diagramas de estado para <code>quesos</code>, <code>numeros</code> y <code>vacio</code>.
</p>
</div>
<div id="fig10-1" class="imageblock">
<div class="content">
<img src="images/fig101.svg" alt="fig101">
</div>
<div class="title">Figura 11. State diagram</div>
</div>
<div class="paragraph">
<p>Los arreglos son representados mediante cuadros con elementos del arreglo en su interior. El arreglo <code>quesos</code> hace referencia a un arreglo con tres elementos indexados <code>1</code>, <code>2</code> y <code>3</code>. El arreglo <code>numeros</code> contiene dos elementos. El diagrama muestra que el valor del segundo elemento de <code>numeros</code> se ha reasignado de <code>123</code> a <code>5</code>. Finalmente, <code>vacio</code> hace referencia a un arreglo sin elementos.</p>
</div>
<div class="paragraph">
<p>Los índices de un arreglo funcionan de la misma manera que los índices de una cadena (pero sin los problemas generados por la codificación UTF-8):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cualquier expresión entera se puede usar como índice.</p>
</li>
<li>
<p>Si se intenta leer o escribir un elemento que no existe, se obtiene un <code>BoundsError</code>.</p>
</li>
<li>
<p>La palabra reservada <code>end</code> indica el último índice del arreglo.
</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El operador <code>∈</code> también funciona en arreglos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; "Edam" ∈ quesos
true
julia&gt; "Brie" in quesos
false</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_recorriendo_un_arreglo">Recorriendo un Arreglo</h3>
<div class="paragraph">
<p>La forma más común de recorrer los elementos de un arreglo es con un ciclo <code>for</code>. La sintaxis es la misma que para las cadenas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for queso in quesos
    println(queso)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto funciona bien si solo se necesita leer los elementos del arreglo. Pero si se desea escribir o actualizar los elementos es necesario utilizar índices. Una forma común de hacerlo es usando la función integrada <code>eachindex</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for i in eachindex(numeros)
    numeros[i] = numeros[i] * 2
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este bucle recorre el arreglo y actualiza cada elemento. En cada iteración del ciclo, <code>i</code> representa el índice del elemento actual. La sentencia de asignación usa <code>numeros[i]</code> para leer el valor original del elemento y asignar el nuevo valor.</p>
</div>
<div class="paragraph">
<p>Por otra parte, <code>length</code> devuelve el número de elementos en el arreglo.</p>
</div>
<div class="paragraph">
<p>Un ciclo <code>for</code> sobre un arreglo vacío nunca ejecuta el cuerpo del bucle:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for x in []
    println("Esto nunca pasa.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aunque un arreglo puede contener otro arreglo, este arreglo anidado cuenta como un elemento único. Por ejemplo, la longitud de este arreglo es cuatro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">["spam", 1, ["Brie", "Roquefort", "Camembert"], [1, 2, 3]]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_porciones_de_arreglos">Porciones de arreglos</h3>
<div class="paragraph">
<p>El operador porción también funciona en arreglos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c', 'd', 'e', 'f'];

julia&gt; print(t[1:3])
['a', 'b', 'c']
julia&gt; print(t[3:end])
['c', 'd', 'e', 'f']</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador porción <code>[:]</code> hace una copia de todo el arreglo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; print(t[:])
['a', 'b', 'c', 'd', 'e', 'f']</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como los arreglos son mutables, es útil hacer una copia antes de realizar operaciones que las modifiquen.</p>
</div>
<div class="paragraph">
<p>Un operador porción en el lado izquierdo de una asignación puede actualizar varios elementos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t[2:3] = ['x', 'y'];

julia&gt; print(t)
['a', 'x', 'y', 'd', 'e', 'f']</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_librería_de_arreglos">Librería de Arreglos</h3>
<div class="paragraph">
<p>Julia tiene funciones integradas que operan en arreglos. Por ejemplo, <code>push!</code> agrega un nuevo elemento al final de un arreglo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; push!(t, 'd');

julia&gt; print(t)
['a', 'b', 'c', 'd']</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>append!</code> agrega elementos de un arreglo al final de otro:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t1 = ['a', 'b', 'c'];

julia&gt; t2 = ['d', 'e'];

julia&gt; append!(t1, t2);

julia&gt; print(t1)
['a', 'b', 'c', 'd', 'e']</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo <code>t2</code> no es modificado.</p>
</div>
<div class="paragraph">
<p><code>sort!</code> ordena los elementos de un arreglo de menor a mayor:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['d', 'c', 'e', 'b', 'a'];

julia&gt; sort!(t);

julia&gt; print(t)
['a', 'b', 'c', 'd', 'e']</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sort</code> devuelve una copia ordenada de los elementos de un arreglo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t1 = ['d', 'c', 'e', 'b', 'a'];

julia&gt; t2 = sort(t1);

julia&gt; print(t1)
['d', 'c', 'e', 'b', 'a']
julia&gt; print(t2)
['a', 'b', 'c', 'd', 'e']</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Nota</div>
</td>
<td class="content">
<div class="paragraph">
<p>Como convención en Julia, se agrega <code>!</code> a los nombres de las funciones que modifican sus argumentos.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_mapear_filtrar_y_reducir">Mapear, Filtrar y Reducir</h3>
<div class="paragraph">
<p>Para sumar todos los números en un arreglo se puede usar un ciclo como este:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function sumartodo(t)
    total = 0
    for x in t
        total += x
    end
    total
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>total</code> se inicializa en 0. En cada iteración, con <code>+=</code> se añade un elemento del arreglo a la suma total. El operador <code>+=</code> es una forma simple de actualizar esta variable. Esta <em>sentencia de asignación aumentada</em>,
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">total += x</code></pre>
</div>
</div>
<div class="paragraph">
<p>es equivalente a</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">total = total + x</code></pre>
</div>
</div>
<div class="paragraph">
<p>A medida que se ejecuta el ciclo, <code>total</code> acumula la suma de los elementos. A veces se denomina <em>acumulador</em> a una variable utilizada de esta manera.
</p>
</div>
<div class="paragraph">
<p>Sumar los elementos de un arreglo es una operación tan común que Julia tiene una función integrada para ello, <code>sum</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [1, 2, 3, 4];

julia&gt; sum(t)
10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una operación como esta, que combina una secuencia de elementos en un solo valor a veces se denomina <em>operación de reducción</em>.
</p>
</div>
<div class="paragraph">
<p>Es común querer recorrer un arreglo mientras se construye otro. Por ejemplo, la siguiente función toma un arreglo de cadenas y devuelve un nuevo arreglo que contiene las mismas cadenas pero en mayúsculas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function todoenmayusculas(t)
    res = []
    for s in t
        push!(res, uppercase(s))
    end
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>res</code> se inicializa con un arreglo vacío, y en cada iteración se le agrega un nuevo elemento. De esta manera, <code>res</code> es otro tipo de acumulador.</p>
</div>
<div class="paragraph">
<p>Una operación como <code>todoenmayusculas</code> a veces se denomina <em>mapeo</em> porque "asigna" una función (en este caso <code>uppercase</code>) a cada uno de los elementos de una secuencia.
</p>
</div>
<div class="paragraph">
<p>Otra operación común es seleccionar solo algunos de los elementos de un arreglo y devolver una sub-arreglo. Por ejemplo, la siguiente función toma un arreglo de cadenas y devuelve un arreglo que contiene solamente las cadenas en mayúsculas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function solomayusculas(t)
    res = []
    for s in t
        if s == uppercase(s)
            push!(res, s)
        end
    end
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Operaciones como <code>solomayusculas</code> se llaman <em>filtro</em> porque seleccionan solo algunos elementos, filtrando otros.
</p>
</div>
<div class="paragraph">
<p>Las operaciones de arreglos más comunes son una combinación de mapeo, filtro y reducción.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sintaxis_de_punto">Sintaxis de punto</h3>
<div class="paragraph">
<p>Para cada operador binario, como por ejemplo <code>^</code>, existe un <em>operador punto</em> correspondiente <code>.^</code> que automaticamente define la operación <code>^</code> para cada elemento de un arreglo. Por ejemplo, <code>&#91;1, 2, 3&#93; ^ 3</code> no está definido, pero <code>&#91;1, 2, 3&#93; .^ 3</code> se define como el resultado de realizar la operación <code>^</code> en cada elemento <code>&#91;1^3, 2^3, 3^3&#93;</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; print([1, 2, 3] .^ 3)
[1, 8, 27]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cualquier función <code>f</code> de Julia puede ser aplicada a cada elemento de cualquier arreglo con la <em>sintaxis de punto</em>. Por ejemplo, para poner en mayúsculas un arreglo de cadenas, no es necesario un bucle explícito:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = uppercase.(["abc", "def", "ghi"]);

julia&gt; print(t)
["ABC", "DEF", "GHI"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta es una forma elegante de crear un mapeo. Siguiendo esta lógica, la función <code>todoenmayusculas</code> puede implementarse con una línea:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function todoenmayusculas(t)
    uppercase.(t)
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_borrando_insertando_elementos">Borrando (Insertando) Elementos</h3>
<div class="paragraph">
<p>Hay varias formas de eliminar elementos de un arreglo. Si se conoce el índice del elemento que se desea eliminar, se puede usar <code>splice!</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; splice!(t, 2)
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
julia&gt; print(t)
['a', 'c']</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>splice!</code> modifica el arreglo y devuelve el elemento que se eliminó.</p>
</div>
<div class="paragraph">
<p><code>pop!</code> elimina y devuelve el último elemento:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; pop!(t)
'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)
julia&gt; print(t)
['a', 'b']</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>popfirst!</code> elimina y devuelve el primer elemento:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; popfirst!(t)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia&gt; print(t)
['b', 'c']</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las funciones <code>pushfirst!</code> y <code>push!</code> insertan un elemento al principio y al final del arreglo, respectivamente.
</p>
</div>
<div class="paragraph">
<p>Si no se necesita el valor eliminado, se puede usar la función <code>deleteat!</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; print(deleteat!(t, 2))
['a', 'c']</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>insert!</code> inserta un elemento en un índice dado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'b', 'c'];

julia&gt; print(insert!(t, 2, 'x'))
['a', 'x', 'b', 'c']</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arreglos_y_cadenas">Arreglos y Cadenas</h3>
<div class="paragraph">
<p>Una cadena es una secuencia de caracteres y un arreglo es una secuencia de valores, pero un arreglo de caracteres no es lo mismo que una cadena. Para convertir una cadena a un arreglo de caracteres, se puede usar la función <code>collect</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = collect("spam");

julia&gt; print(t)
['s', 'p', 'a', 'm']</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>collect</code> divide una cadena u otra secuencia en elementos individuales.</p>
</div>
<div class="paragraph">
<p>Si desea dividir una cadena en palabras, puede usar la función <code>split</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = split("En un lugar de la Mancha");

julia&gt; print(t)
SubString{String}["En", "un", "lugar", "de", "la", "Mancha"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un <em>argumento opcional</em> llamado <em>delimitador</em> especifica qué caracteres usar como límites de palabra. El siguiente ejemplo usa un guión como delimitador:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = split("hola-hola-hola", '-');

julia&gt; print(t)
SubString{String}["hola", "hola", "hola"]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>join</code> es el inverso de <code>split</code>. Toma un arreglo de cadenas y concatena los elementos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ["En", "un", "lugar", "de", "la", "Mancha"];

julia&gt; s = join(t, ' ')
"En un lugar de la Mancha"</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este caso, el delimitador es un carácter de espacio en blanco. Para concatenar cadenas sin espacios, no especifique un delimitador.</p>
</div>
</div>
<div class="sect2">
<h3 id="_objeto_y_valores">Objeto y Valores</h3>
<div class="paragraph">
<p>Un <em>objeto</em> es algo a lo que una variable puede referirse. Hasta ahora, podría usar "objeto" y "valor" indistintamente.
</p>
</div>
<div class="paragraph">
<p>Si ejecutamos estas sentencias de asignación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">a = "banana"
b = "banana"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sabemos que <code>a</code> y <code>b</code> apuntan a una cadena, pero no sabemos si están apuntando a la <em>misma</em> cadena. Hay dos estados posibles, los cuales se muestran en la Figura 10-2.
</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/fig102.svg" alt="fig102">
</div>
<div class="title">Figura 12. State diagrams.</div>
</div>
<div class="paragraph">
<p>En un caso, <code>a</code> y <code>b</code> se refieren a dos objetos diferentes que tienen el mismo valor. En el segundo caso, se refieren al mismo objeto.</p>
</div>
<div class="paragraph">
<p>Para verificar si dos variables se refieren al mismo objeto, se puede usar el operador <code>≡</code> (<strong><code>\equiv TAB</code></strong>)) o <code>===</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = "banana"
"banana"
julia&gt; b = "banana"
"banana"
julia&gt; a ≡ b
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, Julia solo creó un objeto de cadena, y ambas variables <code>a</code> y <code>b</code> apuntan a ella. Pero cuando se crean dos arreglos, se obtienen dos objetos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = [1, 2, 3];

julia&gt; b = [1, 2, 3];

julia&gt; a ≡ b
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Entonces el diagrama de estado se ve así <a href="#fig10-3">State diagram</a>.
</p>
</div>
<div id="fig10-3" class="imageblock">
<div class="content">
<img src="images/fig103.svg" alt="fig103">
</div>
<div class="title">Figura 13. State diagram</div>
</div>
<div class="paragraph">
<p>En este caso, diríamos que los dos arreglos son <em>equivalentes</em>, porque tienen los mismos elementos, pero no <em>idénticos</em>, porque no son el mismo objeto. Si dos objetos son idénticos, también son equivalentes, pero si son equivalentes, no son necesariamente idénticos.
</p>
</div>
<div class="paragraph">
<p>Para ser precisos, un objeto tiene un valor. Si se evalúa <code>[1, 2, 3]</code>, se obtendrá un objeto arreglo cuyo valor es una secuencia de enteros. Si otro arreglo tiene los mismos elementos, decimos que tiene el mismo valor, pero no es el mismo objeto.</p>
</div>
</div>
<div class="sect2">
<h3 id="_alias_poner_sobrenombres">Alias (poner sobrenombres)</h3>
<div class="paragraph">
<p>Si <code>a</code> apunta a un objeto, y asignas <code>b = a</code>, entonces ambas variables se refieren al mismo objeto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = [1, 2, 3];

julia&gt; b = a;

julia&gt; b ≡ a
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>El diagrama de estado sería como este <a href="#fig10-4">State diagram</a>.</p>
</div>
<div id="fig10-4" class="imageblock">
<div class="content">
<img src="images/fig104.svg" alt="fig104">
</div>
<div class="title">Figura 14. State diagram</div>
</div>
<div class="paragraph">
<p>La asociación de una variable con un objeto se llama <em>referencia</em>. En este ejemplo, hay dos referencias al mismo objeto.
</p>
</div>
<div class="paragraph">
<p>Un objeto con más de una referencia tiene más de un nombre, por lo que decimos que el objeto tiene un <em>alias</em>.
</p>
</div>
<div class="paragraph">
<p>Si el objeto con alias es mutable, los cambios hechos a un alias afectan al otro:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; b[1] = 42
42
julia&gt; print(a)
[42, 2, 3]</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>Aunque este comportamiento puede ser util, a veces puede inducir a errores. En general, es ms seguro evitar los alias cuando trabajemos con objetos mutables.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>No hay problema con los alias al trabajar con objetos inmutables, tales como cadenas de texto. En este ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">a = "banana"
b = "banana"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Casi nunca es relevante que <code>a</code> y <code>b</code> se refieran a la misma cadena o no.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arreglos_como_argumentos">Arreglos como argumentos</h3>
<div class="paragraph">
<p>Cuando se pasa un arreglo como argumento de una función, en realidad se pasa una referencia a ella. Si la función modifica el arreglo, el que hizo la llamada verá el cambio. Por ejemplo, la función <code>borrarprimero</code> elimina el primer elemento de un arreglo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function borrarprimero!(t)
    popfirst!(t)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aquí vemos el uso de borrarprimero!:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; letras = ['a', 'b', 'c'];

julia&gt; borrarprimero!(letras);

julia&gt; print(letras)
['b', 'c']</code></pre>
</div>
</div>
<div class="paragraph">
<p>El parámetro <code>t</code> y la variable <code>letras</code> son alias de un mismo objeto. El diagrama de estado es así <a href="#fig10-5">Stack diagram</a>.
</p>
</div>
<div id="fig10-5" class="imageblock">
<div class="content">
<img src="images/fig105.svg" alt="fig105">
</div>
<div class="title">Figura 15. Stack diagram</div>
</div>
<div class="paragraph">
<p>Como el arreglo está compartido por dos marcos, lo dibujamos entre ambos.</p>
</div>
<div class="paragraph">
<p>Es importante distinguir entre operaciones que modifiquen arreglos y operaciones que creen nuevas arreglos. Por ejemplo, <code>push!</code> modifica un arreglo, pero <code>vcat</code> crea un nuevo arreglo.
</p>
</div>
<div class="paragraph">
<p>Aquí hay un ejemplo de <code>push!</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t1 = [1, 2];

julia&gt; t2 = push!(t1, 3);

julia&gt; print(t1)
[1, 2, 3]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>t2</code> es un alias de <code>t1</code>.</p>
</div>
<div class="paragraph">
<p>Aquí hay un ejemplo de <code>vcat</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t3 = vcat(t1, [4]);

julia&gt; print(t1)
[1, 2, 3]
julia&gt; print(t3)
[1, 2, 3, 4]</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado de <code>vcat</code> es unn nuevo arreglo. El arreglo original no ha sufrido cambios.</p>
</div>
<div class="paragraph">
<p>Esta diferencia es importante al momento de escribir funciones que modifican arreglos.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, esta función <em>no</em> elimina el primer elemento de un arrreglo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function noborrarprimero(t)
    t = t[2:end]                # MALO!
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador porción crea un nuevo arreglo y la asignación hace que <code>t</code> se refiera a ella, pero eso no afecta al arreglo <code>t</code> fuera de la función.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t4 = noborrarprimero(t3);

julia&gt; print(t3)
[1, 2, 3, 4]
julia&gt; print(t4)
[2, 3, 4]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Al comienzo de <code>noborrarprimero</code>, <code>t</code> y <code>t3</code> se refieren al mismo arreglo. Al final, <code>t</code> se refiere a un nuevo arreglo, pero <code>t3</code> todavía se refiere al arreglo original no modificado.</p>
</div>
<div class="paragraph">
<p>Una alternativa es escribir una función que cree y devuelva un nuevo arreglo. Por ejemplo, la función <code>cola</code> devuelve todos menos el primer elemento de un arreglo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function cola(t)
    t[2:end]
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta función no modifica el arreglo original, y se usa de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; letras = ['a', 'b', 'c'];

julia&gt; demas = cola(letras);

julia&gt; print(demas)
['b', 'c']</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_8">Depuración</h3>
<div class="paragraph">
<p>Un uso inadecuado de los arreglos (y otros objetos mutables) puede llevarnos a largas horas de depuración. A continuación se muestran algunos errores comunes y cómo evitarlos:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La mayoría de las funciones que operan en arreglos modifican el argumento. Esto es lo opuesto a lo que ocurre en las funciones que operan en cadenas de texto, que devuelven una nueva cadena y dejan la original sin modificaciones.</p>
<div class="paragraph">
<p>Si está acostumbrado a escribir código con cadenas de texto como este:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">nueva_palabra = strip(palabra)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puede parecer tentador escribir código con arreglos como este:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">t2 = sort!(t1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pero como <code>sort!</code> devuelve el arreglo original <code>t1</code> modificado, <code>t2</code> es un alias de <code>t1</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Antes de utilizar funciones y operadores de arreglos, debes leer la documentación detenidamente y luego probarla en modo interactivo.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Escoge una expresión y quédate con ella.</p>
<div class="paragraph">
<p>Parte del problema con los arreglos es que hay demasiadas formas de hacer las cosas. Por ejemplo, para eliminar un elemento de un arreglo se puede usar <code>pop!</code>, <code>popfirst!</code>, <code>delete_at</code>, o incluso una asignación de porción. Para agregar un elemento se puede usar <code>push!</code>, <code>pushfirst!</code>, <code>insert!</code> or <code>vcat</code>. Suponiendo que <code>t</code> es un arreglo y <code>x</code>, es un elemento, estas formas son correctas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">insert!(t, 4, x)
push!(t, x)
append!(t, [x])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Y estos incorrectas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">insert!(t, 4, [x])         # MALO!
push!(t, [x])              # MALO!
vcat(t, [x])               # MALO!</code></pre>
</div>
</div>
</li>
<li>
<p>Haga copias para evitar usar alias.</p>
<div class="paragraph">
<p>Si se desea utilizar una función como <code>sort!</code> que modifica el argumento, pero también se necesita mantener el arreglo original, es posible hacer una copia:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [3, 1, 2];

julia&gt; t2 = t[:]; # t2 = copy(t)

julia&gt; sort!(t2);

julia&gt; print(t)
[3, 1, 2]
julia&gt; print(t2)
[1, 2, 3]</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, también podría usar la función incorporada <code>sort</code>, que devuelve un nuevo arreglo ordenado y no modifica el original:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t2 = sort(t);

julia&gt; println(t)
[3, 1, 2]
julia&gt; println(t2)
[1, 2, 3]</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_9">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">arreglo</dt>
<dd>
<p>Una secuencia de valores.
</p>
</dd>
<dt class="hdlist1">elemento</dt>
<dd>
<p>Uno de los valores de un arreglo (u otra secuencia), también llamado item.
</p>
</dd>
<dt class="hdlist1">lista anidada</dt>
<dd>
<p>Un arreglo que es elemento de otro arreglo.
</p>
</dd>
<dt class="hdlist1">acumulador</dt>
<dd>
<p>Una variable utilizada en un ciclo para sumar o acumular un resultado.
</p>
</dd>
<dt class="hdlist1">asignación aumentada</dt>
<dd>
<p>Una sentencia que actualiza el valor de una variable usando un operador como <code>+=</code>.
</p>
</dd>
<dt class="hdlist1">operador punto</dt>
<dd>
<p>Operador binario que se aplica a cada elemento de un arreglo.
</p>
</dd>
<dt class="hdlist1">sintaxis de punto</dt>
<dd>
<p>Sintaxis utilizada para aplicar una función a todos los elementos de cualquier arreglo.
</p>
</dd>
<dt class="hdlist1">operación de reducción</dt>
<dd>
<p>Un patrón de procesamiento que recorre una secuencia y acumula los elementos en un solo resultado.
</p>
</dd>
<dt class="hdlist1">mapeo</dt>
<dd>
<p>Un patrón de procesamiento que recorre una secuencia y realiza una operación en cada elemento.
</p>
</dd>
<dt class="hdlist1">filtro</dt>
<dd>
<p>Un patrón de procesamiento que recorre una secuencia y selecciona los elementos que satisfacen algún criterio.
</p>
</dd>
<dt class="hdlist1">objeto</dt>
<dd>
<p>Una cosa a la que se puede referir una variable. Un objeto tiene tipo y valor.
</p>
</dd>
<dt class="hdlist1">equivalente</dt>
<dd>
<p>Tener el mismo valor.
</p>
</dd>
<dt class="hdlist1">idéntico</dt>
<dd>
<p>Ser el mismo objeto (lo que implica equivalencia).
</p>
</dd>
<dt class="hdlist1">referencia</dt>
<dd>
<p>La asociación entre una variable y su valor.
</p>
</dd>
<dt class="hdlist1">alias</dt>
<dd>
<p>Multiples variables que contienen referencias al mismo objeto.
</p>
</dd>
<dt class="hdlist1">argumentos opcionales</dt>
<dd>
<p>argumentos que no son necesarios.
</p>
</dd>
<dt class="hdlist1">delimitador</dt>
<dd>
<p>Un carácter o cadena utilizado para indicar donde debe cortarse una cadena.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_12">Ejercicios</h3>
<div class="sect3">
<h4 id="ex10-1">Ejercicio 10-1</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>sumaanidada</code> que tome un arreglo de arreglos de enteros y sume los elementos de todos los arreglos anidados. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [[1, 2], [3], [4, 5, 6]];

julia&gt; sumaanidada(t)
21</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ex10-2">Ejercicio 10-2</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>sumaacumulada</code> que tome un arreglo de números y devuelva la suma acumulativa; es decir, un nuevo arreglo donde el \(i\)ésimo elemento es la suma de los primeros \(i\) elementos del arreglo original. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [1, 2, 3];

julia&gt; print(sumaacumulada(t))
Any[1, 3, 6]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ex10-3">Ejercicio 10-3</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>interior</code> que tome un arreglo y devuelva un nuevo arreglo que contenga todos los elementos excepto el primero y el último. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [1, 2, 3, 4];

julia&gt; print(interior(t))
[2, 3]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ex10-4">Ejercicio 10-4</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>interior!</code> que tome un arreglo, lo modifique eliminando el primer y el último elemento, y que no devuelva un valor. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [1, 2, 3, 4];

julia&gt; interior!(t)

julia&gt; print(t)
[2, 3]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ex10-5">Ejercicio 10-5</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>estaordenada</code> que tome un arreglo como parámetro y devuelva <code>true</code> si el arreglo se ordena en orden ascendente y <code>false</code> de lo contrario. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; estaordenada([1, 2, 2])
true
julia&gt; estaordenada(['b', 'a'])
false</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ex10-6">Ejercicio 10-6</h4>
<div class="paragraph">
<p>Dos palabras son anagramas si se pueden ordenar las letras de una para escribir la otra. Escriba una función llamada <code>esanagrama</code> que tome dos cadenas y devuelva <code>true</code> si son anagramas.
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex10-7">Ejercicio 10-7</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>repetido</code> que tome un arreglo y devuelva <code>true</code> si hay algún elemento que aparece más de una vez. No debe modificar el arreglo original.
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex10-8">Ejercicio 10-8</h4>
<div class="paragraph">
<p>Este ejercicio se relaciona con la llamada paradoja del cumpleaños, sobre la cual puede leer en <a href="https://es.wikipedia.org/wiki/Paradoja_del_cumplea%C3%B1os" class="bare">https://es.wikipedia.org/wiki/Paradoja_del_cumplea%C3%B1os</a>
</p>
</div>
<div class="paragraph">
<p>Si hay 23 estudiantes en su clase, ¿cuáles son las posibilidades de que dos de ustedes tengan el mismo cumpleaños? Puede estimar esta probabilidad generando muestras aleatorias de 23 cumpleaños y buscando coincidencias.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Puede generar cumpleaños aleatorios con <code>rand(1:365)</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ex10-9">Ejercicio 10-9</h4>
<div class="paragraph">
<p>Escriba una función que lea el archivo <code>palabras.txt</code> y construya un arreglo con un elemento por palabra. Escriba dos versiones de esta función, una con <code>push!</code> y la otra con la expresión <code>t = [t..., x]</code>. ¿Cuál tarda más en ejecutarse? ¿Por qué?
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex10-10">Ejercicio 10-10</h4>
<div class="paragraph">
<p>Para verificar si una palabra está en el arreglo de palabras se puede usar el operador <code>∈</code>. Esto sería lento pues este operador busca las palabras en orden.</p>
</div>
<div class="paragraph">
<p>Debido a que las palabras están en orden alfabético, podemos acelerar la verificación con una búsqueda de bisección (también conocida como búsqueda binaria), que es similar a lo que haces cuando buscas una palabra en el diccionario. Comienzas en el medio y verificas si la palabra que estás buscando va antes que la palabra localizada en el medio. Si es así, se busca en la primera mitad de la matriz de la misma manera. De lo contrario, se busca en la segunda mitad.</p>
</div>
<div class="paragraph">
<p>En ambos casos se reduce el espacio de búsqueda restante a la mitad. Si el arreglo de palabras tiene 113,809 palabras, se necesitarán unos 17 pasos para encontrar la palabra o concluir que no está allí.</p>
</div>
<div class="paragraph">
<p>Escriba una función llamada <code>enbiseccion</code> que tome un arreglo ordenado y un valor objetivo, y devuelva <code>true</code> si la palabra está en el arreglo y <code>false</code> si no lo está.
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex10-11">Ejercicio 10-11</h4>
<div class="paragraph">
<p>Dos palabras son un "par inverso" si cada una es la inversa de la otra. Escriba un programa llamado <code>parinverso</code> que encuentre todos los pares inversos en el arreglo de palabras.
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex10-12">Ejercicio 10-12</h4>
<div class="paragraph">
<p>Dos palabras se "entrelazan" si al tomar letras alternando entre cada palabra se forma una nueva palabra. Por ejemplo, "pi" y "as" se entrelazan para formar "pais".
</p>
</div>
<div class="paragraph">
<p>Credito: Este ejercicio está inspirado en un ejemplo de <a href="http://puzzlers.org" class="bare">http://puzzlers.org</a>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escriba un programa que encuentre todos los pares de palabras que se entrelazan.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>¡No enumeres todos los pares!</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>¿Puedes encontrar tres palabras que se entrelacen, es decir, cada tercera letra forma una palabra, empezando de la primera, segunda o tercera letra de la palabra?</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap11">11. Diccionarios</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo presenta otro tipo integrado llamado diccionario.</p>
</div>
<div class="sect2">
<h3 id="_un_diccionario_es_un_mapeo">Un Diccionario es un Mapeo</h3>
<div class="paragraph">
<p>Un <em>diccionario</em> es como una matriz, pero más general. En una matriz, los índices tienen que ser enteros; en un diccionario pueden ser (casi) de cualquier tipo.
</p>
</div>
<div class="paragraph">
<p>Un diccionario contiene una colección de índices, llamados <em>claves</em>, y una colección de valores. Cada clave está asociada a un solo valor. La asociación entre una clave y un valor se denomina <em>par clave-valor</em> o, a veces, item.
</p>
</div>
<div class="paragraph">
<p>En lenguaje matemático, un diccionario representa un <em>mapeo</em> de las claves a los valores, es decir, cada clave apunta a un valor. A modo de ejemplo, crearemos un diccionario que asocie palabras en español con palabras en inglés. En este diccionario, las claves y los valores son cadenas.
</p>
</div>
<div class="paragraph">
<p>La función <code>Dict</code> crea un nuevo diccionario sin elementos. Como <code>Dict</code> es el nombre de una función integrada de Julia, debe evitar usarla como nombre de variable.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ing_a_esp = Dict()
Dict{Any,Any} with 0 entries</code></pre>
</div>
</div>
<div class="paragraph">
<p>El tipo de este diccionario está compuesto por el tipo de las claves y de los valores, entre llaves. En este caso, las claves y los valores son de tipo <code>Any</code>.
</p>
</div>
<div class="paragraph">
<p>El diccionario está vacio. Para agregar elementos a él, se pueden usar corchetes:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ing_a_esp["one"] = "uno";</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta línea de código crea un elemento con la clave "one" que apunta al valor "uno". Si imprimimos el diccionario nuevamente, vemos un par clave-valor con una flecha <code>=&gt;</code> entre la clave y el valor:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ing_a_esp
Dict{Any,Any} with 1 entry:
  "one" =&gt; "uno"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este formato de salida también es un formato de entrada. Por ejemplo, puedes crear un nuevo diccionario con tres items de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ing_a_esp = Dict("one" =&gt; "uno", "two" =&gt; "dos", "three" =&gt; "tres")
Dict{String,String} with 3 entries:
  "two"   =&gt; "dos"
  "one"   =&gt; "uno"
  "three" =&gt; "tres"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Todas las claves y valores iniciales son cadenas, por lo que se crea un <code>Dict{String,String}</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>El orden de los pares clave-valor podría no ser el mismo. Si escribe el mismo ejemplo en su computadora, podría obtener un resultado diferente. En general, el orden de los elementos en un diccionario es impredecible.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Esto no significa un problema ya que los elementos de un diccionario nunca se indexan con índices enteros. En lugar de ello, se utilizan las claves para buscar los valores correspondientes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ing_a_esp["two"]
"dos"</code></pre>
</div>
</div>
<div class="paragraph">
<p>La clave "two" nos da el valor "dos", así que el orden de los items no importa.</p>
</div>
<div class="paragraph">
<p>Si la clave no está en el diccionario, recibimos un mensaje de error:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ing_a_esp["four"]
ERROR: KeyError: key "four" not found</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>length</code> también funciona con diccionarios; devuelve el número de pares clave-valor:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; length(ing_a_esp)
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>keys</code> devuelve una colección con las claves del diccionario:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ks = keys(ing_a_esp);

julia&gt; print(ks)
["two", "one", "three"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>También se puede usar el operador <code>∈</code> para ver si algo es una <em>clave</em> en un diccionario:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; "one" ∈ ks
true
julia&gt; "uno" ∈ ks
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para ver si algo es un valor en un diccionario, se puede usar la función <code>values</code>, que devuelve una colección de valores, y luego usar el operador <code>∈</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; vs = values(ing_a_esp);

julia&gt; "uno" ∈ vs
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador <code>∈</code> utiliza diferentes algoritmos para matrices y diccionarios. Para las matrices, busca los elementos de la matriz en orden, como en <a href="#searching">Búsqueda</a>. El tiempo de búsqueda es directamente proporcional al largo de la matriz.</p>
</div>
<div class="paragraph">
<p>Para los diccionarios, Julia usa un algoritmo llamado <em>tabla hash</em> que tiene una propiedad importante: el operador <code>∈</code> toma aproximadamente la misma cantidad de tiempo sin importar cuántos elementos haya en el diccionario.
</p>
</div>
</div>
<div class="sect2">
<h3 id="dictionary_collection_counters">Diccionario como una Colección de Frecuencias</h3>
<div class="paragraph">
<p>Suponga que tienes una cadena y deseas contar cuántas veces aparece cada letra. Hay varias formas de hacerlo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Podrías crear 27 variables, una para cada letra del alfabeto. Luego, recorrer la cadena y, para cada carácter, incrementar el contador correspondiente, probablemente utilizando condiciones encadenadas.</p>
</li>
<li>
<p>Podrías crear una matriz con 27 elementos. Luego, podrías convertir cada carácter en un número (usando la función integrada <code>Int</code>), usar el número como índice en la matriz e incrementar el contador apropiado.</p>
</li>
<li>
<p>Puedes crear un diccionario con caracteres como claves y contadores como los valores correspondientes. La primera vez que veas un carácter, agregarías un elemento al diccionario. Después de eso, incrementarías el valor de un elemento existente.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cada una de estas opciones realiza el mismo cálculo, pero la implementación es diferente.</p>
</div>
<div class="paragraph">
<p>Una <em>implementación</em> es una forma de realizar un cálculo. Algunas implementaciones son mejores que otras, por ejemplo, una ventaja de la implementación del diccionario es que no tenemos que saber de antemano qué letras aparecen en la cadena y solo tenemos que agregar las letras que aparecen.
</p>
</div>
<div class="paragraph">
<p>Así es como se vería el código:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function histograma(s)
    d = Dict()
    for c in s
        if c ∉ keys(d)
            d[c] = 1
        else
            d[c] += 1
        end
    end
    d
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función se llama <code>histograma</code>, que es un término en estadística para una colección de frecuencias (o conteos).
</p>
</div>
<div class="paragraph">
<p>La primera línea de la función crea un diccionario vacío. El ciclo <code>for</code> recorre la cadena <code>s</code>. En cada iteración de este ciclo, si el carácter <code>c</code> no está en el diccionario, se crea un nuevo elemento con la clave <code>c</code> y el valor inicial <code>1</code> (ya que hemos visto esta letra una vez). Si <code>c</code> ya está en el diccionario, se incrementa <code>d[c]</code>.</p>
</div>
<div class="paragraph">
<p>Así es como funciona:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; h = histograma("brontosaurus")
Dict{Any,Any} with 8 entries:
  'n' =&gt; 1
  's' =&gt; 2
  'a' =&gt; 1
  'r' =&gt; 2
  't' =&gt; 1
  'o' =&gt; 2
  'u' =&gt; 2
  'b' =&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>El histograma indica que las letras <code><em>a</em></code> y <code><em>b</em></code> aparecen una vez; <code><em>o</em></code> aparece dos veces, y así sucesivamente.</p>
</div>
<div class="paragraph">
<p>Los diccionarios tienen una función llamada <code>get</code> que toma como argumentos un diccionario, una clave y un valor predeterminado. Si la clave aparece en el diccionario, <code>get</code> devuelve el valor correspondiente; de lo contrario, devuelve el valor predeterminado. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; h = histograma("a")
Dict{Any,Any} with 1 entry:
  'a' =&gt; 1
julia&gt; get(h, 'a', 0)
1
julia&gt; get(h, 'b', 0)
0</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicio_11_1">Ejercicio 11-1</h4>
<div class="paragraph">
<p>Use <code>get</code> para escribir la función <code>histograma</code> de manera más concisa. Debería poder eliminar la declaración <code>if</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_iteración_y_diccionarios">Iteración y Diccionarios</h3>
<div class="paragraph">
<p>Es posible recorrer las claves del diccionario con un ciclo <code>for</code>. Por ejemplo, <code>imprimirhist</code> imprime cada clave y su valor correspondiente:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimirhist(h)
    for c in keys(h)
        println(c, " ", h[c])
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Así es como se ve la salida:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; h = histograma("perros");

julia&gt; imprimirhist(h)
s 1
e 1
p 1
r 2
o 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nuevamente, las claves no están en un orden particular. Para recorrer las claves en orden, puede usar <code>sort</code> y <code>collect</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; for c in sort(collect(keys(h)))
           println(c, " ", h[c])
       end
e 1
o 1
p 1
r 2
s 1</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_búsqueda_inversa">Búsqueda inversa</h3>
<div class="paragraph">
<p>Dado un diccionario <code>d</code> y una clave <code>k</code>, es fácil encontrar el valor correspondiente <code>v = d[k]</code>. Esta operación se llama <em>búsqueda</em>.
</p>
</div>
<div class="paragraph">
<p>Pero, ¿qué pasa si tenemos <code>v</code> y queremos encontrar <code>k</code>? Existen dos problemas: primeramente, puede haber más de una clave que apunta al valor <code>v</code>. Dependiendo de lo que queramos, es posible que podamos elegir una de estas claves, o que tengamos que hacer una matriz que las contenga a todas. En segundo lugar, no hay una sintaxis simple para hacer una búsqueda inversa; solo debemos buscar.
</p>
</div>
<div class="paragraph">
<p>A continuación se muestra una función que toma un valor y que devuelve la primera clave que apunta a ese valor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function busquedainversa(d, v)
    for k in keys(d)
        if d[k] == v
            return k
        end
    end
    error("Error de Busqueda")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta función es otro ejemplo del patrón de búsqueda, pero utiliza una función que no hemos visto antes: <code>error</code>. La función <code>error</code> se usa para producir un <code>ErrorException</code> que interrumpe el flujo normal. En este caso tiene el mensaje <code>"Error de Busqueda"</code>, que indica que no existe una clave.
</p>
</div>
<div class="paragraph">
<p>Si llega al final del ciclo, eso significa que <code>v</code> no aparece en el diccionario como un valor, por lo que se produce una excepción.</p>
</div>
<div class="paragraph">
<p>A continuación se muestra un ejemplo de una búsqueda inversa exitosa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; h = histograma("perros");

julia&gt; key = busquedainversa(h, 2)
'r': ASCII/Unicode U+0072 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Y una no exitosa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; key = busquedainversa(h, 3)
ERROR: Error de Busqueda</code></pre>
</div>
</div>
<div class="paragraph">
<p>El efecto cuando generamos una excepción es el mismo que cuando Julia genera una: se imprime un trazado inverso y un mensaje de error.</p>
</div>
<div class="paragraph">
<p>Julia proporciona una forma optimizada de hacer una búsqueda inversa: <code>findall(isequal(3),h)</code>.
</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>Una búsqueda inversa es mucho más lenta que una búsqueda directa. Si tiene que hacer búsquedas inversas con frecuencia, o si el diccionario es muy grande, el rendimiento de su programa se verá afectado.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_diccionarios_y_matrices">Diccionarios y Matrices</h3>
<div class="paragraph">
<p>Las matrices pueden aparecer como valores en un diccionario. Por ejemplo, si tenemos un diccionario que asigna frecuencias a letras, y queremos invertirlo; es decir, tener un diccionario que asigne letras a frecuencias. Dado que pueden haber varias letras con la misma frecuencia, cada valor en el diccionario invertido debería ser una matriz de letras.</p>
</div>
<div class="paragraph">
<p>Aquí hay una función que invierte un diccionario:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function invertirdic(d)
    inverso = Dict()
    for clave in keys(d)
        val = d[clave]
        if val ∉ keys(inverso)
            inverso[val] = [clave]
        else
            push!(inverso[val], clave)
        end
    end
    inverso
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cada vez que recorremos el bucle, se asigna a la variable <code>clave</code> una clave de <code>d</code>, y a <code>val</code> el valor correspondiente. Si <code>val</code> no está en el diccionario <code>inverso</code>, significa que no hemos visto este valor antes, por lo que creamos un nuevo item y lo inicializamos con un <em>singleton</em> (una matriz que contiene un solo elemento). De lo contrario, hemos visto este valor antes, por lo que agregamos la clave correspondiente a la matriz.
</p>
</div>
<div class="paragraph">
<p>Aquí hay un ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; hist = histograma("perros");

julia&gt; inverso = invertirdic(hist)
Dict{Any,Any} with 2 entries:
  2 =&gt; ['r']
  1 =&gt; ['s', 'e', 'p', 'o']</code></pre>
</div>
</div>
<div id="fig11-1" class="imageblock">
<div class="content">
<img src="images/fig111.svg" alt="fig111">
</div>
<div class="title">Figura 16. State diagram</div>
</div>
<div class="paragraph">
<p><a href="#fig11-1">State diagram</a> es un diagrama de estado que muestra <code>hist</code> e <code>inverso</code>. Un diccionario se representa como un cuadro con los pares clave-valor dentro. En este libro, si los valores son enteros, números de punto flotante o cadenas de texto, se dibujan dentro del cuadro, y las matrices (generalmente) se dibujan fuera del cuadro, solo para mantener el diagrama simple.
</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Nota</div>
</td>
<td class="content">
<div class="paragraph">
<p>Anteriormente se mencionó que un diccionario se implementa usando una tabla hash (también llamada matriz asociativa, hashing, mapa hash, tabla de dispersión o tabla fragmentada), lo cual significa que las claves deben ser <em>hashable</em>.
</p>
</div>
<div class="paragraph">
<p>Un <em>hash</em> es una función que toma un valor (de cualquier tipo) y devuelve un entero. Los diccionarios usan estos enteros, llamados valores hash, para almacenar y buscar pares clave-valor.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="memos">Pistas</h3>
<div class="paragraph">
<p>Si estuvo jugando con la función <code>fibonacci</code> de <a href="#one_more_example">Un Ejemplo Más</a>, es posible que haya notado que cuanto más grande el argumento que le da, más tiempo tarda la función en ejecutarse. Más aún, el tiempo de ejecución aumenta muy rápidamente.
</p>
</div>
<div class="paragraph">
<p>Para entender por qué, considere <a href="#fig11-2">Call graph</a>, que muestra el <em>gráfico de llamadas</em> para la función <code>fibonacci</code> con <code>n = 4</code>:
</p>
</div>
<div id="fig11-2" class="imageblock">
<div class="content">
<img src="images/fig112.svg" alt="fig112">
</div>
<div class="title">Figura 17. Call graph</div>
</div>
<div class="paragraph">
<p>Un gráfico de llamadas muestra un conjunto de cuadros de funciones, con líneas que conectan cada cuadro con los cuadros de las funciones a las que llama. En la parte superior del gráfico, <code>fibonacci</code> con <code>n = 4</code> llama a <code>fibonacci</code> con <code>n = 3</code> y <code>n = 2</code>. A su vez, <code>fibonacci</code> con <code>n = 3</code> llama a <code>fibonacci</code> con <code>n = 2</code> y <code>n = 1</code>. Y así sucesivamente.</p>
</div>
<div class="paragraph">
<p>Cuente cuántas veces se llama a <code>fibonacci(0)</code> y <code>fibonacci(1)</code>. Esta es una solución ineficiente al problema, y empeora a medida que el argumento aumenta en tamaño.</p>
</div>
<div class="paragraph">
<p>Una solución es llevar un registro de los valores que ya se han calculado almacenándolos en un diccionario. Un valor que ya ha sido calculado y almacenado para un uso posterior se le denomina <em>pista</em>. Aquí hay una implementación de fibonacci con pistas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">anteriores = Dict(0=&gt;0, 1=&gt;1)

function fibonacci(n)
    if n ∈ keys(anteriores)
        return anteriores[n]
    end
    res = fibonacci(n-1) + fibonacci(n-2)
    anteriores[n] = res
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El diccionario llamado <code>anteriores</code> mantiene un registro de los valores de Fibonacci que ya conocemos. El programa comienza con dos pares: <code>0</code> corresponde a <code>1</code> y <code>1</code> corresponde a <code>1</code>.</p>
</div>
<div class="paragraph">
<p>Siempre que se llama a <code>fibonacci</code>, se comprueba si el diccionario contiene el resultado ya calculado. Si está ahi, la función puede devolver el valor inmediatamente. Si no, tiene que calcular el nuevo valor, añadirlo al diccionario y devolverlo.</p>
</div>
<div class="paragraph">
<p>Si ejecuta esta versión de <code>fibonacci</code> y la compara con la original, se dará cuenta de que es mucho más rápida.</p>
</div>
</div>
<div class="sect2">
<h3 id="global_variables">Variables Globales</h3>
<div class="paragraph">
<p>En el ejemplo anterior, el diccionario anteriores se crea fuera de la función, por lo que pertenece al marco especial llamado <code>Main</code>. Las variables en <code>Main</code> a veces son llamadas <em>globales</em> porque se puede acceder a ellas desde cualquier función. A diferencia de las variables locales, que desaparecen cuando finaliza su función, las variables globales existen de una llamada de función a la siguiente.
</p>
</div>
<div class="paragraph">
<p>Es común usar variables globales como <em>flags</em> o <em>banderas</em>; es decir, variables booleanas que indican si una condición es verdadera. Por ejemplo, algunos programas usan una bandera llamada <code>verbosa</code> para controlar el nivel de detalle en la salida:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">verbose = true

function ejemplo1()
    if verbosa
        println("Ejecutando ejemplo1")
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si intentas reasignar una variable global, te sorprenderás. El siguiente ejemplo trata de llevar registro sobre si se ha llamado o no a una función:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">ha_sido_llamada = false

function ejemplo2()
    ha_sido_llamada = true         # MALO
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pero si lo ejecutas, verás que el valor de <code>ha_sido_llamada</code> no cambia. El problema es que <code>ejemplo2 + crea una nueva variable local llamada +ha_sido_llamada</code>. La variable local desaparece cuando finaliza la función y no tiene efecto en la variable global.</p>
</div>
<div class="paragraph">
<p>Para reasignar una variable global dentro de una función, debe <em>declarar</em> la variable global antes de usarla:
(reasignación</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">been_called = false

function ejemplo2()
    global ha_sido_llamada
    ha_sido_llamada = true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La <em>sentencia global</em> le dice al intérprete algo como esto: “En esta función, cuando digo <code>ha_sido_llamada</code>, me refiero a la variable global; así que no crees una variable local".
</p>
</div>
<div class="paragraph">
<p>A continuación se muestra un ejemplo que intenta actualizar una variable global:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">conteo = 0

function ejemplo3()
    conteo = conteo + 1          # MALO
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si lo ejecutas obtienes:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ejemplo3()
ERROR: UndefVarError: conteo not defined</code></pre>
</div>
</div>
<div class="paragraph">
<p>Julia asume que <code>conteo</code> es local, y bajo esa suposición lo estás leyendo antes de escribirlo. La solución, nuevamente, es declarar <code>conteo</code> como global.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">conteo = 0

function ejemplo3()
    global conteo
    conteo += 1
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si una variable global se refiere a un valor mutable, puedes modificar el valor sin declarar la variable global:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">anteriores = Dict(0=&gt;0, 1=&gt;1)

function ejemplo4()
    anteriores[2] = 1
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por lo tanto, puede agregar, eliminar y reemplazar elementos de una matriz global o diccionario, pero si desea reasignar la variable, debe declararla global:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">anteriores = Dict(0=&gt;0, 1=&gt;1)

function ejemplo5()
    global anteriores
    anteriores = Dict()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para mejorar el rendimiento, puedes declarar la variable global como constante. Con esto, ya no se puede reasignar la variable, pero si se refiere a un valor mutable, sí se puede modificar el valor.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">const known = Dict(0=&gt;0, 1=&gt;1)

function example4()
    known[2] = 1
end</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>Las variables globales pueden ser útiles, pero si tiene muchas de ellas y las modifica con frecuencia, pueden dificultar la depuración y empeorar el desempeño de los programas.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_9">Depuración</h3>
<div class="paragraph">
<p>A medida que trabaja con conjuntos de datos más grandes, la depuración mediante la impresió y verificación de la salida de manera manual puede tornarse difícil. Aquí hay algunas sugerencias para depurar grandes conjuntos de datos:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reduzca la entrada:</p>
<div class="paragraph">
<p>Si es posible, reduzca el tamaño del conjunto de datos. Por ejemplo, si el programa lee un archivo de texto, comience con solo las primeras 10 líneas, o con el ejemplo más pequeño que pueda encontrar que produzca errores. No debe editar los archivos, sino modificar el programa para que solo lea las primeras \(n\) líneas.
</p>
</div>
<div class="paragraph">
<p>Si hay un error, puede reducir \(n\) al valor más pequeño que manifieste el error, y luego aumentarlo gradualmente a medida que encuentre y corrija errores.</p>
</div>
</li>
<li>
<p>Revisar resúmenes y tipos</p>
<div class="paragraph">
<p>En lugar de imprimir y verificar todo el conjunto de datos, considere imprimir resúmenes de los datos: por ejemplo, el número de elementos en un diccionario o el total de una serie de números.
</p>
</div>
<div class="paragraph">
<p>Una causa común de los errores de tiempo de ejecución son los valores de tipo incorrecto. Para depurar este tipo de error, generalmente es suficiente imprimir el tipo de un valor.</p>
</div>
</li>
<li>
<p>Escribir autocomprobaciones:</p>
<div class="paragraph">
<p>Puede escribir código que verifique errores automáticamente. Por ejemplo, si está calculando el promedio de una matriz de números, puede verificar que el resultado no sea mayor que el elemento más grande de la matriz o menor que el más pequeño. Esto se llama "prueba de cordura".
</p>
</div>
<div class="paragraph">
<p>Otro tipo de verificación compara los resultados de dos cálculos diferentes para ver si son consistentes. Esta se llama "prueba de consistencia".
</p>
</div>
</li>
<li>
<p>Formatear la salida:</p>
<div class="paragraph">
<p>Formatear la salida de depuración puede hacer que sea más fácil detectar un error. Vimos un ejemplo en <a href="#deb06">Depuración</a>.
</p>
</div>
<div class="paragraph">
<p>Nuevamente, el tiempo que dedica a construir andamiaje puede reducir el tiempo que dedica a la depuración
</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_10">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">mapeo</dt>
<dd>
<p>Una relación en la que cada elemento de un conjunto corresponde a un elemento de otro conjunto.
</p>
</dd>
<dt class="hdlist1">diccionario</dt>
<dd>
<p>Una asignación de claves a sus valores correspondientes.
</p>
</dd>
<dt class="hdlist1">par clave-valor</dt>
<dd>
<p>La representación de la asociación entre una clave y un valor.
</p>
</dd>
<dt class="hdlist1">item</dt>
<dd>
<p>En un diccionario, otro nombre para un par clave-valor.
</p>
</dd>
<dt class="hdlist1">clave</dt>
<dd>
<p>Un objeto que aparece en un diccionario como la primera parte de un par clave-valor.
</p>
</dd>
<dt class="hdlist1">valor</dt>
<dd>
<p>Un objeto que aparece en un diccionario como la segunda parte de un par clave-valor. Este término es más específico que nuestro uso previo de la palabra "valor".
</p>
</dd>
<dt class="hdlist1">implementación</dt>
<dd>
<p>Una forma de realizar un cálculo.
</p>
</dd>
<dt class="hdlist1">tabla hash</dt>
<dd>
<p>El algoritmo utilizado para implementar los diccionarios de Julia.
</p>
</dd>
<dt class="hdlist1">función hash</dt>
<dd>
<p>Una función utilizada por una tabla hash para calcular la ubicación de una clave.
</p>
</dd>
<dt class="hdlist1">hashable</dt>
<dd>
<p>Un tipo que tiene una función hash.
</p>
</dd>
<dt class="hdlist1">búsqueda</dt>
<dd>
<p>Una operación sobre un diccionario que toma una clave y encuentra el valor correspondiente.
</p>
</dd>
<dt class="hdlist1">búsqueda inversa</dt>
<dd>
<p>Una operación sobre un diccionario que toma un valor y encuentra una o más claves que se asignan a él.
</p>
</dd>
<dt class="hdlist1">singleton</dt>
<dd>
<p>Una matriz (u otra secuencia) con un solo elemento.
</p>
</dd>
<dt class="hdlist1">gráfico de llamada</dt>
<dd>
<p>Un diagrama que muestra cada cuadro creado durante la ejecución de un programa, con una flecha entre cada función y sus respectivas funciones llamadas.
</p>
</dd>
<dt class="hdlist1">pista</dt>
<dd>
<p>Valor precalculado y almacenado temporalmente para evitar cálculos redundantes.
</p>
</dd>
<dt class="hdlist1">variable global</dt>
<dd>
<p>Una variable definida fuera de una función. Se puede acceder a las variables globales desde cualquier función.
</p>
</dd>
<dt class="hdlist1">sentencia global</dt>
<dd>
<p>Una sentencia que declara un nombre de variable global.
</p>
</dd>
<dt class="hdlist1">bandera</dt>
<dd>
<p>Una variable booleana utilizada para indicar si una condición es verdadera.
</p>
</dd>
<dt class="hdlist1">declaración</dt>
<dd>
<p>Una sentencia como <code>global</code> que le dice al intérprete algo sobre una variable.
</p>
</dd>
<dt class="hdlist1">variable global constante</dt>
<dd>
<p>Una variable global que no se puede reasignar.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_13">Ejercicios</h3>
<div class="sect3">
<h4 id="ex11-1">Ejercicio 11-2</h4>
<div class="paragraph">
<p>Escriba una función que lea las palabras en <em>palabras.txt</em> y las almacene como claves en un diccionario. No importa cuáles sean los valores. Luego puede usar el operador <code>∈</code> como una forma rápida de verificar si una cadena está en el diccionario.
</p>
</div>
<div class="paragraph">
<p>Si hizo <a href="#ex10-10">Ejercicio 10-10</a>, puede comparar la velocidad de esta implementación con el operador array <code>∈</code> y la búsqueda binaria.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex11-2">Ejercicio 11-3</h4>
<div class="paragraph">
<p>Lea la documentación de la función que opera sobre diccionarios <code>get!</code> y úsela para escribir una versión más concisa de <code>invertirdic</code>.
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex11-3">Ejercicio 11-4</h4>
<div class="paragraph">
<p>Use pistas en la función de Ackermann de <a href="#ex06-2">Ejercicio 6-5</a> y vea si esto permite evaluar la función con argumentos de mayor tamaño.
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex11-4">Ejercicio 11-5</h4>
<div class="paragraph">
<p>Si hizo <a href="#ex10-7">Ejercicio 10-7</a>, ya tiene una función llamada <code>repetido</code> que toma una matriz como parámetro y devuelve <code>true</code> si hay algún objeto que aparece más de una vez en la matriz.
</p>
</div>
<div class="paragraph">
<p>Use un diccionario para escribir una versión más rápida y simple de <code>repetido</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex11-5">Ejercicio 11-6</h4>
<div class="paragraph">
<p>Dos palabras son "pares desplazados" si puede desplazar una de ellas y obtener la otra (vea <code>desplazarpalabra</code> en <a href="#ex08-5">Exercise 8-11</a>).
</p>
</div>
<div class="paragraph">
<p>Escriba un programa que lea una matriz de palabras y encuentre todos los pares desplazados.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex11-6">Ejercicio 11-7</h4>
<div class="paragraph">
<p>Aquí hay otro Puzzle de Car Talk (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>This was sent in by a fellow named Dan O’Leary. He came upon a common one-syllable, five-letter word recently that has the following unique property. When you remove the first letter, the remaining letters form a homophone of the original word, that is a word that sounds exactly the same. Replace the first letter, that is, put it back and remove the second letter and the result is yet another homophone of the original word. And the question is, what’s the word?</p>
</div>
<div class="paragraph">
<p>Now I’m going to give you an example that doesn’t work. Let’s look at the five-letter word, ‘wrack.’ W-R-A-C-K, you know like to ‘wrack with pain.’ If I remove the first letter, I am left with a four-letter word, ’R-A-C-K.’ As in, ‘Holy cow, did you see the rack on that buck! It must have been a nine-pointer!’ It’s a perfect homophone. If you put the ‘w’ back, and remove the ‘r,’ instead, you’re left with the word, ‘wack,’ which is a real word, it’s just not a homophone of the other two words.</p>
</div>
<div class="paragraph">
<p>But there is, however, at least one word that Dan and we know of, which will yield two homophones if you remove either of the first two letters to make two, new four-letter words. The question is, what’s the word?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>You can use the dictionary from <a href="#ex11-1">Ejercicio 11-2</a> to check whether a string is in the word array.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>To check whether two words are homophones, you can use the CMU Pronouncing Dictionary. You can download it from <a href="http://www.speech.cs.cmu.edu/cgi-bin/cmudict" class="bare">http://www.speech.cs.cmu.edu/cgi-bin/cmudict</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Write a program that lists all the words that solve the Puzzler.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap12">12. Tuplas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo presenta otro tipo integrado; las tuplas, y luego muestra cómo los arreglos, los diccionarios y las tuplas funcionan en conjunto. También se presenta una característica útil para los arreglos de longitud variable como argumento: los operadores de recopilación y dispersión.</p>
</div>
<div class="sect2">
<h3 id="_las_tuplas_son_immutables">Las Tuplas son Immutables</h3>
<div class="paragraph">
<p>Una tupla es una secuencia de valores. Los valores pueden ser de cualquier tipo, y están indexados por enteros, por lo que las tuplas son muy parecidas a los arreglos. La diferencia más importante es que las tuplas son inmutables y que cada elemento puede tener su propio tipo.
</p>
</div>
<div class="paragraph">
<p>Una tupla es una lista de valores separados por comas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = 'a', 'b', 'c', 'd', 'e'
('a', 'b', 'c', 'd', 'e')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aunque no es necesario, es común encerrar las tuplas entre paréntesis:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ('a', 'b', 'c', 'd', 'e')
('a', 'b', 'c', 'd', 'e')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para crear una tupla con un solo elemento, se debe incluir una coma final:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t1 = ('a',)
('a',)
julia&gt; typeof(t1)
Tuple{Char}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>Un valor entre paréntesis sin coma no es una tupla:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t2 = ('a')
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia&gt; typeof(t2)
Char</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Otra forma de crear una tupla es la función de tupla integrada en Julia. Sin argumento, esta función crea una tupla vacía:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; tuple()
()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si se tienen múltiples argumentos, el resultado es una tupla con los argumentos dados:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t3 = tuple(1, 'a', pi)
(1, 'a', π)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ya que tuple es el nombre de una función integrada, debe evitar usarla como nombre de variable.</p>
</div>
<div class="paragraph">
<p>La mayoría de los operadores de arreglos también sirven en las tuplas. El operador corchete indexa un elemento:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ('a', 'b', 'c', 'd', 'e');

julia&gt; t[1]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Y el operador porción selecciona un rango de elementos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t[2:4]
('b', 'c', 'd')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pero si se intenta modificar uno de los elementos de la tupla, se obtendrá un error:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t[1] = 'A'
ERROR: MethodError: no method matching setindex!(::NTuple{5,Char}, ::Char, ::Int64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como las tuplas son inmutables, sus elementos no se pueden modificar.</p>
</div>
<div class="paragraph">
<p>Los operadores relacionales funcionan con las tuplas y otras secuencias; Julia comienza comparando el primer elemento de cada secuencia. Si son iguales, pasa a los siguientes elementos, y así sucesivamente, hasta que encuentra elementos que difieren. Los elementos posteriores no se consideran (incluso si son realmente grandes).
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; (0, 1, 2) &lt; (0, 3, 4)
true
julia&gt; (0, 1, 2000000) &lt; (0, 3, 4)
true</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_asignación_de_tupla">Asignación de tupla</h3>
<div class="paragraph">
<p>De vez en cuando, es útil intercambiar los valores de dos variables. Para hacerlo con sentencias de asignación convencionales debemos usar una variable temporal. Por ejemplo, para intercambiar a y b:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">temp = a
a = b
b = temp</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta solución resulta aparatosa. La asignación de tuplas soluciona este problema elegantemente:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">a, b = b, a</code></pre>
</div>
</div>
<div class="paragraph">
<p>El lado izquierdo es una tupla de variables; el lado derecho es una tupla de expresiones. Cada valor se asigna a su respectiva variable. Todas las expresiones del lado derecho se evalúan antes de las asignaciones.</p>
</div>
<div class="paragraph">
<p>El número de variables de la izquierda tiene que ser menor o igual que el número de valores a la derecha:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; (a, b) = (1, 2, 3)
(1, 2, 3)
julia&gt; a, b, c = 1, 2
ERROR: BoundsError: attempt to access (1, 2)
  at index [3]</code></pre>
</div>
</div>
<div class="paragraph">
<p>El lado derecho puede ser cualquier tipo de secuencia (cadena, arreglo o tupla). Por ejemplo, para dividir una dirección de correo electrónico en nombre de usuario y dominio, se puede escribir:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; addr = "julio.cesar@roma"
"julio.cesar@roma"
julia&gt; unombre, dominio = split(addr, '@');</code></pre>
</div>
</div>
<div class="paragraph">
<p>El valor de retorno de <code>split</code> es un arreglo con dos elementos; el primer elemento se asigna a <code>unombre</code>, y el segundo a <code>dominio</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; unombre
"julio.cesar"
julia&gt; dominio
"roma"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tuplas_como_valor_de_retorno">Tuplas como valor de retorno</h3>
<div class="paragraph">
<p>Estrictamente hablando, una función solo puede devolver un valor, pero si el valor es una tupla, el efecto es el mismo que devolver múltiples valores. Por ejemplo, si desea dividir dos enteros y calcular el cociente y el resto, es ineficiente calcular <code>x ÷ y</code> y luego <code>x % y</code>. Es mejor calcular ambos al mismo tiempo.
</p>
</div>
<div class="paragraph">
<p>La función integrada <code>divrem</code> toma dos argumentos y devuelve una tupla de dos valores: el cociente y el resto. El resultado puede ser almacenado como una tupla:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = divrem(7, 3)
(2, 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>También se puede utilizar asignación de tuplas para almacenar los elementos por separado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; q, r = divrem(7, 3);

julia&gt; @show q r;
q = 2
r = 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aquí hay un ejemplo de una función que devuelve una tupla:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function minmax(t)
    minimum(t), maximum(t)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>maximum</code> y <code>minimum</code> son funciones integradas que encuentran los elementos más grandes y más pequeños de una secuencia, respectivamente. La función <code>minmax</code> calcula ambos y devuelve una tupla de dos valores. Otra alternativa es utilizar la función integrada <code>extrema</code>, lo cual es más eficiente.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_tupla_con_argumentos_de_longitud_variable">Tupla con Argumentos de Longitud Variable</h3>
<div class="paragraph">
<p>Las funciones pueden tomar un número variable de argumentos. Un nombre de parámetro que termina con <code>...</code> <em>recopila</em> argumentos en una tupla. Por ejemplo, <code>imprimirtodo</code> toma cualquier número de argumentos y los imprime:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimirtodo(args...)
    println(args)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El parámetro de recopilación puede tener cualquier nombre, pero la convención es llamarlo <code>args</code>. A continuación se muestra cómo funciona la función:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; imprimirtodo(1, 2.0, '3')
(1, 2.0, '3')</code></pre>
</div>
</div>
<div class="paragraph">
<p>El opuesto de la recopilación es la <em>dispersión</em>. Si tiene una secuencia de valores y desea pasarla a una función como argumento múltiple, puede usar el operador <code>...</code> . Por ejemplo, <code>divrem</code> toma exactamente dos argumentos; no funciona con tuplas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = (7, 3);

julia&gt; divrem(t)
ERROR: MethodError: no method matching divrem(::Tuple{Int64,Int64})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pero si "dispersamos" la tupla, funciona:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; divrem(t...)
(2, 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Muchas de las funciones integradas usan tuplas con argumentos de longitud variable. Por ejemplo, <code>max</code> y <code>min</code> pueden tomar cualquier número de argumentos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; max(1, 2, 3)
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pero <code>sum</code> no:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; sum(1, 2, 3)
ERROR: MethodError: no method matching sum(::Int64, ::Int64, ::Int64)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicio_12_1">Ejercicio 12-1</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>sumartodo</code> que tome cualquier número de argumentos y devuelva su suma.
</p>
</div>
<div class="paragraph">
<p>En el mundo de Julia, generalmente se le llama “slurp” ("sorber" en español) a reunir y "splat" ("plaf" en español, como el ruido cuando cae algo) a dispersar.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arreglos_y_tuplas">Arreglos y tuplas</h3>
<div class="paragraph">
<p><code>zip</code> es una función integrada que toma dos o más secuencias y devuelve una colección de tuplas donde cada tupla contiene un elemento de cada secuencia. El nombre de la función se refiere a una cremallera, que une e intercala dos filas de dientes.
</p>
</div>
<div class="paragraph">
<p>Este ejemplo une e intercala una cadena y un arreglo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; s = "abc";

julia&gt; t = [1, 2, 3];

julia&gt; zip(s, t)
Base.Iterators.Zip{Tuple{String,Array{Int64,1}}}(("abc", [1, 2, 3]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado es un <em>objeto zip</em> que permite iterar a través de los pares. El uso más común de <code>zip</code> es en un bucle <code>for</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; for par in zip(s, t)
           println(par)
       end
('a', 1)
('b', 2)
('c', 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un objeto zip es un tipo de <em>iterador</em>, que es cualquier objeto que itera a través de una secuencia. Los iteradores son, de cierto modo, similares a los arreglos, pero a diferencia de los arreglos, no se puede usar un índice para seleccionar un elemento de un iterador.
</p>
</div>
<div class="paragraph">
<p>Si desea usar operadores y funciones de arreglos, puedes usar un objeto zip para hacer un arreglo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; collect(zip(s, t))
3-element Array{Tuple{Char,Int64},1}:
 ('a', 1)
 ('b', 2)
 ('c', 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado es una serie de tuplas; en este ejemplo, cada tupla contiene un carácter de la cadena y el elemento correspondiente del arreglo.</p>
</div>
<div class="paragraph">
<p>Si las secuencias no tienen el mismo largo, el resultado tiene el largo de la más corta.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; collect(zip("Juan", "Gabriel"))
4-element Array{Tuple{Char,Char},1}:
 ('J', 'G')
 ('u', 'a')
 ('a', 'b')
 ('n', 'r')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se puede usar asignación de tuplas en un bucle <code>for</code> para recorrer un arreglo de tuplas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [('a', 1), ('b', 2), ('c', 3)];

julia&gt; for (letra, numero) in t
           println(numero, " ", letra)
       end
1 a
2 b
3 c</code></pre>
</div>
</div>
<div class="paragraph">
<p>En cada iteración del ciclo, Julia selecciona la siguiente tupla en el arreglo y asigna estos elementos a letra y número. Los paréntesis de <code>(letra, número)</code> son obligatorios.
</p>
</div>
<div class="paragraph">
<p>Si combinamos <code>zip</code>, <code>for</code> y asignación de tuplas, tendremos una forma para recorrer dos (o más) secuencias al mismo tiempo. Por ejemplo, la función <code>coinciden</code> toma dos secuencias, <code>t1</code> y <code>t2</code>, y devuelve <code>true</code> si hay un índice <code>i</code> tal que <code>t1[i] == t2[i]</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function coinciden(t1, t2)
    for (x, y) in zip(t1, t2)
        if x == y
            return true
        end
    end
    false
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si se necesita recorrer los elementos de una secuencia y sus índices, se puede usar la función integrada <code>enumerate</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; for (indice, elemento) in enumerate("abc")
           println(indice, " ", elemento)
       end
1 a
2 b
3 c</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado de <code>enumerate</code> es un objeto enumerate, el cual hace una iteración sobre una secuencia de pares, donde cada par contiene un índice (a partir de 1) y un elemento de la secuencia dada.</p>
</div>
</div>
<div class="sect2">
<h3 id="_diccionarios_y_tuplas">Diccionarios y Tuplas</h3>
<div class="paragraph">
<p>Los diccionarios se pueden usar como iteradores que iteran sobre los pares clave-valor. Puede usarlos en un bucle <code>for</code> como este:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; d = Dict('a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3);

julia&gt; for (key, value) in d
           println(key, " ", value)
       end
a 1
c 3
b 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como es de esperar, en un diccionario los elementos no están en un orden particular.</p>
</div>
<div class="paragraph">
<p>Ahora, si queremos hacer lo contrario, podemos usar una serie de tuplas para inicializar un nuevo diccionario:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = [('a', 1), ('c', 3), ('b', 2)];

julia&gt; d = Dict(t)
Dict{Char,Int64} with 3 entries:
  'a' =&gt; 1
  'c' =&gt; 3
  'b' =&gt; 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Al combinar <code>Dict</code> con <code>zip</code>, podemos crear un diccionario de una manera muy simple:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; d = Dict(zip("abc", 1:3))
Dict{Char,Int64} with 3 entries:
  'a' =&gt; 1
  'c' =&gt; 3
  'b' =&gt; 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Es común usar tuplas como claves en los diccionarios. Por ejemplo, un directorio telefónico puede asignar números de teléfono a una tupla con apellido y nombre. Suponiendo que hemos definido <code>apellido</code>, <code>nombre</code> y <code>numero</code>, podríamos escribir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">directorio[apellido, nombre] = numero</code></pre>
</div>
</div>
<div class="paragraph">
<p>La expresión entre paréntesis es una tupla. Podríamos usar asignación de tuplas para recorrer este diccionario.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for ((apellido, nombre), numero) in directorio
    println(nombre, " ", apellido, " ", numero)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este bucle recorre los pares clave-valor en <code>directorio</code>, los cuales son tuplas. Asigna los elementos de la clave de cada tupla a <code>apellido</code> y <code>nombre</code>, y el valor a <code>numero</code>, luego imprime el nombre y el número de teléfono correspondiente.</p>
</div>
<div class="paragraph">
<p>Hay dos formas de representar tuplas en un diagrama de estado. La versión más detallada muestra los índices y elementos tal como aparecen en un arreglo. Por ejemplo, la tupla <code>("Cortázar", "Julio")</code> se vería como en <a href="#fig12-1">State diagram</a>.
</p>
</div>
<div id="fig12-1" class="imageblock">
<div class="content">
<img src="images/fig121.svg" alt="fig121">
</div>
<div class="title">Figura 18. State diagram</div>
</div>
<div class="paragraph">
<p>Pero en un diagrama más grande, es posible que desee omitir algunos detalles. Por ejemplo, un diagrama del directorio telefónico puede verse como en <a href="#fig12-2">State diagram</a>.
</p>
</div>
<div id="fig12-2" class="imageblock">
<div class="content">
<img src="images/fig122.svg" alt="fig122">
</div>
<div class="title">Figura 19. State diagram</div>
</div>
<div class="paragraph">
<p>Aquí las tuplas se muestran usando la sintaxis de Julia para tener un esquema más simple. El número de teléfono del diagrama es el número de reclamos de la BBC, así que no intentes llamar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_secuencias_de_secuencias">Secuencias de Secuencias</h3>
<div class="paragraph">
<p>Nos hemos centrado en los arreglos de tuplas, pero casi todos los ejemplos de este capítulo también funcionan con arreglos de arreglos, tuplas de tuplas y tuplas de arreglos. Para evitar enumerar todas las posibles combinaciones, a veces es más fácil hablar sobre secuencias de secuencias.
</p>
</div>
<div class="paragraph">
<p>En muchos contextos, los diferentes tipos de secuencias (cadenas, arreglos y tuplas) se pueden usar indistintamente. Entonces, ¿cómo elegir uno u otro?
</p>
</div>
<div class="paragraph">
<p>Para comenzar con lo mas obvio, las cadenas son más limitadas que las demás secuencias, porque los elementos deben ser caracteres. Además son inmutables. Si necesitas poder cambiar los caracteres en una cadena (en vez de crear una nueva), puede que lo mas adecuado sea elegir un arreglo de caracteres.
</p>
</div>
<div class="paragraph">
<p>Los arreglos se usan con mas frecuencia que las tuplas, principalmente porque son mutables. Pero hay algunos casos donde es posible que prefieras usar tuplas:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En algunos contextos, como en una sentencia return, resulta sintácticamente más simple crear una tupla que un arreglo.</p>
</li>
<li>
<p>Si estas pasando una secuencia como argumento de una función, el uso de tuplas reduce los comportamientos potencialmente indeseados debido a la creacion de alias.
</p>
</li>
<li>
<p>Por rendimiento. El compilador puede especializarse en este tipo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Dado que las tuplas son inmutables, no tienen funciones como <code>sort!</code> y <code>reverse!</code>, que modifiquen arreglos ya existentes. Sin embargo, Julia proporciona las funciones integradas <code>sort</code>, que toma un arreglo y devuelve una secuencia nueva con los mismos elementos ordenados, y <code>reverse</code>, que toma cualquier secuencia y devuelve una secuencia nueva del mismo tipo con los mismos elementos en el orden contrario.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_10">Depuración</h3>
<div class="paragraph">
<p>Los arreglos, diccionarios y tuplas son ejemplos de <em>estructuras de datos</em>; en este capítulo estamos comenzando a ver estructuras de datos compuestas, como arreglos o tuplas, y diccionarios que contienen tuplas como claves y arreglos como valores. Las estructuras de datos compuestas son utiles, pero también resultan propensas a lo que yo llamo <em>errores de forma</em>; es decir, errores causados cuando una estructura de datos tiene el tipo, tamaño o estructura incorrecta. Por ejemplo, si estás esperando una lista con un entero y te paso simplemente un entero (no en una lista), no funcionará.
</p>
</div>
<div class="paragraph">
<p>Julia permite añadir el tipo a elementos de una secuencia. Esto se detalla en <a href="#chap17">Dispatch Múltiple</a>. Especificar el tipo elimina muchos errores de forma.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_11">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">tupla</dt>
<dd>
<p>Una secuencia inmutable de elementos donde cada elemento puede tener su propio tipo.
</p>
</dd>
<dt class="hdlist1">asignación en tupla</dt>
<dd>
<p>Una asignacion con una secuencia en el lado derecho y una tupla de variables en el izquierdo. Primero se evalua el lado derecho y luego sus elementos son asignados a las variables de la izquierda.
</p>
</dd>
<dt class="hdlist1">reunir</dt>
<dd>
<p>La operacion de armar una tupla con argumentos de longitud variable.
</p>
</dd>
<dt class="hdlist1">dispersar</dt>
<dd>
<p>La operacion de tratar una secuencia como una lista de argumentos.
</p>
</dd>
<dt class="hdlist1">objeto zip</dt>
<dd>
<p>El resultado de llamar a la función integrada <code>zip</code>; un objeto que itera a través de una secuencia de tuplas.
</p>
</dd>
<dt class="hdlist1">iterador</dt>
<dd>
<p>Un objeto que puede iterar a través de una secuencia, pero que no tiene los operadores y funciones de arreglos.
</p>
</dd>
<dt class="hdlist1">estructura de datos</dt>
<dd>
<p>Una coleccion de valores relacionados, a menudo organizados en arreglos, diccionarios, tuplas, etc.
</p>
</dd>
<dt class="hdlist1">error de forma</dt>
<dd>
<p>Un error causado porque un valor tiene la forma incorrecta; es decir, el tipo o tamaño incorrecto.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_14">Ejercicios</h3>
<div class="sect3">
<h4 id="ex12-1">Ejercicio 12-2</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>masfrecuente</code> que tome una cadena e imprima las letras en orden decreciente de frecuencia. Encuentre muestras de texto de varios idiomas diferentes y vea cómo la frecuencia de las letras varía entre idiomas. Compare sus resultados con las tablas en <a href="https://en.wikipedia.org/wiki/Letter_frequencies" class="bare">https://en.wikipedia.org/wiki/Letter_frequencies</a>.
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex12-2">Ejercicio 12-3</h4>
<div class="paragraph">
<p>¡Más anagramas!</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escriba un programa que lea una lista de palabras de un archivo (vea <a href="#reading_word_lists">Leer listas de palabras</a>) e imprima todos los conjuntos de palabras que son anagramas.</p>
<div class="paragraph">
<p>Aquí hay un ejemplo de cómo se vería la salida:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">["brazo", "zobra", "broza", "zarbo"]
["palabra", "parlaba"]
["vida", "diva"]
["gato", "toga", "gota"]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Es posible que desee crear un diccionario que asigne a una colección de letras una serie de palabras que se puedan deletrear con esas letras. La pregunta es, ¿cómo representar la colección de letras de una manera que pueda usarse como clave?</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Modifique el programa anterior para que imprima primero el arreglo más largo de anagramas, seguida de la segunda más larga, y así sucesivamente.</p>
</li>
<li>
<p>En Scrabble, un "bingo" es cuando juegas las siete fichas de tu atril, junto con una letra del tablero, para formar una palabra de ocho letras. ¿Qué colección de 8 letras forman parte del bingo más probable?</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="ex12-3">Ejercicio 12-4</h4>
<div class="paragraph">
<p>Dos palabras metatizan si se puede transformar una en la otra intercambiando dos letras; por ejemplo, "conversar" y "conservar". Escriba un programa que encuentre todos los pares de metátesis en el diccionario.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>No pruebe con todos los pares de palabras, ni tampoco con todos los intercambios posibles.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Créditos: Este ejercicio está inspirado en un ejemplo de <a href="http://puzzlers.org" class="bare">http://puzzlers.org</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex12-4">Ejercicio 12-5</h4>
<div class="paragraph">
<p>Aquí hay otro Puzzle de Car Talk (<a href="https://www.cartalk.com/puzzler/browse" class="bare">https://www.cartalk.com/puzzler/browse</a>):
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>¿Cuál es la palabra en español más larga, que sigue siendo una palabra en español válida a medida que se eliminan sus letras una a una?</p>
</div>
<div class="paragraph">
<p>Las letras se pueden eliminar de cualquier extremo o del medio, pero no se puede reordenar ninguna de ellas. Cada vez que eliminas una letra, te quedas con otra palabra en español. Eventualmente terminarás con una letra, la cual también será una palabra en español que puedes encontrar en el diccionario. Se desea saber cuál es la palabra más larga y cuántas letras tiene.</p>
</div>
<div class="paragraph">
<p>A modo de ejemplo, pensemos en la palabra: Palote. ¿De acuerdo? Comienzas con palote, eliminas la letra p y queda alote, luego quitamos la t y nos quedamos con aloe, tomamos la e y tenemos alo, quitando la o tenemos al, y finalmente, eliminando la l nos queda a.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Escriba un programa que encuentre todas las palabras que se pueden reducir de esta manera, y luego encuentre la más larga.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Este ejercicio es un poco más desafiante que el resto, así que aquí hay algunas sugerencias:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Es posible que quieras escribir una función que tome una palabra y calcule un arreglo de todas las palabras que se pueden formar al eliminar una letra. Estos son los "hijos" de la palabra.</p>
</li>
<li>
<p>De manera recursiva, una palabra es reducible si alguno de sus hijos es reducible. Como caso base, puede considerar la cadena vacía reducible.
</p>
</li>
<li>
<p>La lista de palabras <em>palabras.txt</em> no tiene la cadena vacía, por lo que tendrás que agregarla.</p>
</li>
<li>
<p>Para mejorar el rendimiento de su programa, es posible que desee guardar las palabras que se sabe que son reducibles.
</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap13">13. Estudio de Caso: Selección de Estructura de Datos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hasta ahora hemos aprendido sobre las principales estructuras de datos de Julia y hemos visto algunos de los algoritmos que las utilizan.</p>
</div>
<div class="paragraph">
<p>Este capítulo presenta un estudio de caso con ejercicios que le permiten practicar la elección de estructuras de datos y su uso.</p>
</div>
<div class="sect2">
<h3 id="_análisis_de_frecuencia_de_palabras">Análisis de Frecuencia de Palabras</h3>
<div class="paragraph">
<p>Como de costumbre, se recomienda intentar resolver los ejercicios antes de leer las soluciones.</p>
</div>
<div class="sect3">
<h4 id="ex13-1">Ejercicio 13-1</h4>
<div class="paragraph">
<p>Escriba un programa que lea un archivo, divida cada línea en palabras, elimine el espacio en blanco y la puntuación de las palabras, y luego las convierta en minúsculas.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>La función <code>isletter</code> permite saber si un carácter pertenece al alfabeto.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ex13-2">Ejercicio 13-2</h4>
<div class="paragraph">
<p>Vaya a la página de Proyecto Gutenberg (<a href="https://gutenberg.org" class="bare">https://gutenberg.org</a>) y descargue su libro favorito sin derechos de autor en formato de texto plano. La mayoría de los libros están en inglés, pero existen algunos en español.
</p>
</div>
<div class="paragraph">
<p>Modifique su programa del ejercicio anterior para leer el libro que descargó, omita la información del encabezado al comienzo del archivo y procese el resto de las palabras tal como en el ejercicio previo.</p>
</div>
<div class="paragraph">
<p>Luego, modifique el programa para contar la cantidad total de palabras en el libro y la cantidad de veces que se usa cada palabra.</p>
</div>
<div class="paragraph">
<p>Imprima la cantidad de palabras diferentes que se usan en el libro. Compare diferentes libros de diferentes autores, escritos en diferentes épocas. ¿Qué autor usa el vocabulario más extenso?</p>
</div>
</div>
<div class="sect3">
<h4 id="ex13-3">Ejercicio 13-3</h4>
<div class="paragraph">
<p>Modifique el programa del ejercicio anterior para imprimir las 20 palabras más utilizadas en el libro.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex13-4">Ejercicio 13-4</h4>
<div class="paragraph">
<p>Modifique el programa anterior para que lea una lista de palabras y luego imprima todas las palabras del libro que no estén en la lista de palabras. ¿Cuántos de ellos son errores tipográficos? ¿Cuántos de ellos son palabras comunes que deberían estar en la lista de palabras, y cuántos de ellos son términos realmente macabros?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_números_aleatorios">Números aleatorios</h3>
<div class="paragraph">
<p>Dadas las mismas entradas, la mayor parte de los programas generan la misma salida cada vez que los ejecutamos, por lo que se dice que son deterministas. Normalmente el determinismo es algo bueno, ya que esperamos que un cálculo nos entregue siempre el mismo resultado. Para algunas aplicaciones, sin embargo, queremos que el computador sea impredecible. Por ejemplo en los juegos, pero hay otros casos.
</p>
</div>
<div class="paragraph">
<p>Hacer que un programa sea realmente no determinista resulta difícil, pero hay formas de que al menos parezca no determinista. Una de ellas es usar algoritmos para generar números <em>pseudoaleatorios</em>. Los números pseudoaleatorios no son verdaderamente aleatorios porque se generan mediante un cálculo determinista, pero al mirar estos números es casi imposible distinguirlos de lo aleatorio.
</p>
</div>
<div class="paragraph">
<p>La función <code>rand</code> devuelve un numero de punto flotante entre <code>0.0</code> y <code>1.0</code> (incluyendo 0.0 pero no 1.0). Cada vez que usted llama a <code>rand</code> obtiene el siguiente numero de una larga serie. Para ver un ejemplo, ejecute este bucle:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for i in 1:10
    x = rand()
    println(x)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>rand</code> puede tomar un iterador o arreglo como argumento y devuelve un elemento aleatorio de ellos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for i in 1:10
    x = rand(1:6)
    print(x, " ")
end</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="ex13-5">Ejercicio 13-5</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>escogerdelhistograma</code> que tome un histograma definido como en <a href="#dictionary_collection_counters">Diccionario como una Colección de Frecuencias</a> y devuelva un valor aleatorio del histograma, elegido con probabilidad proporcional a la frecuencia. Por ejemplo, para este histograma:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ['a', 'a', 'b'];

julia&gt; histograma(t)
Dict{Any,Any} with 2 entries:
  'a' =&gt; 2
  'b' =&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>su función debe devolver <code>'a'</code> con probabilidad \(\frac{2}{3}\) y <code>'b'</code> con probabilidad \(\frac{1}{3}\).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_histograma_de_palabras">Histograma de Palabras</h3>
<div class="paragraph">
<p>Debes hacer los ejercicios anteriores antes de continuar. También necesitarás <a href="https://github.com/PiensaEnJulia/PiensaEnJulia.jl/blob/master/data/DonQuijote.txt" class="bare">https://github.com/PiensaEnJulia/PiensaEnJulia.jl/blob/master/data/DonQuijote.txt</a>.</p>
</div>
<div class="paragraph">
<p>Aquí hay un programa que lee un archivo y construye un histograma de las palabras en el archivo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function procesararchivo(nombrearchivo)
    hist = Dict()
    for linea in eachline(nombrearchivo)
        procesarlinea(linea, hist)
    end
    hist
end;

function procesarlinea(linea, hist)
    linea = replace(linea, '-' =&gt; ' ')
    for palabra in split(linea)
        palabra = string(filter(isletter, [palabra...])...)
        palabra = lowercase(palabra)
        hist[palabra] = get!(hist, palabra, 0) + 1
    end
end;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">hist = procesararchivo("DonQuijote.txt");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este programa lee <em>DonQuijote.txt</em>, que contiene el texto de <em>Don Quijote</em> de Miguel de Cervantes.
</p>
</div>
<div class="paragraph">
<p><code>procesararchivo</code> recorre las líneas del archivo, pasando una línea a la vez a <code>procesarlinea</code>. El histograma <code>hist</code> se está utilizando como acumulador.
</p>
</div>
<div class="paragraph">
<p><code>procesarlinea</code> usa la función <code>replace</code> para reemplazar los guiones por espacios antes de usar <code>split</code> para dividir la línea en un arreglo de cadenas. Recorre el conjunto de palabras y usa <code>filter</code>, <code>isletter</code> y <code>lowercase</code> para eliminar los signos de puntuación y convertir las palabras a minúsculas. (Decir que las cadenas se "convierten" es incorrecto; recuerde que las cadenas son inmutables, por lo que una función como <code>lowercase</code> devuelve cadenas nuevas).
</p>
</div>
<div class="paragraph">
<p>Finalmente, <code>procesarlinea</code> actualiza el histograma creando un nuevo elemento o incrementando uno existente.</p>
</div>
<div class="paragraph">
<p>Para contar el número total de palabras en el archivo, podemos sumar las frecuencias en el histograma:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function palabrastotales(hist)
    sum(values(hist))
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El número de palabras diferentes es el número de elementos en el diccionario:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function palabrasdiferentes(hist)
    length(hist)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para imprimir los resultados se puede usar el siguiente código:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; println("Número total de palabras: ", palabrastotales(hist))
Número total de palabras: 385925

julia&gt; println("Número de palabras diferentes: ", palabrasdiferentes(hist))
Número de palabras diferentes: 23607</code></pre>
</div>
</div>
<div class="paragraph">
<p>Observación: No se considera el encabezado del archivo de texto, sólo el libro.</p>
</div>
</div>
<div class="sect2">
<h3 id="_palabras_más_comunes">Palabras Más Comunes</h3>
<div class="paragraph">
<p>Para encontrar las palabras más comunes, podemos hacer un arreglo de tuplas, donde cada tupla contiene una palabra y su frecuencia, y ordenarla. La siguiente función toma un histograma y devuelve un arreglo de tuplas de frecuencia de palabras:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function mascomun(hist)
    t = []
    for (clave, valor) in hist
        push!(t, (valor,clave))
    end
    reverse(sort(t))
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>En cada tupla, la frecuencia aparece primero, por lo que el arreglo resultante se ordena por frecuencia. A continuación se muestra un bucle que imprime las 10 palabras más comunes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">t = mascomun(hist)
println("Las palabras más comunes son:")
for (frec, palabra) in t[1:10]
    println(palabra, "\t", frec)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo utilizamos un carácter de tabulación (<code>'\t'</code>) como "separador", en vez de un espacio, por lo que la segunda columna está alineada. A continuación se muestran los resultados de <em>Don Quijote</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Las palabras más comunes son:
que	20626
de	18217
y	18188
la	10363
a	9881
en	8241
el	8210
no	6345
los	4748
se	4690</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Este código se puede simplificar usando como argumento la palabra reservada <code>rev</code> de la función <code>sort</code>. Puede leer sobre esto en <a href="https://docs.julialang.org/en/v1/base/sort/#Base.sort" class="bare">https://docs.julialang.org/en/v1/base/sort/#Base.sort</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parametros_opcionales">Parametros Opcionales</h3>
<div class="paragraph">
<p>Hemos visto funciones integradas de Julia que toman argumentos opcionales. También es posible escribir funciones definidas por el programador con argumentos opcionales. Por ejemplo, aquí hay una función que imprime las palabras más comunes en un histograma:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimirmascomun(hist, num=10)
    t = mascomun(hist)
    println("Las palabras más comunes son: ")
    for (frec, palabra) in t[1:num]
        println(palabra, "\t", frec)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El primer parámetro es obligatorio; el segundo es opcional. El <em>valor predeterminado</em> de <code>num</code> es <code>10</code>.
</p>
</div>
<div class="paragraph">
<p>Si solo pasas un argumento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">imprimirmascomun(hist)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>num</code> toma el valor predeterminado. Si pasas dos argumentos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">imprimirmascomun(hist, 20)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>num</code> toma el valor del argumento. En otras palabras, el argumento opcional <em>anula</em> el valor predeterminado.
</p>
</div>
<div class="paragraph">
<p>Si una función tiene parámetros obligatorios y opcionales, los parámetros obligatorios deben ir primero, seguidos de los opcionales.</p>
</div>
</div>
<div class="sect2">
<h3 id="dictionary_subtraction">Resta de Diccionario</h3>
<div class="paragraph">
<p>Encontrar las palabras de un libro que no están en la lista de palabras de <code>palabras.txt</code> es un problema similar a una resta de conjuntos; es decir, queremos encontrar todas las palabras de un conjunto (las palabras en el libro) que no están en el otro (las palabras en la lista).</p>
</div>
<div class="paragraph">
<p><code>resta</code> toma los diccionarios <code>d1</code> y <code>d2</code> y devuelve un nuevo diccionario que contiene todas las claves de <code>d1</code> que no están en <code>d2</code>. Como realmente no nos importan los valores, los fijamos como <code>nothing</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function resta(d1, d2)
    res = Dict()
    for clave in keys(d1)
        if clave ∉ keys(d2)
            res[clave] = nothing
        end
    end
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para encontrar las palabras en el libro que no están en <code>palabras.txt</code>, podemos usar <code>procesararchivo</code> para construir un histograma para <code>palabras.txt</code>, y luego la función <code>resta</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">palabras = procesararchivo("palabras.txt")
dif = resta(hist, palabras)

println("Palabras en el libro que no están en la lista de palabras:")
for palabra in keys(dif)
    print(palabra, " ")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Estos son algunos de los resultados de <em>Don Quijote</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Palabras en el libro que no están en la lista de palabras:
enojó angosta coronan sirviesen solene enderécese rescatarlos embotó estime renovaban ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Algunas de estas palabras son conjugaciones de verbos. Otros, como "solene", ya no son de uso común. ¡Pero algunas son palabras comunes que deberían estar en la lista!</p>
</div>
<div class="sect3">
<h4 id="ex13-6">Ejercicio 13-6</h4>
<div class="paragraph">
<p>Julia proporciona una estructura de datos llamada <code>Set</code> que proporciona muchas operaciones comunes de conjuntos. Puede leer sobre ellas en <a href="#collections_and_data_structures">Colecciones y Estructuras de Datos</a>, o leer la documentación en <a href="https://docs.julialang.org/en/v1/base/collections/#Set-Like-Collections-1" class="bare">https://docs.julialang.org/en/v1/base/collections/#Set-Like-Collections-1</a>.</p>
</div>
<div class="paragraph">
<p>Escriba un programa que use la resta de conjuntos para encontrar palabras en el libro que no están en la lista de palabras.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_palabras_al_azar">Palabras al Azar</h3>
<div class="paragraph">
<p>Para elegir una palabra aleatoria del histograma, el algoritmo más simple es construir un arreglo con múltiples copias de cada palabra, de acuerdo con la frecuencia observada, y luego elegir una palabra del arreglo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function palabraalazar(h)
    t = []
    for (palabra, frec) in h
        for i in 1:frec
            push!(t, palabra)
        end
    end
    rand(t)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este algoritmo funciona, pero no es muy eficiente; cada vez que elige una palabra aleatoria, reconstruye el arreglo, que es tan grande como el libro original. Una mejora es construir el arreglo una vez y luego hacer múltiples selecciones, pero el arreglo sigue siendo grande.</p>
</div>
<div class="paragraph">
<p>Una alternativa es:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use las <code>claves</code> para obtener un arreglo de palabras del libro.</p>
</li>
<li>
<p>Cree un arreglo que contenga la suma acumulada de las frecuencias de palabras (vea <a href="#ex10-2">Ejercicio 10-2</a>). El último elemento en este arreglo es el número total de palabras en el libro, \(n\).</p>
</li>
<li>
<p>Elija un número aleatorio del 1 al \(n\). Use búsqueda binaria (vea <a href="#ex10-10">Ejercicio 10-10</a>) para encontrar el índice donde se insertará el número aleatorio en la suma acumulada.
</p>
</li>
<li>
<p>Use el índice para encontrar la palabra correspondiente en el arreglo de palabras.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="ex13-7">Ejercicio 13-7</h4>
<div class="paragraph">
<p>Escriba un programa que use este algoritmo para elegir una palabra aleatoria del libro.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="markov_analysis">Análisis de Markov</h3>
<div class="paragraph">
<p>Si elige palabras del libro al azar, puedes tener una idea del vocabulario usado, pero probablemente no obtendremos una oración:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>rocinante pláticas sazón ojos Dulcinea Dios</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una serie de palabras aleatorias rara vez tiene sentido porque no hay relación entre palabras sucesivas. Por ejemplo, en una oración real, esperaría que un artículo como "el" sea seguido por un sustantivo, y probablemente no un verbo o un adverbio.</p>
</div>
<div class="paragraph">
<p>Una forma de medir este tipo de relaciones es con el análisis de Markov, que define para una secuencia dada de palabras, la probabilidad de las palabras que podrían venir después. Por ejemplo, en la canción <em>La vida es un carnaval</em> (de Celiz Cruz):
</p>
</div>
<div class="verseblock">
<pre class="content">Todo aquel
Que piense que la vida siempre es cruel
Tiene que saber que no es así
Que tan solo hay momentos malos
Y todo pasa

Todo aquel
Que piense que esto nunca va cambiar
Tiene que saber que no es así
Que al mal tiempo, buena cara
Y todo cambia

Ay, no hay que llorar (No hay que llorar)
Que la vida es un carnaval
Que es más bello vivir cantando</pre>
</div>
<div class="paragraph">
<p>En este texto, la frase "que piense" siempre va seguida de la palabra "que", pero la frase "piense que" puede ir seguida de "la" o "esto".</p>
</div>
<div class="paragraph">
<p>El resultado del análisis de Markov es un mapeo de cada prefijo (como "que piense" y "piense que") a todos los sufijos posibles (como "la" y "esto").
</p>
</div>
<div class="paragraph">
<p>Dada esta asignación, puede generar un texto aleatorio comenzando con cualquier prefijo y eligiendo aleatoriamente entre los posibles sufijos. A continuación, puede combinar el final del prefijo y el nuevo sufijo para formar el siguiente prefijo y repetir.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si comienza con el prefijo "Que la", la siguiente palabra será "vida", porque el prefijo solo aparece dos veces en el texto y siempre está seguido de este sufijo. El siguiente prefijo es "la vida", por lo que el siguiente sufijo podría ser "siempre" o "es".</p>
</div>
<div class="paragraph">
<p>En este ejemplo, la longitud del prefijo siempre es dos, pero puede hacer análisis de Markov con un prefijo de cualquier longitud.</p>
</div>
<div class="sect3">
<h4 id="ex13-8">Ejercicio 13-8</h4>
<div class="paragraph">
<p>Análisis de Markov:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escriba un programa que lea un texto desde un archivo y realice análisis de Markov. El resultado debe ser un diccionario que asocie prefijos y una colección de posibles sufijos. La colección puede ser un arreglo, tupla o diccionario; depende de usted hacer una elección adecuada. Puede probar su programa con una longitud de prefijo de dos, pero debe escribir el programa de manera tal que sea fácil probar con otras longitudes.</p>
</li>
<li>
<p>Agregue una función al programa anterior para generar texto aleatorio basado en análisis de Markov. Aquí hay un ejemplo de Don Quijote con longitud de prefijo 2:</p>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>"Trifaldi, había de Troya, ni por la majestad real. Y con mis quejas. Desechásteme ¡oh estremo su frío del agravio a la espada, teniéndola por aca y más que sólo se trueca y con el cual encendía el ejemplo de aquellos cazadores"</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Para este ejemplo, se dejó la puntuación anexa a las palabras. El resultado es casi sintácticamente correcto. Semánticamente, casi tiene sentido, pero no del todo.</p>
</div>
<div class="paragraph">
<p>¿Qué sucede si aumenta la longitud del prefijo? ¿El texto aleatorio tiene más sentido?</p>
</div>
</li>
<li>
<p>Una vez que su programa esté funcionando, podrías probar combinando texto de dos o más libros, el texto aleatorio que genere combinará el vocabulario y las frases de las fuentes de maneras interesantes.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Crédito: Este estudio de caso se basa en un ejemplo de Kernighan y Pike, The Practice of Programming, Addison-Wesley, 1999.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Debes hacer este ejercicio antes de continuar.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructuras_de_datos">Estructuras de Datos</h3>
<div class="paragraph">
<p>Usar análisis de Markov para generar texto aleatorio es divertido, pero además, este ejercicio tiene un trasfondo: la selección de la estructura de datos. En los los ejercicios anteriores, tenía que elegir:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cómo representar los prefijos.</p>
</li>
<li>
<p>Cómo representar la colección de los posibles sufijos.</p>
</li>
<li>
<p>Cómo representar la asociación de cada prefijo con la colección de posibles sufijos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El último es fácil: un diccionario es la opción obvia para una asociación entre claves y valores correspondientes.</p>
</div>
<div class="paragraph">
<p>Para los prefijos, las opciones más obvias son cadena, arreglo de cadenas o tupla de cadenas.</p>
</div>
<div class="paragraph">
<p>Para los sufijos, puede ser un arreglo o un histograma (diccionario).</p>
</div>
<div class="paragraph">
<p>¿Cómo se elige? El primer paso es pensar en las operaciones que deberá implementar para cada estructura de datos. Para los prefijos, debemos ser capaces de eliminar palabras del principio y agregarlas al final. Por ejemplo, si el prefijo actual es "que piense" y la siguiente palabra es "que", debe poder formar el siguiente prefijo, "piense que".</p>
</div>
<div class="paragraph">
<p>Para los prefijos, podría elegir un arreglo, ya que en él es fácil agregar y eliminar elementos.</p>
</div>
<div class="paragraph">
<p>Para la colección de sufijos, las operaciones que debemos realizar incluyen agregar un nuevo sufijo (o aumentar la frecuencia de uno existente) y elegir un sufijo aleatorio.</p>
</div>
<div class="paragraph">
<p>Agregar un nuevo sufijo es igualmente fácil para la implementación del arreglo o del histograma. Elegir un elemento aleatorio de un arreglo es fácil; elegir eficientemente de un histograma es más difícil (ver <a href="#ex13-7">Ejercicio 13-7</a>).</p>
</div>
<div class="paragraph">
<p>Hasta ahora hemos hablado principalmente sobre la facilidad de implementación, pero hay otros factores a considerar al elegir las estructuras de datos. Uno es el tiempo de ejecución. A veces hay una razón teórica para esperar que una estructura de datos sea más rápida que otra; por ejemplo, anteriormente se mencionó que el operador <code>in</code> es más rápido para los diccionarios que para los arreglos, al menos cuando el número de elementos es grande.</p>
</div>
<div class="paragraph">
<p>Pero generalmente no se sabe de antemano qué implementación será más rápida. Una opción es implementar ambos y ver cuál es mejor. Este enfoque se llama <em>benchmarking</em>. Una alternativa práctica es elegir la estructura de datos que sea más fácil de implementar y luego ver si es lo suficientemente rápida para la aplicación prevista. Si es así, no hay necesidad de continuar. Si no, hay herramientas, como el módulo <code>Profile</code>, que pueden identificar los lugares en un programa que toman más tiempo.
</p>
</div>
<div class="paragraph">
<p>El otro factor a considerar es el espacio de almacenamiento. Por ejemplo, usar un histograma para la colección de sufijos puede tomar menos espacio porque solo tiene que almacenar cada palabra una vez, sin importar cuántas veces aparezca en el texto. En algunos casos, ahorrar espacio también puede hacer que su programa se ejecute más rápido. En el peor de los casos, su programa podría no ejecutarse si se queda sin memoria. Pero para muchas aplicaciones, el espacio es una consideración secundaria después del tiempo de ejecución.</p>
</div>
<div class="paragraph">
<p>Una última reflexión: en esta discusión, he dado a entender que deberíamos usar una estructura de datos para el análisis y la generación. Pero dado que estas son fases separadas, también sería posible usar una estructura para el análisis y luego convertirla en otra estructura para la generación. Esto sería conveniente si el tiempo ahorrado durante la generación excede el tiempo dedicado a la conversión.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>El paquete de Julia <code>DataStructures</code> (ver <a href="https://github.com/JuliaCollections/DataStructures.jl" class="bare">https://github.com/JuliaCollections/DataStructures.jl</a>) implementa una variedad de estructuras de datos.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_11">Depuración</h3>
<div class="paragraph">
<p>Cuando está depurando un programa, y especialmente si está tratando de resolver un error difícil, hay cinco cosas que puede probar:
</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Lee</dt>
<dd>
<p>Examina tu código, léelo y verifica que dice lo que querías decir.</p>
</dd>
<dt class="hdlist1">Ejecuta</dt>
<dd>
<p>Experimente haciendo cambios y ejecutando diferentes versiones. A menudo, si muestra lo correcto en el lugar correcto del programa, el problema se vuelve obvio, pero para ello a veces tiene que desarrollar andamiaje.</p>
</dd>
<dt class="hdlist1">Reflexiona</dt>
<dd>
<p>¡Tómese un tiempo para pensar! ¿Qué tipo de error es: de sintaxis, tiempo de ejecución o semántica? ¿Qué información puede obtener de los mensajes de error o de la salida del programa? ¿Qué tipo de error podría causar el problema que estás viendo? ¿Qué cambió antes de que apareciera el problema?</p>
</dd>
<dt class="hdlist1">Habla</dt>
<dd>
<p>Si le explica el problema a otra persona, a veces puede encontrar la respuesta incluso antes de terminar de hacer la pregunta. Generalmente no necesitas a otra persona; incluso podrías hablar con un pato de goma. Este es el origen de la conocida estrategia llamada depuración del pato de goma. Esto es real, vea <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging" class="bare">https://en.wikipedia.org/wiki/Rubber_duck_debugging</a>.
</p>
</dd>
<dt class="hdlist1">Vuelve atrás</dt>
<dd>
<p>En ocasiones, lo mejor que puede hacer es retroceder, deshacer los cambios recientes, hasta regresar a un programa que funcione y que comprenda. Una vez logrado esto, puedes comenzar a reconstruir.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Los programadores principiantes a veces se atascan en una de estas actividades y olvidan las otras. Cada actividad viene con su propia forma de fallar.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, leer su código podría ayudar si el problema es un error tipográfico, pero no si el problema es un malentendido conceptual. Si no comprende lo que hace su programa, puede leerlo 100 veces y nunca ver el error, porque el error está en su cabeza.</p>
</div>
<div class="paragraph">
<p>Ejecutar experimentos puede ayudar, especialmente si ejecuta pruebas pequeñas y simples. Pero si ejecuta experimentos sin pensar o leer su código, puede caer en un patrón que llamo "programación de caminata aleatoria", que es el proceso de hacer cambios aleatorios hasta que el programa haga lo correcto. No hace falta decir que la programación de caminata aleatoria puede llevar mucho tiempo.
</p>
</div>
<div class="paragraph">
<p>Tienes que tomarte el tiempo para pensar. La depuración es como una ciencia experimental. Debes tener al menos una hipótesis sobre la causa del problema. Si hay dos o más opciones, trate de pensar en una prueba que elimine una de ellas.</p>
</div>
<div class="paragraph">
<p>Pero incluso las mejores técnicas de depuración fallarán si hay demasiados errores, o si el código que está tratando de corregir es demasiado grande y complicado. A veces, la mejor opción es volver atrás, simplificando el programa hasta que llegue a algo que funcione y que comprenda.</p>
</div>
<div class="paragraph">
<p>Los programadores principiantes a menudo son reacios a volver atrás porque no pueden soportar eliminar una línea de código (incluso si es incorrecto). Si te hace sentir mejor, copia tu programa en otro archivo antes de comenzar a eliminarlo. Luego puedes copiar las piezas una por una.</p>
</div>
<div class="paragraph">
<p>Encontrar un error difícil requiere leer, ejecutar, reflexionar y, a veces, volver atrás. Si te quedas atascado en una de estas actividades, prueba las otras.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_12">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">determinístico</dt>
<dd>
<p>Perteneciente a un programa que hace lo mismo cada vez que se ejecuta, a partir de las mismas entradas.
</p>
</dd>
<dt class="hdlist1">pseudoaleatorio</dt>
<dd>
<p>Perteneciente a una secuencia de números que parecen ser aleatorios, pero son generados por un programa determinista.
</p>
</dd>
<dt class="hdlist1">valor por defecto (o valor por omisión)</dt>
<dd>
<p>El valor dado a un parámetro opcional si no se proporciona un argumento.
</p>
</dd>
<dt class="hdlist1">anular</dt>
<dd>
<p>Reemplazar un valor por defecto con un argumento.
</p>
</dd>
<dt class="hdlist1">benchmarking</dt>
<dd>
<p>El proceso de elegir entre estructuras de datos implementando alternativas y probándolas con una muestra de las posibles entradas.
</p>
</dd>
<dt class="hdlist1">depuración del pato de goma</dt>
<dd>
<p>Depuración en dónde se explica el problema a un objeto inanimado, tal como un pato de goma. Articular el problema puede ayudarte a resolverlo, incluso si el pato de goma no sabe de Julia.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_15">Ejercicios</h3>
<div class="sect3">
<h4 id="ex13-9">Ejercicio 13-9</h4>
<div class="paragraph">
<p>El "rango" de una palabra es su posición en un arreglo de palabras ordenadas por frecuencia: la palabra más común tiene rango 1, la segunda más común tiene rango 2, etc.</p>
</div>
<div class="paragraph">
<p>La ley de Zipf describe una relación entre los rangos y las frecuencias de las palabras en idiomas naturales (<a href="https://en.wikipedia.org/wiki/Zipf&apos;s_law" class="bare">https://en.wikipedia.org/wiki/Zipf&apos;s_law</a>). Específicamente, predice que la frecuencia, \(f\), de la palabra con rango \(r\) es:
</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{f = c r^{-s}}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>donde \(s\) y \(c\) son parámetros que dependen del idioma y el texto. Si aplicas logaritmo a ambos lados de esta ecuación, obtienes:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{\log f = \log c - s \log r}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Entonces, si graficas \(\log f\) versus \(\log r\), debería obtener una línea recta con pendiente \(-s\) e intercepto \(\log c\).</p>
</div>
<div class="paragraph">
<p>Escriba un programa que lea un texto de un archivo, cuente las frecuencias de las palabras e imprima una línea para cada palabra, en orden descendente de frecuencia, con  \(\log f\) y \(\log r\).</p>
</div>
<div class="paragraph">
<p>Instale una librería para graficar:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">(v1.0) pkg&gt; add Plots</code></pre>
</div>
</div>
<div class="paragraph">
<p>Su uso es muy sencillo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">using Plots
x = 1:10
y = x.^2
plot(x, y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use la librería <code>Plots</code> para graficar los resultados y verificar si forman una línea recta.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap14">14. Archivos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo presenta el concepto de persistencia, que alude a los programas que mantienen los datos en almacenamiento permanente, y muestra cómo usar diferentes tipos de almacenamiento permanente, tales como archivos y bases de datos.</p>
</div>
<div class="sect2">
<h3 id="_persistencia">Persistencia</h3>
<div class="paragraph">
<p>La mayoría de los programas que hemos visto hasta ahora han sido transitorios, es decir se ejecutan por un corto tiempo y generan una salida, pero cuando finalizan, sus datos desaparecen. Si ejecuta el programa nuevamente, este comienza de cero.
</p>
</div>
<div class="paragraph">
<p>Otros programas son <em>persistentes</em>; se ejecutan durante un largo período de tiempo (o todo el tiempo), mantienen al menos parte de sus datos en almacenamiento permanente (en un disco duro, por ejemplo), y si se apagan y vuelven a comenzar, retoman donde lo dejaron.
</p>
</div>
<div class="paragraph">
<p>Ejemplos de programas persistentes son los sistemas operativos, que se ejecutan siempre que una computadora esté encendida, y los servidores web, que se ejecutan todo el tiempo, esperando que lleguen solicitudes a la red.</p>
</div>
<div class="paragraph">
<p>Una de las formas más simples para que los programas mantengan sus datos es leyendo y escribiendo <em>archivos de texto</em>. Ya hemos visto programas que leen archivos de texto; en este capítulo veremos programas que los escriben.</p>
</div>
<div class="paragraph">
<p>Otra alternativa es almacenar el estado del programa en una base de datos. En este capítulo también se presentará cómo usar una base de datos simple.</p>
</div>
</div>
<div class="sect2">
<h3 id="reading_and_writing">Lectura y Escritura</h3>
<div class="paragraph">
<p>Un archivo de texto es una secuencia de caracteres almacenados en un medio permanente, como un disco duro o una memoria flash. Ya vimos cómo abrir y leer un archivo en <a href="#reading_word_lists">Leer listas de palabras</a>.</p>
</div>
<div class="paragraph">
<p>Para escribir un archivo, debe abrirlo usando el modo <code>"w"</code> (de write) como segundo parámetro:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fout = open("salida.txt", "w")
IOStream(&lt;file salida.txt&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si el archivo ya existe, abrirlo en modo de escritura borra los datos antiguos y comienza de nuevo, ¡así que tenga cuidado!. Si el archivo no existe, se crea uno nuevo. <code>open</code> devuelve un objeto de archivo y la función <code>write</code> escribe datos en el archivo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; linea1 = "El Cid convoca a sus vasallos;\n";

julia&gt; write(fout, linea1)
31</code></pre>
</div>
</div>
<div class="paragraph">
<p>El valor de retorno es el número de caracteres que se escribieron. El objeto de archivo <em>fout</em> lleva registro de dónde quedó por última vez, por lo que si llama a <code>write</code> nuevamente, esta agrega nuevos datos al final del archivo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; linea2 = "éstos se destierran con él.\n";

julia&gt; write(fout, linea2)
30</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando hayas terminado de escribir, debes cerrar el archivo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; close(fout)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si no cierra el archivo, se cierra cuando finaliza el programa.</p>
</div>
</div>
<div class="sect2">
<h3 id="_formateo">Formateo</h3>
<div class="paragraph">
<p>El argumento de write tiene que ser una cadena, por lo que si queremos poner otros valores en un archivo, tenemos que convertirlos en cadenas. La forma más fácil de hacerlo es con la función <code>string</code>, o con interpolación de cadenas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fout = open("salida.txt", "w")
IOStream(&lt;file salida.txt&gt;)
julia&gt; write(fout, string(150))
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otra alternativa es utilizar la familia de funciones de <code>print(ln)</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; camellos = 42
42
julia&gt; println(fout, "He visto $camellos camellos.")</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Una alternativa más potente es la macro <code>@printf</code>, que imprime utilizando cadenas con especificación de formato al más puro estilo C, lo cual puede leer en <a href="https://docs.julialang.org/en/v1/stdlib/Printf/" class="bare">https://docs.julialang.org/en/v1/stdlib/Printf/</a>
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_nombre_de_archivo_y_ruta">Nombre de Archivo y Ruta</h3>
<div class="paragraph">
<p>Los archivos están organizados en <em>directorios</em> (también llamados "carpetas"). Cada programa en ejecución tiene su propio "directorio actual", que es el directorio que usará por defecto para para la mayoría de las operaciones. Por ejemplo, cuando abre un archivo para leer, Julia lo busca en el directorio actual.
</p>
</div>
<div class="paragraph">
<p>La función <code>pwd</code> devuelve el nombre del directorio actual:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; cwd = pwd()
"/home/ben"</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>cwd</code> significa "directorio del trabajo actual" (en inglés “current working directory”). El resultado en este ejemplo es <code>/home/ben</code>, que es el directorio de inicio de un usuario llamado <code>ben</code>.</p>
</div>
<div class="paragraph">
<p>Una cadena como <code>"/home/ben"</code> que identifica un archivo o directorio se llama <em>ruta</em> o <em>path</em>.
</p>
</div>
<div class="paragraph">
<p>Un nombre de archivo simple, como <code>memo.txt</code> también se considera una ruta, pero es una <em>ruta relativa</em> porque comienza en el directorio actual. Si el directorio actual es <code>/home/ben</code>, el nombre de archivo <code>memo.txt</code> se referiría a <code>/home/ben/memo.txt</code>.
</p>
</div>
<div class="paragraph">
<p>Una ruta que comienza con <code>/</code> no depende del directorio actual. Este tipo de ruta se llama una ruta absoluta. Para encontrar la ruta absoluta de un archivo, puede usar <code>abspath</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; abspath("memo.txt")
"/home/ben/memo.txt"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Julia también tiene otras funciones para trabajar con nombres de archivo y rutas. Por ejemplo, <code>ispath</code> comprueba si existe un archivo o directorio:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ispath("memo.txt")
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si existe, <code>isdir</code> comprueba si es un directorio:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; isdir("memo.txt")
false
julia&gt; isdir("/home/ben")
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Del mismo modo, <code>isfile</code> comprueba si se trata de un archivo.
</p>
</div>
<div class="paragraph">
<p><code>readdir</code> devuelve un arreglo de los archivos (y otros directorios) en el directorio dado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; readdir(cwd)
3-element Array{String,1}:
 "memo.txt"
 "musica"
 "fotos"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para mostrar el funcionamiento de estas funciones, el siguiente ejemplo "recorre" un directorio, imprime los nombres de todos los archivos y se llama a si misma, de manera recursiva, en todos los directorios.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function recorrer(nombredir)
    for nombre in readdir(nombredir)
        ruta = joinpath(nombredir, nombre)
        if isfile(ruta)
            println(ruta)
        else
            recorrer(ruta)
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>joinpath</code> toma un directorio y un nombre de archivo, y los une en una ruta completa.
</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Julia tiene una función integrada llamada <code>walkdir</code> (vea <a href="https://docs.julialang.org/en/v1/base/file/#Base.Filesystem.walkdir" class="bare">https://docs.julialang.org/en/v1/base/file/#Base.Filesystem.walkdir</a>) que es similar a esta pero más versátil. Como ejercicio, lea la documentación y úsela para imprimir los nombres de los archivos en un directorio dado y sus subdirectorios.
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="catching_exceptions">Captura de Excepciones</h3>
<div class="paragraph">
<p>Muchas cosas pueden salir mal al intentar leer y escribir archivos. Al intentar abrir un archivo que no existe, se obtiene un <code>SystemError</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fin = open("archivo_malo")
ERROR: SystemError: opening file "archivo_malo": No such file or directory</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si intentas abrir un archivo pero no tienes permiso para acceder a él, obtienes el error de sistema "Permission denied" (Permiso denegado).</p>
</div>
<div class="paragraph">
<p>Para evitar estos errores, se podrían usar funciones como <code>ispath</code> e <code>isfile</code>, pero tomaría mucho tiempo y líneas de código verificar todas las posibilidades.</p>
</div>
<div class="paragraph">
<p>Es más fácil intentar lidiar con los problemas a medida que ocurren, que es exactamente lo que hace la sentencia <code>try</code>. La sintaxis es similar a una sentencia <code>if</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">try
    fin = open("archivo_malo.txt")
catch exc
    println("Algo salió mal: $exc")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Julia comienza ejecutando el bloque <code>try</code>. Si todo resulta bien, se saltará el bloque <code>catch</code> y finalizará. Si ocurre una excepción, Julia saltara fuera del bloque <code>try</code> y ejecutará el bloque <code>catch</code>.</p>
</div>
<div class="paragraph">
<p>Gestionar una excepcion con <code>try</code> recibe el nombre de <em>capturar</em> una excepcion. En este ejemplo, el bloque <code>catch</code> muestra un mensaje de error que no es muy útil. En general, capturar una excepcion te da la oportunidad de corregir el problema, volverlo a intentar o, al menos, terminar el programa con elegancia.
</p>
</div>
<div class="paragraph">
<p>Cuando el código realiza cambios de estado o usa recursos, como archivos, generalmente se deben hacer ciertas cosas al finalizar la programación del código, como cerrar los archivos. Las excepciones pueden complicar esta tarea, ya que se podría salir antes de lo esperado de un bloque de código. La palabra reservada <code>finally</code> permite ejecutar un código al salir de un bloque de código determinado, independientemente de cómo salga:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">f = open("salida.txt")
try
    linea = readline(f)
    println(linea)
finally
    close(f)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, la función <code>close</code> siempre se ejecutará.</p>
</div>
</div>
<div class="sect2">
<h3 id="databases">Bases de datos</h3>
<div class="paragraph">
<p>Una <em>base de datos</em> es un archivo que esta organizado para almacenar datos. La mayoría de las bases de datos están organizadas como diccionarios, en el sentido de que realizan asociaciones entre claves y valores. La diferencia mas importante entre un diccionario y una base de datos, es que la base de datos se encuentra en el disco (u otro almacenamiento permanente), de modo que su contenido se conserva despues de que el programa finaliza.
</p>
</div>
<div class="paragraph">
<p>PiensaEnJulia proporciona una interfaz para <code>GDBM</code> (GNU dbm), que permite crear y actualizar archivos de base de datos. A modo de ejemplo, crearemos una base de datos que contenga pies de foto para archivos de imagen.
</p>
</div>
<div class="paragraph">
<p>Abrir una base de datos es similar a abrir otros archivos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; using PiensaEnJulia

julia&gt; bd = DBM("piedefoto", "c")
DBM(&lt;piedefoto&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>El modo "c" significa que la base de datos debe crearse si no existe. El resultado es un objeto de base de datos que se puede usar (para la mayoría de las operaciones) como un diccionario.</p>
</div>
<div class="paragraph">
<p>Cuando creas un nuevo elemento, <code>GDBM</code> actualiza el archivo de base de datos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; bd["luismi.png"] = "Foto de Luis Miguel."
"Foto de Luis Miguel."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando accede a uno de los elementos, <code>GDBM</code> lee el archivo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; bd["luismi.png"]
"Foto de Luis Miguel."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si realiza otra asignación a una clave existente, <code>GDBM</code> reemplaza el valor anterior:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; bd["luismi.png"] = "Foto de Luis Miguel cantando."
"Foto de Luis Miguel cantando."
julia&gt; bd["luismi.png"]
"Foto de Luis Miguel cantando."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Algunas funciones que tienen un diccionario como argumento, con <code>claves</code> y <code>valores</code>, no funcionan con objetos de base de datos. Pero la iteración con un bucle <code>for</code> sí:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for (clave, valor) in bd
    println(clave, ": ", valor)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Al igual que con otros archivos, debe cerrar la base de datos cuando haya terminado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; close(bd)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_serialización">Serialización</h3>
<div class="paragraph">
<p>Una limitación de <code>GDBM</code> es que las claves y los valores deben ser cadenas o conjuntos de bytes. Si intenta utilizar cualquier otro tipo, se producirá un error.</p>
</div>
<div class="paragraph">
<p>Las funciones <code>serialize</code> y <code>deserialize</code> pueden ser útiles. Traducen casi cualquier tipo de objeto en un arreglo de bytes (un iobuffer) adecuada para el almacenamiento en una base de datos, y luego traducen los arreglos de bytes nuevamente en objetos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; using Serialization

julia&gt; io = IOBuffer();

julia&gt; t = [1, 2, 3];

julia&gt; serialize(io, t)
24
julia&gt; print(take!(io))
UInt8[0x37, 0x4a, 0x4c, 0x08, 0x04, 0x00, 0x00, 0x00, 0x15, 0x00, 0x08, 0xe2, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</code></pre>
</div>
</div>
<div class="paragraph">
<p>El formato no es obvio para nosotros; pero es fácil de interpretar para Julia. <code>deserialize</code> reconstituye el objeto:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; io = IOBuffer();

julia&gt; t1 = [1, 2, 3];

julia&gt; serialize(io, t1)
24
julia&gt; s = take!(io);

julia&gt; t2 = deserialize(IOBuffer(s));

julia&gt; print(t2)
[1, 2, 3]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>serialize</code> y <code>deserialize</code> escriben y leen desde un objeto iobuffer que representa un I/O stream en memoria. La función <code>take!</code> recupera el contenido del iobuffer como un arreglo de bytes y reestablece el iobuffer a su estado inicial.</p>
</div>
<div class="paragraph">
<p>Aunque el nuevo objeto tiene el mismo valor que el anterior, no es (en general) el mismo objeto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t1 == t2
true
julia&gt; t1 ≡ t2
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>En otras palabras, la serialización y luego la deserialización tienen el mismo efecto que copiar el objeto.
</p>
</div>
<div class="paragraph">
<p>Puedes usar esto para almacenar valores que no sean cadenas en una base de datos.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>De hecho, el almacenamiento de valores que no son cadenas en una base de datos es tan común que se ha encapsulado en un paquete llamado <code>JLD2</code> (consulte <a href="https://github.com/JuliaIO/JLD2.jl" class="bare">https://github.com/JuliaIO/JLD2.jl</a>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_objetos_de_comando">Objetos de Comando</h3>
<div class="paragraph">
<p>La mayoría de los sistemas operativos proporcionan una interfaz de línea de comandos, también conocida como <em>shell</em>. Las shells generalmente proporcionan comandos para navegar por el sistema de archivos y ejecutar aplicaciones. Por ejemplo, en Unix puede cambiar los directorios con <code>cd</code>, mostrar el contenido de un directorio con <code>ls</code> e iniciar un navegador web escribiendo (por ejemplo) <code>firefox</code>.
</p>
</div>
<div class="paragraph">
<p>Cualquier programa que pueda iniciar desde la shell también puede iniciarse desde Julia usando un <em>objeto de comando</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; cmd = `echo hola`
`echo hola`</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las comillas invertidas se usan para delimitar el comando.</p>
</div>
<div class="paragraph">
<p>La función <code>run</code> ejecuta el comando:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; run(cmd);
hola</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hola</code> es la salida del comando echo, enviado a <code>STDOUT</code>. La función <code>run</code> devuelve un objeto de proceso y genera un <code>ErrorException</code> si el comando externo no se ejecuta correctamente.</p>
</div>
<div class="paragraph">
<p>Si desea leer la salida del comando externo, se puede usar <code>read</code> en su lugar:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = read(cmd, String)
"hola\n"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por ejemplo, la mayoría de los sistemas Unix tienen un comando llamado <code>md5sum</code> o <code>md5</code> que lee el contenido de un archivo y calcula una "suma de verificación". Puede leer sobre Md5 en <a href="https://en.wikipedia.org/wiki/Md5" class="bare">https://en.wikipedia.org/wiki/Md5</a>. Este comando proporciona una manera eficiente de verificar si dos archivos tienen el mismo contenido. La probabilidad de que diferentes contenidos produzcan la misma suma de comprobación es muy pequeña.
</p>
</div>
<div class="paragraph">
<p>Puede usar un objeto de comando para ejecutar <code>md5</code> desde Julia y obtener el resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; nombrearchivo = "salida.txt"
"salida.txt"
julia&gt; cmd = `md5 $nombrearchivo`
`md5 salida.txt`
julia&gt; res = read(cmd, String)
"MD5 (salida.txt) = d41d8cd98f00b204e9800998ecf8427e\n"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_modulos">Modulos</h3>
<div class="paragraph">
<p>Supongamos que tenemos un archivo llamado <code>"wc.jl"</code> con el siguiente código:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function contarlineas(nombrearchivo)
    conteo = 0
    for linea in eachline(nombrearchivo)
        conteo += 1
    end
    conteo
end

print(contarlineas("wc.jl"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si ejecuta este programa, se leen las líneas de código y se imprime el número de líneas en el archivo, que es 9. También puede incluirlo en REPL de esta manera:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jl-con" data-lang="jl-con">julia&gt; include("wc.jl")
9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los módulos permiten crear espacios de trabajo separados, es decir, nuevos global scopes (ámbitos de tipo global). Una sentencia tiene
global scope si tiene efecto en todo el prorgama.</p>
</div>
<div class="paragraph">
<p>Un módulo comienza con la palabra reservada <code>module</code> y termina con <code>end</code>. Al usar módulos, se evitan los conflictos de nombres entre sus propias definiciones de nivel superior y las que se encuentran en el código de otra persona. <code>import</code> permite controlar qué nombres de otros módulos están visibles y <code>export</code> especifica cuáles de sus nombres son públicos, es decir, aquellos que se pueden usar fuera del módulo sin tener el prefijo del nombre del módulo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">module ContarLineas
    export contarlineas

    function contarlineas(nombrearchivo)
        conteo = 0
        for linea in eachline(nombrearchivo)
            conteo += 1
        end
        conteo
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El módulo <code>ContarLineas</code> proporciona la función <code>contarlineas</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">julia&gt; using ContarLineas

julia&gt; contarlineas("wc.jl")
11</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicio_14_1">Ejercicio 14-1</h4>
<div class="paragraph">
<p>Escriba este ejemplo en un archivo llamado <em>wc.jl</em>, inclúyalo en REPL (con include) y escriba <code>using ContarLineas</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>Si importa un módulo que ya se ha importado, Julia no hace nada. No se vuelve a leer el archivo, incluso si ha cambiado.</p>
</div>
<div class="paragraph">
<p>Si desea volver a cargar un módulo, debe reiniciar REPL. El paquete <code>Revise</code> puede ayudarlo a no reiniciar tan seguido (vea <a href="https://github.com/timholy/Revise.jl" class="bare">https://github.com/timholy/Revise.jl</a>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_12">Depuración</h3>
<div class="paragraph">
<p>Al leer y escribir archivos, puedes tener problemas con los espacios en blanco. Estos errores pueden ser difíciles de depurar porque los espacios, las tabulaciones y las nuevas líneas son generalmente invisibles:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; s = "1 2\t 3\n 4";

julia&gt; println(s)
1 2     3
 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las funciones integradas <code>repr</code> o <code>dump</code> pueden ser de ayuda. Toman cualquier objeto como argumento y devuelven una representación de tipo cadena del objeto.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; repr(s)
"\"1 2\\t 3\\n 4\""
julia&gt; dump(s)
String "1 2\t 3\n 4"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto puede ser útil para la depuración.
</p>
</div>
<div class="paragraph">
<p>Otro problema con el que te puedes encontrar es que en diferentes sistemas operativos se usan diferentes caracteres para indicar el final de una línea. Algunos sistemas usan una nueva línea, representada por <code>\n</code>. Otros usan un carácter de retorno <code>\r</code>. Algunos usan ambos. Si usas un archivo en diferentes sistemas, estas inconsistencias podrían causar problemas.
</p>
</div>
<div class="paragraph">
<p>Para la mayoría de los sistemas, hay aplicaciones para convertir de un formato a otro. Puede encontrarlas (y leer más sobre este tema) en <a href="https://en.wikipedia.org/wiki/Newline" class="bare">https://en.wikipedia.org/wiki/Newline</a>. O, por supuesto, podrías escribir una tú mismo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_13">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">persistente</dt>
<dd>
<p>Perteneciente a un programa que se ejecuta indefinidamente y mantiene al menos algunos de sus datos en almacenamiento permanente.
</p>
</dd>
<dt class="hdlist1">archivo de texto</dt>
<dd>
<p>Una secuencia de caracteres almacenados en almacenamiento permanente, tal como en un disco duro.
</p>
</dd>
<dt class="hdlist1">directorio</dt>
<dd>
<p>Una colección de archivos con nombre, también llamada carpeta.
</p>
</dd>
<dt class="hdlist1">ruta</dt>
<dd>
<p>Una cadena que identifica a un archivo.
</p>
</dd>
<dt class="hdlist1">ruta relativa</dt>
<dd>
<p>Una ruta que comienza en el directorio actual.
</p>
</dd>
<dt class="hdlist1">ruta absoluta</dt>
<dd>
<p>Una ruta que comienza en el directorio superior del sistema de archivos.
</p>
</dd>
<dt class="hdlist1">capturar (catch)</dt>
<dd>
<p>Evitar que una excepción haga terminar un programa, utilizando las sentencias <code>try ... catch ... finally</code>.
</p>
</dd>
<dt class="hdlist1">base de datos</dt>
<dd>
<p>Un archivo cuyo contenido está organizado como un diccionario con claves que corresponden a valores.
</p>
</dd>
<dt class="hdlist1">shell</dt>
<dd>
<p>Un programa que permite a los usuarios escribir comandos y luego ejecutarlos iniciando otros programas.
</p>
</dd>
<dt class="hdlist1">objeto de comando</dt>
<dd>
<p>Un objeto que representa un comando de shell. Esto permite que un programa de Julia ejecute comandos y lea los resultados.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_16">Ejercicios</h3>
<div class="sect3">
<h4 id="ex14-1">Ejercicio 14-2</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>sed</code> que tome como argumentos una cadena de patrones, una cadena de reemplazo y dos nombres de archivo. La función debe leer el primer archivo y escribir el contenido en el segundo archivo (creándolo si es necesario). Si la cadena de patrones aparece en algún lugar del archivo, debe reemplazarse con la cadena de reemplazo.
</p>
</div>
<div class="paragraph">
<p>Si se produce un error al abrir, leer, escribir o cerrar los archivos, su programa debe detectar la excepción, imprimir un mensaje de error y terminar.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex14-2">Ejercicio 14-3</h4>
<div class="paragraph">
<p>Si hizo <a href="#ex12-2">Ejercicio 12-3</a>, recordará que debía crear un diccionario que asociaba una cadena ordenada de letras al conjunto de palabras que se podía deletrear con esas letras. Por ejemplo, <code>"cuaderno"</code> estaba asociado al arreglo <code>["cuaderno", "educaron", "encuadro"]</code>.</p>
</div>
<div class="paragraph">
<p>Escriba un módulo que importe <code>conjuntoanagramas</code> y proporcione dos nuevas funciones: <code>almacenaranagramas</code>, que almacena el diccionario de anagramas usando <code>JLD2</code> (vea <a href="https://github.com/JuliaIO/JLD2.jl" class="bare">https://github.com/JuliaIO/JLD2.jl</a>); y <code>leeranagramas</code>, que busca una palabra y devuelve un arreglo de sus anagramas.
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex14-3">Ejercicio 14-4</h4>
<div class="paragraph">
<p>En una gran colección de archivos MP3, puede haber más de una copia de la misma canción, almacenada en diferentes directorios o con diferentes nombres de archivo. El objetivo de este ejercicio es buscar duplicados.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escriba un programa que busque un directorio y todos sus subdirectorios, de forma recursiva, y devuelva un arreglo de rutas completas para todos los archivos con un sufijo dado (como <em>.mp3</em>).</p>
</li>
<li>
<p>Para reconocer duplicados, puede usar <code>md5sum</code> o <code>md5</code> para calcular una "suma de verificación" para cada archivo. Si dos archivos tienen la misma suma de verificación, probablemente tengan el mismo contenido.</p>
</li>
<li>
<p>Para verificar, puede usar el comando de Unix <code>diff</code>.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap15">15. Estructuras y Objetos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A esta altura, ya debe saber cómo usar funciones para tener un código más organizado, y cómo usar los tipos integrados de Julia para organizar sus datos. El siguiente paso es aprender a construir sus propios tipos para organizar tanto el código como los datos. Este es un gran tema, y por lo tanto tomará un par de capítulos abarcar todo.</p>
</div>
<div class="sect2">
<h3 id="_tipos_compuestos">Tipos Compuestos</h3>
<div class="paragraph">
<p>Hemos utilizado muchos tipos integrados en Julia; ahora vamos a definir un nuevo tipo. A modo de ejemplo, crearemos un tipo llamado <code>Punto</code> que represente un punto en un espacio bidimensional.
</p>
</div>
<div class="paragraph">
<p>En notación matemática, los puntos suelen escribirse entre paréntesis con una coma que separa las coordenadas. Por ejemplo, \(\left(0,0\right)\) representa el origen, y \(\left(x,y\right)\) representa el punto localizado \(x\) unidades a la derecha y \(y\) unidades hacia arriba del origen.</p>
</div>
<div class="paragraph">
<p>Hay varias formas en que podríamos representar puntos del plano cartesiano en Julia:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Podríamos almacenar las coordenadas por separado en dos variables, <code>x</code> e <code>y</code>.</p>
</li>
<li>
<p>Podríamos almacenar las coordenadas como elementos de un arreglo o tupla.</p>
</li>
<li>
<p>Podríamos crear un nuevo tipo para representar puntos como objetos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Crear un nuevo tipo exige un poco más de esfuerzo que las otras opciones, pero tiene algunas ventajas que veremos pronto.</p>
</div>
<div class="paragraph">
<p>Un <em>tipo compuesto</em> definido por el programador también se denomina <em>estructura</em> (struct en inglés). La definición de <code>estructura</code> de un punto se ve así:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Punto
    x
    y
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El encabezado indica que la nueva estructura se llama <code>Punto</code>. El cuerpo define los <em>atributos</em> o <em>campos</em> de la estructura. La estructura de <code>Punto</code> tiene dos campos: <code>x</code> e <code>y</code>.
</p>
</div>
<div class="paragraph">
<p>Una estructura es como una fábrica que crea objetos. Para crear un punto, debes llamar a <code>Punto</code> como si fuera una función que tiene como argumentos los valores de los campos. Cuando <code>Punto</code> se usa como una función, se llama <em>constructor</em>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; p = Punto(3.0, 4.0)
Punto(3.0, 4.0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>El valor de retorno es una referencia a un objeto <code>Punto</code>, el cual asignamos a <code>p</code>.
</p>
</div>
<div class="paragraph">
<p>La creación de un nuevo objeto se llama <em>instanciación</em>, y el objeto creado es una <em>instancia</em> del tipo.
</p>
</div>
<div class="paragraph">
<p>Cuando imprimes una instancia, Julia te dice a qué tipo pertenece y cuáles son los valores de los atributos.</p>
</div>
<div class="paragraph">
<p>Cada objeto es una instancia de algún tipo, por lo que "objeto" e "instancia" son intercambiables. Pero en este capítulo se utiliza "instancia" para indicar que hablamos de un tipo definido por el programador.</p>
</div>
<div class="paragraph">
<p>Un diagrama de estado que muestra un objeto y sus atributos se denomina <em>diagrama de objeto</em>; ver <a href="#fig15-1">Object diagram</a>.
</p>
</div>
<div id="fig15-1" class="imageblock">
<div class="content">
<img src="images/fig151.svg" alt="fig151">
</div>
<div class="title">Figura 20. Object diagram</div>
</div>
</div>
<div class="sect2">
<h3 id="_las_estructuras_son_inmutables">Las Estructuras son Inmutables</h3>
<div class="paragraph">
<p>Puede obtener los valores de los campos utilizando la notación <code>.</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = p.x
3.0
julia&gt; p.y
4.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>La expresión <code>p.x</code> significa: "Ve al objeto al que se apunta <code>p</code> y obtén el valor de <code>x</code>". En el ejemplo, asignamos ese valor a una variable llamada <code>x</code>. No hay conflicto entre la variable <code>x</code> y el atributo <code>x</code>.</p>
</div>
<div class="paragraph">
<p>Puede usar esa notación de punto como parte de cualquier expresión. Por ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; distancia = sqrt(p.x^2 + p.y^2)
5.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sin embargo, las estructuras son inmutables por defecto, después de la construcción los campos no pueden cambiar su valor:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; p.y = 1.0
ERROR: setfield! immutable struct of type Punto cannot be changed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto puede parecer extraño al principio, pero tiene varias ventajas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Puede ser más eficiente.</p>
</li>
<li>
<p>No es posible violar las invariantes (requisitos que deberían cumplirse en todos los objetos, en todo momento) de los constructores de un tipo compuesto (ver <a href="#constructor">Constructores</a>).</p>
</li>
<li>
<p>El código que usa objetos inmutables puede ser más fácil de entender.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_estructuras_mutables">Estructuras Mutables</h3>
<div class="paragraph">
<p>De ser necesario, se pueden declarar tipos compuestos mutables con la palabra reservada <code>mutable struct</code>. A continuación se muestra la definición de un punto mutable:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">mutable struct MPunto
    x
    y
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puede asignar valores a una instancia de una estructura mutable utilizando notación de punto (.):
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; blanco = MPunto(0.0, 0.0)
MPunto(0.0, 0.0)
julia&gt; blanco.x = 3.0
3.0
julia&gt; blanco.y = 4.0
4.0</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rectángulos">Rectángulos</h3>
<div class="paragraph">
<p>A veces, decidir cuáles deberían ser los campos de un objeto es fácil, pero en otros casos no. Por ejemplo, imagine que queremos un tipo que represente un rectángulo. ¿Qué campos usarías para especificar la ubicación y el tamaño de un rectángulo? Puedes ignorar el ángulo. Para simplificar las cosas, supongamos que el rectángulo es vertical u horizontal.</p>
</div>
<div class="paragraph">
<p>Hay al menos dos posibilidades:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Puede especificar una esquina del rectángulo (o el centro), el ancho y la altura.</p>
</li>
<li>
<p>Podría especificar dos esquinas opuestas.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Es difícil decir que una opción es mejor que la otra, por lo que implementaremos la primera, a modo de ejemplo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">"""
Representa un rectángulo.

atributos: ancho, alto, esquina.
"""
struct Rectangulo
    ancho
    alto
    esquina
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El texto escrito entre comillas triples es llamado cadena de documentación (o docstring), y permite documentar. La documentación es el acto de comentar convenientemente cada una de las partes que tiene el programa.</p>
</div>
<div class="paragraph">
<p>En este ejemplo, la cadena de documentación (o docstring) enumera los atributos. Los atributos ancho y alto son números, y esquina es un objeto <code>Punto</code> que especifica la esquina inferior izquierda.
</p>
</div>
<div class="paragraph">
<p>Para representar un rectángulo, debe crear una instancia del tipo <code>Rectangulo</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; origen = MPunto(0.0, 0.0)
MPunto(0.0, 0.0)
julia&gt; caja = Rectangulo(100.0, 200.0, origen)
Rectangulo(100.0, 200.0, MPunto(0.0, 0.0))</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#fig15-2">Object diagram</a> muestra el estado de este objeto. Un objeto es <em>embebido</em> si es atributo de otro objeto. Debido a que el atributo <code>esquina</code> se refiere a un objeto mutable, se dibuja fuera del objeto <code>Rectangulo</code>.
</p>
</div>
<div id="fig15-2" class="imageblock">
<div class="content">
<img src="images/fig152.svg" alt="fig152">
</div>
<div class="title">Figura 21. Object diagram</div>
</div>
</div>
<div class="sect2">
<h3 id="_instancias_como_argumentos">Instancias como Argumentos</h3>
<div class="paragraph">
<p>Podemos pasar una instancia como argumento de la manera habitual. Por ejemplo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimirpunto(p)
    println("($(p.x), $(p.y))")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>imprimirpunto</code> toma un <code>Punto</code> como argumento y lo muestra en notación matemática. Puede llamar a imprimirpunto con un argumento <code>p</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; imprimirpunto(blanco)
(3.0, 4.0)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicio_15_1">Ejercicio 15-1</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>distanciaentrepuntos</code> que tome dos puntos como argumentos y devuelva la distancia entre ellos.
</p>
</div>
<div class="paragraph">
<p>Si un objeto de estructura mutable se pasa a una función como argumento, la función puede modificar los campos del objeto. Por ejemplo, <code>moverpunto!</code> toma un objeto mutable <code>Punto</code> y dos números, <code>dx</code> y <code>dy</code>, los cuales suma a los atributos <code>x</code> e <code>y</code> de <code>Punto</code>, respectivamente:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function moverpunto!(p, dx, dy)
    p.x += dx
    p.y += dy
    nothing
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aquí hay un ejemplo que muestra como funciona:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; origen = MPunto(0.0, 0.0)
MPunto(0.0, 0.0)
julia&gt; moverpunto!(origen, 1.0, 2.0)

julia&gt; origen
MPunto(1.0, 2.0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dentro de la función, <code>p</code> es un alias de <code>origen</code>, por lo que cuando la función modifica <code>p</code>, <code>origen</code> también cambia.
</p>
</div>
<div class="paragraph">
<p>Al pasar un objeto inmutable <code>Punto</code> a <code>moverpunto!</code> se produce un error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; moverpunto!(p, 1.0, 2.0)
ERROR: setfield! immutable struct of type Punto cannot be changed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sin embargo, puede modificar el valor de un atributo mutable de un objeto inmutable. Por ejemplo, <code>moverrectangulo!</code> tiene como argumentos un objeto <code>Rectangulo</code> y dos números, <code>dx</code> y <code>dy</code>. Esta función usa <code>moverpunto!</code> para mover la esquina del rectángulo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function moverrectangulo!(rect, dx, dy)
  moverpunto!(rect.esquina, dx, dy)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora <code>p</code> en <code>moverpunto!</code> es un alias para <code>rect.esquina</code>, por lo que cuando <code>p</code> se modifica, <code>rect.esquina</code> también cambia:</p>
</div>
<div class="paragraph">
<p>Now <code>p</code> in <code>movepoint!</code> is an alias for <code>rect.corner</code>, so when <code>p</code> is modified, <code>rect.corner</code> changes also:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; caja
Rectangulo(100.0, 200.0, MPunto(0.0, 0.0))
julia&gt; moverrectangulo!(caja, 1.0, 2.0)

julia&gt; caja
Rectangulo(100.0, 200.0, MPunto(1.0, 2.0))</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>No puede reasignar un atributo mutable de un objeto inmutable:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; caja.esquina = MPunto(1.0, 2.0)
ERROR: setfield! immutable struct of type Rectangulo cannot be changed</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_instancias_como_valores_de_retorno">Instancias como Valores de Retorno</h3>
<div class="paragraph">
<p>Las funciones pueden devolver instancias. Por ejemplo, <code>encontrarcentro</code> toma un <code>Rectangulo</code> como argumento y devuelve un <code>Punto</code> que contiene las coordenadas del centro del rectángulo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function encontrarcentro(rect)
    Punto(rect.esquina.x + rect.ancho / 2, rect.esquina.y + rect.alto / 2)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La expresión <code>rect.corner.x</code> significa, “Ve al objeto al que <code>rect</code> apunta y seleccione el atributo llamado <code>esquina</code>; luego vaya a ese objeto y seleccione el atributo llamado <code>x</code>".</p>
</div>
<div class="paragraph">
<p>A continución vemos un ejemplo que toma <code>caja</code> como argumento y asigna el <code>Punto</code> resultante a <code>centro</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; centro = encontrarcentro(caja)
Punto(51.0, 102.0)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_copiado">Copiado</h3>
<div class="paragraph">
<p>El uso de alias puede hacer que un programa sea difícil de leer, ya que los cambios hechos en un lugar pueden tener efectos inesperados en otro lugar. Es difícil estar al tanto de todas las variables a las que puede apuntar un objeto dado.
</p>
</div>
<div class="paragraph">
<p>Copiar un objeto es, muchas veces, una alternativa a la creación de un alias. Julia provee una función llamada copy que puede duplicar cualquier objeto:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; p1 = MPunto(3.0, 4.0)
MPunto(3.0, 4.0)
julia&gt; p2 = deepcopy(p1)
MPunto(3.0, 4.0)
julia&gt; p1 ≡ p2
false
julia&gt; p1 == p2
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador <code>≡</code> indica que <code>p1</code> y <code>p2</code> no son el mismo objeto, lo cual es esperable. Lo que no es del todo esperable es que <code>==</code> no devuelva <code>true</code>, aunque estos puntos contengan los mismos datos. Resulta que para los objetos mutables, el comportamiento predeterminado del operador <code>==</code> es el mismo que el operador <code>===</code>, es decir, comprueba la identidad del objeto, no la equivalencia del objeto. Esto se debe a que Julia no sabe qué debería considerarse equivalente para los tipos compuestos mutables. Al menos no todavía.
</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_15_2">Ejercicio 15-2</h4>
<div class="paragraph">
<p>Cree una instancia de <code>Punto</code>, haga una copia y verifique la equivalencia y la igualdad de ambas. El resultado puede sorprenderlo, pero explica por qué el alias no es un problema para un objeto inmutable.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_13">Depuración</h3>
<div class="paragraph">
<p>Al comenzar a trabajar con objetos, es probable que encuentre algunas excepciones nuevas. Si intenta acceder a un campo que no existe, obtendrá:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; p = Punto(3.0, 4.0)
Punto(3.0, 4.0)
julia&gt; p.z = 1.0
ERROR: type Punto has no field z</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si no está seguro del tipo de un objeto, puede saberlo de la siguiente manera:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; typeof(p)
Punto</code></pre>
</div>
</div>
<div class="paragraph">
<p>También puede usar <code>isa</code> para verificar si un objeto es una instancia de un tipo específico:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; p isa Punto
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si no está seguro de si un objeto tiene un atributo particular, puede usar la función <code>fieldnames</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fieldnames(Punto)
(:x, :y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>o la función <code>isdefined</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; isdefined(p, :x)
true
julia&gt; isdefined(p, :z)
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>El primer argumento puede ser cualquier objeto; el segundo argumento es el símbolo <code>:</code> seguido del nombre del atributo.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_14">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">estructura</dt>
<dd>
<p>Un tipo compuesto.
</p>
</dd>
<dt class="hdlist1">constructor</dt>
<dd>
<p>Una función con el mismo nombre que un tipo, que crea instancias de este tipo.
</p>
</dd>
<dt class="hdlist1">instancia</dt>
<dd>
<p>Un objeto que pertenece a un tipo.
</p>
</dd>
<dt class="hdlist1">instanciar</dt>
<dd>
<p>Crear un nuevo objeto.
</p>
</dd>
<dt class="hdlist1">atributo o campo</dt>
<dd>
<p>Un valor con nombre asociado un objeto.
</p>
</dd>
<dt class="hdlist1">objeto embebido</dt>
<dd>
<p>Un objeto que se almacena como atributo de otro objeto.
</p>
</dd>
<dt class="hdlist1">deep copy o copia profunda</dt>
<dd>
<p>Copiar el contenido de un objeto, y cualquier objeto embebido en él, y a su vez, cualquier objeto embebido en ellos, y así sucesivamente. Implementado por la función <code>deepcopy</code>.
</p>
</dd>
<dt class="hdlist1">diagrama de objeto</dt>
<dd>
<p>Un diagrama que muestra objetos, sus atributos y valores de atributos.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_17">Ejercicios</h3>
<div class="sect3">
<h4 id="ex15-1">Ejercicio 15-3</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escriba una definición de un tipo llamado <code>Circulo</code>, que tenga atributos <code>centro</code> y <code>radio</code>, donde <code>centro</code> es un objeto <code>Punto</code> y <code>radio</code> es un número.
</p>
</li>
<li>
<p>Crear instancia de un objeto circulo, que represente a un círculo con centro en \(\left(150, 100\right)\) y radio 75.</p>
</li>
<li>
<p>Escriba una función llamada <code>puntoencirculo</code> que tome un objeto <code>Circulo</code> y un objeto <code>Punto</code>, y devuelva <code>true</code> si el punto se encuentra dentro o en el límite del círculo.
</p>
</li>
<li>
<p>Escriba una función llamada <code>rectencirculo</code> que tome un objeto <code>Circulo</code> y un objeto <code>Rectangulo</code> y devuelva <code>true</code> si el rectángulo se encuentra completamente dentro o en el límite del círculo.
</p>
</li>
<li>
<p>Escriba una función llamada <code>sobreposicionrectcirc</code> que tome un objeto <code>Circulo</code> y un objeto <code>Rectangulo</code> y devuelva <code>true</code> si alguna de las esquinas del rectángulo cae dentro del círculo. Una versión más desafiante es escribir una función que devuelva <code>true</code> si alguna parte del rectángulo (no necesariamente una esquina) cae dentro del círculo.
</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="ex15-2">Ejercicio 15-4</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escriba una función llamada <code>dibujarrect</code> que tome como argumentos un objeto turtle y un objeto <code>Rectángulo</code>, y use turtle para dibujar el rectángulo. Consulte el Capítulo 4 para ver ejemplos que usen objetos <code>Turtle</code>.
</p>
</li>
<li>
<p>Escriba una función llamada <code>dibujarcirculo</code> que tome como argumentos un objeto <code>Turtle</code> y un objeto <code>Circulo</code>, y dibuje el círculo.
</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap16">16. Estructuras y Funciones</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ahora que sabemos cómo crear tipos compuestos, el siguiente paso es escribir funciones que tomen objetos definidos por el programador como parámetros, y que devuelvan otros como resultados. En este capítulo también se presenta el "estilo de programación funcional" y dos nuevas formas de desarrollar programas.</p>
</div>
<div class="sect2">
<h3 id="time">Tiempo</h3>
<div class="paragraph">
<p>Como otro ejemplo de tipo compuesto, definiremos una <code>estructura</code> llamada <code>Hora</code> que registra la hora del día. La definición de esta estructura se muestra a continuación:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">"""
Representa la hora del día.

atributos: hora, minuto, segundo
"""
struct Hora
    hora
    minuto
    segundo
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Observación: <code>Time</code> es una palabra reservada de Julia.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; tiempo = Hora(11, 59, 30)
Hora(11, 59, 30)</code></pre>
</div>
</div>
<div class="paragraph">
<p>El diagrama de objeto para el objeto <code>Hora</code> luce así <a href="#fig16-1">Object diagram</a>.</p>
</div>
<div id="fig16-1" class="imageblock">
<div class="content">
<img src="images/fig161.svg" alt="fig161">
</div>
<div class="title">Figura 22. Object diagram</div>
</div>
<div class="sect3">
<h4 id="_ejercicio_16_1">Ejercicio 16-1</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>imprimirhora</code> que tome un objeto <code>Hora</code> y lo imprima con el formato <code>hora:minuto:segundo</code>. <code>Printf</code>, de la macro <code>@printf</code> del módulo StdLib, permite imprimir un número entero con el formato <code>"%02d"</code>, es decir, utilizando al menos dos dígitos, incluido un cero inicial si es necesario.
</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicio_16_2">Ejercicio 16-2</h4>
<div class="paragraph">
<p>Escriba una función booleana llamada <code>estadespues</code> que tome dos objetos <code>Hora</code>: <code>t1</code> y <code>t2</code>, y devuelva <code>true</code> si la hora <code>t1</code> está después que <code>t2</code>, y <code>false</code> de lo contrario. Desafío: no use sentencias <code>if</code>.
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_funciones_puras">Funciones Puras</h3>
<div class="paragraph">
<p>En las siguientes secciones escribiremos dos versiones de una función que calcula la suma de horas. La primera versión muestra un tipo de función llamado función pura, y la segunda un tipo llamado modificador. Además, estas versiones permitirán mostrar un nuevo plan de desarrollo de programas que llamaremos <em>desarrollo de prototipos</em>, que es una forma de abordar un problema complejo comenzando con un prototipo simple y lidiando gradualmente con las complicaciones.
</p>
</div>
<div class="paragraph">
<p>Este es un primer prototipo de la función <code>sumahora</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function sumahora(t1, t2)
    Hora(t1.hora + t2.hora, t1.minuto + t2.minuto, t1.segundo + t2.segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función crea un nuevo objeto <code>Hora</code>, inicializa sus atributos y devuelve una referencia al nuevo objeto. A esto se le llama <em>función pura</em> porque no modifica ninguno de los objetos que se le pasan como argumento, y no tiene efectos (como mostrar un valor o tomar una entrada del usuario) más que devolver un valor.</p>
</div>
<div class="paragraph">
<p>Para probar esta función, crearemos dos objetos <code>Hora</code>: <code>inicio</code>, que contiene la hora de inicio de una película, como <em>Roma</em>, y <code>duracion</code>, que contiene la duración de la película, que es dos horas y 15 minutos.</p>
</div>
<div class="paragraph">
<p><code>sumahora</code> calcula cuándo se terminará la película.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; inicio = Hora(9, 50, 0);

julia&gt; duracion = Hora(2, 15, 0);

julia&gt; finaliza = sumahora(inicio, duracion);

julia&gt; imprimirhora(finaliza)
11:65:00</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado <code>11:65:00</code> no es lo que queríamos. El problema es que esta función no considera los casos en los que el número de segundos o minutos suma más que sesenta. Cuando ocurre eso, debemos "acarrear" (como en una suma) los segundos sobrantes a la columna de los minutos, o los minutos extras a la columna de las horas. He aquí una versión corregida de la función:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function sumahora(t1, t2)
    segundo = t1.segundo + t2.segundo
    minuto = t1.minuto + t2.minuto
    hora = t1.hora + t2.hora
    if segundo &gt;= 60
        segundo -= 60
        minuto += 1
    end
    if minuto &gt;= 60
        minuto -= 60
        hora += 1
    end
    Hora(hora, minuto, segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aunque esta función es correcta, es muy larga. Más adelante veremos una alternativa más corta.</p>
</div>
</div>
<div class="sect2">
<h3 id="modifiers">Modificadores</h3>
<div class="paragraph">
<p>Hay veces en las que es útil que una función modifique uno o más de los objetos que recibe como parámetros. En ese caso, los cambios son visibles en el nivel en donde se ubica la sentencia de llamada. Estas funciones se llaman <em>modificadores</em>.
</p>
</div>
<div class="paragraph">
<p>La función <code>incrementar!</code>, que agrega un número dado de segundos a un objeto <code>Hora</code>, puede escribirse naturalmente como un modificador. Aquí mostramos un prototipo de la función:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function incrementar!(tiempo, segundos)
    tiempo.segundo += segundos
    if tiempo.segundo &gt;= 60
        tiempo.segundo -= 60
        tiempo.minute += 1
    end
    if tiempo.minuto &gt;= 60
        tiempo.minuto -= 60
        tiempo.hora += 1
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La primera línea realiza la suma de los segundos; las restantes se ocupan de los casos especiales que vimos antes.</p>
</div>
<div class="paragraph">
<p>¿Es correcta esta función? ¿Qué ocurre si el parámetro <code>segundos</code> es mucho mayor que sesenta?</p>
</div>
<div class="paragraph">
<p>En tal caso, no es suficiente con acarrear una vez; debemos seguir haciéndolo hasta que <code>tiempo.segundo</code> sea menor que sesenta. Una solución es sustituir las sentencias <code>if</code> por sentencias <code>while</code>. Esta función sería correcta, pero no es la solución más eficiente.</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_16_3">Ejercicio 16-3</h4>
<div class="paragraph">
<p>Escriba una versión correcta de <code>incrementar!</code> sin bucles.</p>
</div>
<div class="paragraph">
<p>Todo lo que se pueda hacer con modificadores también puede lograrse con funciones puras. De hecho, algunos lenguajes de programación solo permiten funciones puras. Hay ciertas evidencias de que los programas que usan funciones puras son más rápidos de desarrollar y menos propensos a errores que los programas que usan modificadores. Sin embargo, a veces los modificadores son utiles, y en algunos casos los programas funcionales (es decir, con funciones puras) tienden a ser menos eficientes.</p>
</div>
<div class="paragraph">
<p>En general, recomendamos que escriba funciones puras siempre que sea razonable, y recurra a los modificadores sólo si hay una ventaja convincente. Este enfoque podría llamarse <em>estilo de programación funcional</em>.
</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicio_16_4">Ejercicio 16-4</h4>
<div class="paragraph">
<p>Escriba una versión "pura" de <code>incrementar!</code>, que cree y devuelva un nuevo objeto <code>Hora</code> en vez de modificar el parámetro.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="prototyping_versus_planning">Desarrollo de prototipos frente a la planificación</h3>
<div class="paragraph">
<p>El desarrollo de programas que veremos ahora se llama “desarrollo de prototipos”. En cada una de las funciones anteriores, escribimos un prototipo que realizaba el cálculo básico, y luego lo probamos sobre unos cuantos casos, corrigiendo las fallas a medida que las encontrábamos.
</p>
</div>
<div class="paragraph">
<p>Este enfoque puede ser efectivo, especialmente si aún no tiene un conocimiento profundo del problema. Pero las correcciones incrementales pueden generar código innecesariamente complicado (que considere muchos casos especiales) y poco confiable (es difícil saber si ha encontrado todos los errores).</p>
</div>
<div class="paragraph">
<p>Una alternativa es el <em>desarrollo planificado</em>, en el que la comprensión del problema en profundidad puede facilitar en gran medida la programación. En el caso de sumahora, podemos ver un objeto Hora como ¡un numero de tres dígitos en base 60 (vea <a href="https://en.wikipedia.org/wiki/Sexagesimal" class="bare">https://en.wikipedia.org/wiki/Sexagesimal</a> )!. El atributo segundo es la “columna de unidades”, el atributo minuto es la “columna de los sesentas” y el atributo hora es la “columna de los tres mil seiscientos”.
</p>
</div>
<div class="paragraph">
<p>Cuando escribimos <code>sumahora</code> e <code>incrementar!</code>, efectivamente estábamos sumando en base 60, por eso tuvimos que "acarrear" de una columna a la siguiente.</p>
</div>
<div class="paragraph">
<p>Esta observación sugiere otro enfoque para el problema: podemos convertir los objetos <code>Hora</code> en enteros y aprovechar el hecho de que la computadora sabe realizar aritmética con enteros.</p>
</div>
<div class="paragraph">
<p>La siguiente función convierte un objeto Hora en un entero:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function horaaentero(tiempo)
    minutos = tiempo.hora * 60 + tiempo.minuto
    segundos = minutos * 60 + tiempo.segundo
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora, para convertir un entero en un objeto <code>Hora</code> (recuerde que <code>divrem</code> divide el primer argumento por el segundo, y devuelve el cociente y el resto como una tupla):
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function enteroahora(segundos)
    (minutos, segundo) = divrem(segundos, 60)
    hora, minuto = divrem(minutos, 60)
    Hora(hora, minuto, segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puede que tenga que pensar un poco y realizar algunas pruebas para convencerse de que estas funciones son correctas. Una forma de probarlas es verificar que <code>horaaenteroenteroahora(x == x</code> para muchos valores de <code>x</code>. Este es un ejemplo de prueba de consistencia.</p>
</div>
<div class="paragraph">
<p>Una vez que esté convencido, puede usar estas funciones para reescribir sumahora:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function sumahora(t1, t2)
    segundos = horaaentero(t1) + horaaentero(t2)
    enteroahora(segundos)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta versión es más corta que la original y más fácil de verificar.</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_16_5">Ejercicio 16-5</h4>
<div class="paragraph">
<p>Reescriba <code>incrementar!</code> usando <code>horaaentero</code> y <code>enteroahora</code>.</p>
</div>
<div class="paragraph">
<p>Convertir de base 60 a base 10, y viceversa, es más difícil que solo trabajar con los tiempos. El cambio de base es más abstracto; nuestra intuición para tratar con las horas es mejor.</p>
</div>
<div class="paragraph">
<p>Pero si se nos ocurre tratar los tiempos como números base 60, e invertimos un poco de tiempo en escribir las funciones de conversión (<code>horaaentero</code> y <code>enteroahora</code>), obtenemos un programa más corto, fácil de leer y depurar, y confiable.</p>
</div>
<div class="paragraph">
<p>También hace que sea más fácil añadir funcionalidades posteriormente. Por ejemplo, imagine restar dos <code>Horas</code> para hallar el intervalo entre ellas. El enfoque simple sería implementar una resta con "préstamo". Pero usar funciones de conversión sería más fácil y con mayor probabilidad correcto.</p>
</div>
<div class="paragraph">
<p>Irónicamente, a veces hacer un poblema más complejo (o más general) lo hace más fácil (porque hay menos casos especiales y por lo tanto, el margen de error es menor).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="chap16_debugging">Depuración</h3>
<div class="paragraph">
<p>Un objeto <code>Hora</code> está bien definido si los valores de <code>minuto</code> y <code>segundo</code> están entre 0 y 60 (incluido 0 pero no 60) y si <code>hora</code> es positivo. <code>hora</code> y <code>minuto</code> deben ser valores enteros, pero podríamos permitir que <code>segundo</code> sea fraccional.
</p>
</div>
<div class="paragraph">
<p>Los requisitos como estos se denominan <em>invariantes</em> porque siempre deben ser verdaderos. Dicho de otra manera, si no son ciertas, algo está mal.
</p>
</div>
<div class="paragraph">
<p>Escribir código para verificar invariantes puede ayudar a detectar errores y encontrar sus causas. Por ejemplo, podría tener una función como <code>eshoravalida</code> que tome un objeto <code>Hora</code> y devuelva <code>false</code> si viola una invariante:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function eshoravalida(tiempo)
    if tiempo.hora &lt; 0 || tiempo.minuto &lt; 0 || tiempo.segundo &lt; 0
        return false
    end
    if tiempo.minuto &gt;= 60 || tiempo.segundo &gt;= 60
        return false
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Al comienzo de cada función, puede verificar los argumentos para asegurarse de que sean válidos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function sumahora(t1, t2)
    if !eshoravalida(t1) || !eshoravalida(t2)
        error("objeto Hora en sumahora es inválido")
    end
    segundos = horaaentero(t1) + horaaentero(t2)
    enteroahora(segundos)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>O podría usar una macro <code>@assert</code>, que verifica un invariante dado y genera una excepción si falla:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function sumahora(t1, t2)
    @assert(eshoravalida(t1) &amp;&amp; eshoravalida(t2), "objeto Hora en sumahora es inválido")
    segundos = horaaentero(t1) + horaaentero(t2)
    enteroahora(segundos)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las macros <code>@assert</code> son útiles porque permiten distinguir el código que trata condiciones normales, del código que verifica los errores.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_15">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">desarrollo de prototipos</dt>
<dd>
<p>Una forma de desarrollar programas que involucra generar un prototipo del programa, hacer pruebas y corregir errores a medida que son encontrados.
</p>
</dd>
<dt class="hdlist1">desarrollo planificado</dt>
<dd>
<p>Una forma de desarrollar programas que implica una profunda comprensión del problema, y más planificación que desarrollo incremental o desarrollo de prototipos.
</p>
</dd>
<dt class="hdlist1">función pura</dt>
<dd>
<p>Una función que no modifica los objetos que recibe como parámetros. La mayoría de las funciones puras son productivas.
</p>
</dd>
<dt class="hdlist1">modificador</dt>
<dd>
<p>Una función que modifica uno o más de los objetos que recibe como parámetros. La mayoría de los modificadores son nulos, es decir, entregan resultado <code>nothing</code>.
</p>
</dd>
<dt class="hdlist1">estilo funcional de programación</dt>
<dd>
<p>Un estilo de programación en el que la mayoría de las funciones son puras.
</p>
</dd>
<dt class="hdlist1">invariante</dt>
<dd>
<p>Una condición que nunca debería cambiar durante la ejecución de un programa.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_18">Ejercicios</h3>
<div class="sect3">
<h4 id="ex16-1">Ejercicio 16-6</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>multhora</code> que tome un objeto <code>Hora</code> y un número, y devuelva un nuevo objeto <code>Hora</code> que contenga el producto entre <code>Hora</code> original y el número.
</p>
</div>
<div class="paragraph">
<p>Luego use <code>multhora</code> para escribir una función que tome un objeto <code>Hora</code> que represente el tiempo de duración de una carrera, y un número que represente la distancia, y devuelva un objeto <code>Hora</code> que represente el ritmo promedio (minutos por kilómetro).</p>
</div>
</div>
<div class="sect3">
<h4 id="ex16-2">Ejercicio 16-7</h4>
<div class="paragraph">
<p>Julia proporciona objetos de tiempo similares a los objetos <code>Hora</code> de este capítulo, pero que tienen un amplio conjunto de funciones y operadores. Lea la documentación en <a href="https://docs.julialang.org/en/v1/stdlib/Dates/" class="bare">https://docs.julialang.org/en/v1/stdlib/Dates/</a>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Escriba un programa que tome la fecha actual e imprima el día de la semana.</p>
</li>
<li>
<p>Escriba un programa que tome como entrada una fecha de cumpleaños, e imprima la edad del usuario y la cantidad de días, horas, minutos y segundos hasta su próximo cumpleaños.</p>
</li>
<li>
<p>Para dos personas nacidas en días diferentes, hay un día en que una tiene el doble de edad que la otra. Ese es su Día Doble. Escriba un programa que tome dos cumpleaños y calcule su Día doble.</p>
</li>
<li>
<p>Desafío: Escriba una versión más general que calcule el día en que una persona es \(n\) veces mayor que la otra.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap17">17. Dispatch Múltiple</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Julia permite escribir código que puede funcionar con diferentes tipos. Esto se llama programación genérica.</p>
</div>
<div class="paragraph">
<p>En este capítulo se discutirá sobre las declaraciones de tipo en Julia. Además, se presentan los métodos, que son formas de implementar diferentes comportamientos en una función dependiendo del tipo de sus argumentos. Esto es conocido como dispatch múltiple.</p>
</div>
<div class="sect2">
<h3 id="_declaraciones_de_tipo">Declaraciones de Tipo</h3>
<div class="paragraph">
<p>El operador <code>::</code> asocia <em>anotaciones de tipo</em> con expresiones y variables:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; (1 + 2) :: Float64
ERROR: TypeError: in typeassert, expected Float64, got Int64
julia&gt; (1 + 2) :: Int64
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto ayuda a verificar que el programa funciona de la manera esperada.</p>
</div>
<div class="paragraph">
<p>El operador <code>::</code> también se puede agregar al lado izquierdo de una asignación, o como parte de una declaración.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; function devolverfloat()
           x::Float64 = 100
           x
       end
devolverfloat (generic function with 1 method)
julia&gt; x = devolverfloat()
100.0
julia&gt; typeof(x)
Float64</code></pre>
</div>
</div>
<div class="paragraph">
<p>La variable <code>x</code> siempre es de tipo <code>Float64</code>, y su valor se convierte en un punto flotante si es necesario.</p>
</div>
<div class="paragraph">
<p>También se puede añadir una anotación de tipo al encabezado de una definición de función:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function sinc(x)::Float64
    if x == 0
        return 1
    end
    sin(x)/(x)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El valor de retorno de <code>sinc</code> siempre se convierte al tipo <code>Float64</code>.</p>
</div>
<div class="paragraph">
<p>En Julia, cuando se omiten los tipos, los valores pueden ser de cualquier tipo (<code>Any</code>).
</p>
</div>
</div>
<div class="sect2">
<h3 id="_métodos">Métodos</h3>
<div class="paragraph">
<p>En <a href="#chap16">Estructuras y Funciones</a>, definimos una estructura llamada <code>Hora</code> y en <a href="#time">Tiempo</a>, escribimos una función llamada <code>imprimirhora</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">using Printf

struct Hora
    hora :: Int64
    minuto :: Int64
    segundo :: Int64
end

function imprimirhora(tiempo)
    @printf("%02d:%02d:%02d", tiempo.hora, tiempo.minuto, tiempo.segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para mejorar el rendimiento, se pueden (y deben) agregar las declaraciones de tipo a los atributos en una definición de estructura.</p>
</div>
<div class="paragraph">
<p>Para llamar a esta función, debe pasarle un objeto <code>Hora</code> como argumento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; inicio = Hora(9, 45, 0)
Hora(9, 45, 0)
julia&gt; imprimirhora(inicio)
09:45:00</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para agregar un <em>método</em> a la función <code>imprimirhora</code>; con el fin de que esta solo acepte como argumento un objeto <code>Hora</code>, todo lo que tenemos que hacer es agregar <code>::</code> seguido de <code>Hora</code> al argumento <code>tiempo</code> en la definición de función:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimirhora(tiempo::Hora)
    @printf("%02d:%02d:%02d", tiempo.hora, tiempo.minuto, tiempo.segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un método es una definición de función con una <em>especificación</em>: <code>imprimirhora</code> tiene un argumento de tipo <code>Hora</code>.
</p>
</div>
<div class="paragraph">
<p>Llamar a la función <code>imprimirhora</code> con un objeto <code>Hora</code> produce el mismo resultado que antes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; imprimirhora(inicio)
09:45:00</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora redefinamos el primer método sin la anotación de tipo <code>::</code>, lo cual permite un argumento de cualquier tipo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function imprimirhora(tiempo)
    println("No sé cómo imprimir el tiempo del argumento.")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si llama a la función <code>imprimirhora</code> con un objeto diferente de <code>Hora</code>, se obtendrá:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; imprimirhora(150)
No sé cómo imprimir el tiempo del argumento.</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicio_17_1">Ejercicio 17-1</h4>
<div class="paragraph">
<p>Reescriba <code>horaaentero</code> y <code>enteroahora</code> (de <a href="#prototyping_versus_planning">Desarrollo de prototipos frente a la planificación</a>) especificando el tipo de los argumentos.
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejemplos_adicionales">Ejemplos Adicionales</h3>
<div class="paragraph">
<p>Aquí hay una versión de la función <code>incrementar</code> (Ejercicio 16-5 de <a href="#modificadores">[modificadores]</a>) reescrita especificando el tipo de los argumentos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function incrementar(tiempo::Hora, segundos::Int64)
    segundos += horaaentero(tiempo)
    enteroahora(segundos)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tenga en cuenta que ahora, <code>incrementar</code> es una función pura, no un modificador.</p>
</div>
<div class="paragraph">
<p>Así es como se llama a la función incrementar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; inicio = Hora(9, 45, 0)
Hora(9, 45, 0)
julia&gt; incrementar(inicio, 1337)
Hora(10, 7, 17)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si colocamos los argumentos en el orden incorrecto, obtendremos un error:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; incrementar(1337, inicio)
ERROR: MethodError: no method matching incrementar(::Int64, ::Hora)</code></pre>
</div>
</div>
<div class="paragraph">
<p>La especificación del método es <code>incrementar(tiempo::Hora, segundos::Int64)</code>, no <code>incrementar(segundos::Int64, tiempo::Hora)</code>.</p>
</div>
<div class="paragraph">
<p>Al reescribir <code>estadespues</code> (Ejercicio 16-2 de <a href="#modificadores">[modificadores]</a>) para que solo acepte objetos <code>Hora</code> se tiene:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function estadespues(t1::Hora, t2::Hora)
    (t1.hora, t1.minuto, t1.segundo) &gt; (t2.hora, t2.minuto, t2.segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por cierto, los argumentos opcionales permiten definir múltiples métodos. Por ejemplo, esta definición:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function f(a=1, b=2)
    a + 2b
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>se traduce en los siguientes tres métodos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">f(a, b) = a + 2b
f(a) = f(a, 2)
f() = f(1, 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Estas expresiones son definiciones válidas de métodos de Julia. Esta es una notación abreviada para definir funciones/métodos.</p>
</div>
</div>
<div class="sect2">
<h3 id="constructor">Constructores</h3>
<div class="paragraph">
<p>Un <em>constructor</em> es una función especial que se llama para crear un objeto. Los métodos por defecto del constructor <code>Hora</code> tienen las siguientes especificaciones:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">Hora(hora, minuto, segundo)
Hora(hora::Int64, minuto::Int64, segundo::Int64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>También podemos agregar nuestros propios métodos de <em>constructores externos</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Hora(tiempo::Hora)
    Hora(tiempo.hora, tiempo.minuto, tiempo.segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este método se llama <em>constructor de copia</em> porque el nuevo objeto <code>Hora</code> es una copia de su argumento.
</p>
</div>
<div class="paragraph">
<p>Para imponer invariantes, necesitamos métodos de <em>constructor interno</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Hora
    hora :: Int64
    minuto :: Int64
    segundo :: Int64
    function Hora(hora::Int64=0, minuto::Int64=0, segundo::Int64=0)
        @assert(0 ≤ minuto &lt; 60, "Minuto no está entre 0 y 60.")
        @assert(0 ≤ segundo &lt; 60, "Segundo no está entre 0 y 60.")
        new(hora, minuto, segundo)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La estructura <code>Hora</code> tiene ahora 4 métodos de constructor interno:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">Hora()
Hora(hora::Int64)
Hora(hora::Int64, minuto::Int64)
Hora(hora::Int64, minuto::Int64, segundo::Int64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un método de constructor interno siempre se define dentro del bloque de una declaración de tipo, y tiene acceso a una función especial llamada <code>new</code> que crea objetos del tipo recién declarado.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>Si se define algún constructor interno, el constructor por defecto ya no está disponible. Tienes que escribir explícitamente todos los constructores internos que necesitas.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>También existe un método sin argumentos de la función local <code>new</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">mutable struct Hora
    hora :: Int64
    minuto :: Int64
    segundo :: Int64
    function Hora(hora::Int64=0, minuto::Int64=0, segundo::Int64=0)
        @assert(0 ≤ minuto &lt; 60, "Minuto está entre 0 y 60.")
        @assert(0 ≤ segundo &lt; 60, "Segundo está entre 0 y 60.")
        tiempo = new()
        tiempo.hora = hora
        tiempo.minuto = minuto
        tiempo.segundo = segundo
        tiempo
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto permite construir estructuras de datos recursivas, es decir, una estructura donde uno de los atributos es la estructura misma. En este caso, la estructura debe ser mutable porque sus atributos se modifican después de la creación de instancias.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_show"><code>show</code></h3>
<div class="paragraph">
<p><code>show</code> es una función especial que devuelve la representación de cadena de un objeto. Por ejemplo, a continuación se muestra el método <code>show</code> para objetos <code>Hora</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">using Printf

function Base.show(io::IO, tiempo::Hora)
    @printf(io, "%02d:%02d:%02d", tiempo.hora, tiempo.minuto, tiempo.segundo)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta función guarda como cadena de texto una hora dada, en el archivo al que io hace referencia.</p>
</div>
<div class="paragraph">
<p>El prefijo <code>Base</code> es necesario porque queremos agregar un nuevo método a la función <code>Base.show</code>.</p>
</div>
<div class="paragraph">
<p>Cuando se imprime un objeto, Julia llama a la función <code>show</code> (esto ocurre siempre, y como agregamos un nuevo método a la función <code>Base.show</code>, entonces se muestra Hora con el formato que queremos):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; tiempo = Hora(9, 45, 0)
09:45:00</code></pre>
</div>
</div>
<div class="paragraph">
<p>Personalmente, cuando escribo un nuevo tipo compuesto, casi siempre empiezo escribiendo un constructor externo; lo que facilita la creación de instancias de objetos, y <code>show</code>; que es útil para la depuración.</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_17_2">Ejercicio 17-2</h4>
<div class="paragraph">
<p>Escriba un método de constructor externo para la clase <code>Punto</code> que tome <code>x</code> e <code>y</code> como parámetros opcionales y los asigne a los atributos correspondientes.
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sobrecarga_de_operadores">Sobrecarga de Operadores</h3>
<div class="paragraph">
<p>Es posible cambiar la definición de los operadores cuando se aplican a tipos definidos por el usuario. Esto se hace definiendo métodos del operador. Por ejemplo, si definimos un método llamado <code>+</code> con dos argumentos <code>Hora</code>, podríamos usar el operador <code>+</code> en los objetos <code>Hora</code>.</p>
</div>
<div class="paragraph">
<p>Así es como se vería la definición:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">import Base.+

function +(t1::Hora, t2::Hora)
    segundos = horaaentero(t1) + horaaentero(t2)
    enteroahora(segundos)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La sentencia import agrega el operador <code>+</code> al ámbito local (local scope) para que se puedan agregar métodos.</p>
</div>
<div class="paragraph">
<p>A continuación se muestra cómo usar este operador para objetos Hora.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; inicio = Hora(9, 45)
09:45:00
julia&gt; duracion = Hora(1, 35, 0)
01:35:00
julia&gt; inicio + duracion
11:20:00</code></pre>
</div>
</div>
<div class="paragraph">
<p>Al aplicar el operador <code>+</code> a objetos <code>Hora</code>, Julia invoca el método recién agregado. Cuando REPL muestra el resultado, Julia invoca a <code>show</code>. ¡Hay muchas cosas pasando que no vemos!</p>
</div>
<div class="paragraph">
<p>Ampliar el comportamiento de los operadores de modo que funcionen con tipos definidos por el usuario/programador se denomina <em>sobrecarga del operador</em>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_dispatch_múltiple">Dispatch Múltiple</h3>
<div class="paragraph">
<p>En la sección anterior sumamos dos objetos <code>Hora</code>. Imagine que ahora queremos sumar un número entero a un objeto <code>Hora</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function +(tiempo::Hora, segundos::Int64)
    incrementar(tiempo, segundos)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>He aquí un ejemplo que usa el operador <code>+</code> con un objeto <code>Hora</code> y un entero:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; inicio = Hora(9, 45)
09:45:00
julia&gt; inicio + 1337
10:07:17</code></pre>
</div>
</div>
<div class="paragraph">
<p>La suma es un operador conmutativo, por lo que debemos agregar otro método.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function +(segundos::Int64, tiempo::Hora)
  tiempo + segundos
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Y obtenemos el mismo resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; 1337 + inicio
10:07:17</code></pre>
</div>
</div>
<div class="paragraph">
<p>La elección del método a ejecutar cuando se aplica una función se llama <em>dispatch</em>. Julia permite que el proceso de dispatch elija a cuál de los métodos de una función llamar en función del número y tipo de los argumentos dados. El uso de todos los argumentos de una función para elegir el método que se debe invocar se conoce como <em>dispatch múltiple</em>.
</p>
</div>
<div class="sect3">
<h4 id="_ejercicio_17_3">Ejercicio 17-3</h4>
<div class="paragraph">
<p>Escribir los siguientes métodos <code>+</code> para objetos Punto:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si ambos operandos son objetos Punto, el método debería devolver un nuevo objeto Punto cuya coordenada <code>x</code> sea la suma de las coordenadas <code>x</code> de los operandos. De manera análoga para la coordenada <code>y</code>.</p>
</li>
<li>
<p>Si el primer o el segundo operando es una tupla, el método debe agregar el primer elemento de la tupla a la coordenada <code>x</code> y el segundo elemento a la coordenada <code>y</code>, y devolver un nuevo objeto Punto con el resultado.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_programación_genérica">Programación Genérica</h3>
<div class="paragraph">
<p>El dispatch múltiple es útil cuando es necesario, pero (afortunadamente) no siempre lo es. A menudo puede evitarse escribiendo funciones que funcionen correctamente para argumentos de diferentes tipos.</p>
</div>
<div class="paragraph">
<p>Muchas de las funciones que hemos escrito para cadenas también funcionan para otros tipos de secuencia. Por ejemplo, en <a href="#dictionary_collection_counters">Diccionario como una Colección de Frecuencias</a> usamos <code>histograma</code> para contar la cantidad de veces que cada letra aparece en una palabra.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function histograma(s)
    d = Dict()
    for c in s
        if c ∉ keys(d)
            d[c] = 1
        else
            d[c] += 1
        end
    end
    d
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta función también funciona para listas, tuplas e incluso diccionarios, siempre y cuando los elementos de <code>s</code> sean hashables, ya que así pueden usarse como claves de <code>d</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t = ("spam", "huevo", "spam", "spam", "tocino", "spam")
("spam", "huevo", "spam", "spam", "tocino", "spam")
julia&gt; histograma(t)
Dict{Any,Any} with 3 entries:
  "spam"   =&gt; 4
  "huevo"  =&gt; 1
  "tocino" =&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las funciones que pueden tomar parámetros de diferentes tipos se llaman <em>polimórficas</em>. El polimorfismo puede facilitar la reutilización del código.
</p>
</div>
<div class="paragraph">
<p>Por ejemplo, la función integrada <code>sum</code>, que suma los elementos de una secuencia, funciona siempre que los elementos de la secuencia permitan la suma.
</p>
</div>
<div class="paragraph">
<p>Como se añadió el método <code>+</code> para los objetos <code>Hora</code>, entonces se puede usar <code>sum</code> para <code>Hora</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; t1 = Hora(1, 7, 2)
01:07:02
julia&gt; t2 = Hora(1, 5, 8)
01:05:08
julia&gt; t3 = Hora(1, 5, 0)
01:05:00
julia&gt; sum((t1, t2, t3))
03:17:10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si todas las operaciones realizadas dentro de la función se pueden aplicar al tipo, la función se puede aplicar al tipo.</p>
</div>
<div class="paragraph">
<p>El mejor tipo de polimorfismo es el que no se busca; cuando usted descubre que una función que había escrito se puede aplicar a un tipo para el que nunca la había planeado.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_interfaz_e_implementación">Interfaz e implementación</h3>
<div class="paragraph">
<p>Uno de los objetivos del dispatch múltiple es hacer que el software sea más fácil de mantener, lo que significa poder mantener el programa funcionando cuando otras partes del sistema cambian, y modificar el programa para cumplir con los nuevos requisitos.</p>
</div>
<div class="paragraph">
<p>Una técnica de diseño que ayuda a lograr ese objetivo es mantener las interfaces separadas de las implementaciones. Esto significa que los métodos que tienen un argumento con anotación de tipo no deberían depender de cómo se representan los atributos de ese tipo.
</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en este capítulo desarrollamos una estructura que representa una hora del día. Los métodos que tienen un argumento con anotación de este tipo incluyen <code>horaaentero</code>, <code>estadespues</code> y <code>+</code>.</p>
</div>
<div class="paragraph">
<p>Podríamos implementar esos métodos de varias maneras. Los detalles de la implementación dependen de cómo representamos <code>Hora</code>. En este capítulo, los atributos de un objeto <code>Hora</code> son <code>hora</code>, <code>minuto</code> y <code>segundo</code>.</p>
</div>
<div class="paragraph">
<p>Otra opción sería reemplazar estos atributos con un solo entero que represente el número de segundos desde la medianoche. Esta implementación haría que algunas funciones, como <code>estadespues</code>, sean más fáciles de escribir, pero hace que otras sean más difíciles.</p>
</div>
<div class="paragraph">
<p>Después de implementar un tipo, puede descubrir una mejor implementación. Si otras partes del programa están usando su tipo, cambiar la interfaz puede llevar mucho tiempo y ser propenso a errores.</p>
</div>
<div class="paragraph">
<p>Pero si hizo un buen diseñó de interfaz, puede cambiar la implementación sin cambiar la interfaz, lo que significa que otras partes del programa no tienen que cambiar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_14">Depuración</h3>
<div class="paragraph">
<p>Llamar a una función con los argumentos correctos puede ser difícil cuando se especifica más de un método para la función. Julia permite examinar las especificaciones de los métodos de una función.</p>
</div>
<div class="paragraph">
<p>Para saber qué métodos están disponibles para una función determinada, puede usar la función <code>methods</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; methods(imprimirhora)
# 2 methods for generic function "imprimirhora":
[1] printtime(time::MyTime) in Main at REPL[3]:2
[2] printtime(time) in Main at REPL[4]:2</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, la función <code>imprimirhora</code> tiene 2 métodos: uno con un argumento <code>Hora</code> y otro con un argumento <code>Any</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_16">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">anotación de tipo</dt>
<dd>
<p>El operador <code>::</code> seguido de un tipo que indica que una expresión o una variable es de ese tipo.
</p>
</dd>
<dt class="hdlist1">método</dt>
<dd>
<p>Una definición de un posible comportamiento de una función.
</p>
</dd>
<dt class="hdlist1">dispatch</dt>
<dd>
<p>La elección de qué método ejecutar cuando se ejecuta una función.
</p>
</dd>
<dt class="hdlist1">especificación</dt>
<dd>
<p>El número y tipo de argumentos de un método que permite al dispatch seleccionar el método más específico de una función durante la llamada a función.
</p>
</dd>
<dt class="hdlist1">constructor externo</dt>
<dd>
<p>Constructor definido fuera de la definición de tipo para definir métodos útiles para crear un objeto.
</p>
</dd>
<dt class="hdlist1">constructor interno</dt>
<dd>
<p>Constructor definido dentro de la definición de tipo para imponer invariantes o para construir objetos recursivos.
</p>
</dd>
<dt class="hdlist1">constructor por defecto</dt>
<dd>
<p>Constructor interno que está disponible cuando el usuario no define constructores internos.
</p>
</dd>
<dt class="hdlist1">constructor de copia</dt>
<dd>
<p>Método de constructor externo de un tipo, que tiene como único argumento un objeto del tipo. Crea un nuevo objeto que es una copia del argumento.
</p>
</dd>
<dt class="hdlist1">sobrecarga de operadores</dt>
<dd>
<p>Ampliar el comportamiento de los operadores como ++ de modo que trabajen con tipos definidos por el usuario.
</p>
</dd>
<dt class="hdlist1">dispatch múltiple</dt>
<dd>
<p>Dispatch basado en todos los argumentos de una función.
</p>
</dd>
<dt class="hdlist1">programación genérica</dt>
<dd>
<p>Escribir código que pueda funcionar con más de un tipo.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_19">Ejercicios</h3>
<div class="sect3">
<h4 id="ex17-1">Ejercicio 17-4</h4>
<div class="paragraph">
<p>Cambie los atributos de <code>Hora</code> para que sea un solo número entero que represente los segundos desde la medianoche. Luego modifique los métodos definidos en este capítulo para que funcionen con la nueva implementación.</p>
</div>
</div>
<div class="sect3">
<h4 id="ex17-2">Ejercicio 17-5</h4>
<div class="paragraph">
<p>Escriba una definición para un tipo llamado <code>Canguro</code>, con un atributo llamado <code>contenidodemarsupio</code> de tipo <code>Arreglo</code> y los siguientes métodos:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un constructor que inicializa <code>contenidodemarsupio</code> a un arreglo vacío.</p>
</li>
<li>
<p>Un método llamado <code>ponerenmarsupio</code> que tome un objeto <code>Canguro</code> y un objeto de cualquier tipo y lo agregue a <code>contenidodemarsupio</code>.
</p>
</li>
<li>
<p>Un método <code>show</code> que devuelva una representación de cadena del objeto <code>Canguro</code> y el contenido del marsupio.
</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Pruebe su código creando dos objetos <code>Canguro</code>, asignándolos a variables llamadas <code>cangu</code> y <code>ro</code>, y luego agregando <code>ro</code> al contenido del marsupio de <code>cangu</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap18">18. Subtipos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En el capítulo anterior se presentó el dispatch múltiple y los métodos polimórficos. Al no especificar el tipo de los argumentos de un método, este se puede invocar con argumentos de cualquier tipo. Ahora veremos cómo especificar un subconjunto de tipos permitidos en las especificaciones de un método.</p>
</div>
<div class="paragraph">
<p>En este capítulo se explica el concepto de subtipo usando tipos que representan naipes, mazos de naipes y manos de póker.</p>
</div>
<div class="paragraph">
<p>Si nunca has jugado póker, puedes leer sobre él en <a href="https://es.wikipedia.org/wiki/P%C3%B3quer" class="bare">https://es.wikipedia.org/wiki/P%C3%B3quer</a>, aunque no es necesario, pues explicaremos todo lo necesario para los ejercicios.</p>
</div>
<div class="sect2">
<h3 id="_naipes">Naipes</h3>
<div class="paragraph">
<p>Hay cincuenta y dos naipes en una baraja inglesa, cada uno de los cuales pertenece a uno de los cuatro palos y tiene un valor. Los palos son Picas (<code>♠</code>), Corazones (<code>♥</code>), Diamantes (<code>♦</code>) y Tréboles (<code>♣</code>). Los valores son As (A), 2, 3, 4, 5, 6, 7, 8, 9, 10, Jota (J), Reina (Q) y Rey (K). Dependiendo del tipo de juego, el valor del As puede ser mayor que al Rey o inferior al 2.</p>
</div>
<div class="paragraph">
<p>Si queremos definir un nuevo objeto para representar un naipe, son obvios los atributos que debería tener: valor y palo. Lo que no es tan obvio es el tipo que se debe dar a estos atributos. Una opción es usar cadenas de caracteres que contengan palabras como <code>"Picas"</code> para los palos y <code>"Reina"</code> para los valores. Un problema de esta implementación es que no sería fácil comparar naipes para ver cuál tiene mayor valor o palo.</p>
</div>
<div class="paragraph">
<p>Una alternativa es usar números enteros para <em>codificar</em> los valores y palos. En este contexto, "codificar" significa definir una asociación entre números y palos, o entre números y valores. Este tipo de codificación no está relacionada con cifrar o traducir a un código secreto (eso sería "cifrado").
</p>
</div>
<div class="paragraph">
<p>Por ejemplo, esta tabla muestra una correspondencia entre palos y códigos (números) enteros:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>♠</code>  \(\mapsto\)  4</p>
</li>
<li>
<p><code>♥</code>  \(\mapsto\)  3</p>
</li>
<li>
<p><code>♦</code>  \(\mapsto\)  2</p>
</li>
<li>
<p><code>♣</code>  \(\mapsto\)  1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este código facilita la comparación de naipes; los palos más altos se asignan a los números más altos, por lo tanto podemos comparar los palos al comparar sus códigos.</p>
</div>
<div class="paragraph">
<p>Estamos usando el símbolo \(\mapsto\) para dejar en claro que estas asignaciones no son parte de Julia. Forman parte del diseño del programa, pero no aparecen explícitamente en el código.</p>
</div>
<div class="paragraph">
<p>La definición de estructura de <code>Naipe</code> se ve así:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Naipe
    palo :: Int64
    valor :: Int64
    function Naipe(palo::Int64, valor::Int64)
        @assert(1 ≤ palo ≤ 4, "el palo no está entre 1 y 4")
        @assert(1 ≤ valor ≤ 13, "el valor no está entre 1 y 13")
        new(palo, valor)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para crear un <code>Naipe</code>, se debe llamar a <code>Naipe</code> con el palo y el valor del naipe deseado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; reina_de_diamantes = Naipe(2, 12)
Naipe(2, 12)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_variables_globales">Variables Globales</h3>
<div class="paragraph">
<p>Para poder imprimir los objetos <code>Naipe</code> de una manera que sea fácil de leer, necesitamos establecer una correspondencia entre los códigos enteros, y sus correspondientes palos y valores. Una manera natural de hacer esto es con arreglos de cadenas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">const nombres_palo = ["♣", "♦", "♥", "♠"]
const nombres_valor = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las variables <code>nombres_palo</code> y <code>nombres_valor</code> son variables globales. La declaración <code>const</code> significa que la variable solo se puede asignar una vez. Esto resuelve el problema de rendimiento de las variables globales.
</p>
</div>
<div class="paragraph">
<p>Ahora podemos implementar un método <code>show</code> apropiado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Base.show(io::IO, naipe::Naipe)
    print(io, nombres_valor[naipe.valor], nombres_palo[naipe.palo])
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La expresión <code>nombres_valor[naipe.valor]</code> significa "use el atributo <code>valor</code> del objeto <code>naipe</code> como índice en el arreglo <code>nombres_valor</code>, y seleccione la cadena correspondiente".</p>
</div>
<div class="paragraph">
<p>Con los métodos que tenemos hasta ahora, podemos crear e imprimir naipes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Naipe(3, 11)
J♥</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_comparación_de_naipes">Comparación de naipes</h3>
<div class="paragraph">
<p>Para los tipos integrados, existen operadores relacionales (<code>&lt;</code>, <code>&gt;</code>, <code>==</code>, etc.) que comparan valores y determinan cuándo uno es mayor, menor, o igual a otro. Para los tipos definidos por el usuario, podemos sustituir el comportamiento de estos operadores si proporcionamos un método llamado: <code>&lt;</code>.</p>
</div>
<div class="paragraph">
<p>El orden correcto de los naipes no es obvio. Por ejemplo, ¿cuál es mejor, el 3 de Tréboles o el 2 de Diamantes? Uno tiene un valor mayor, pero el otro tiene un palo mayor. Para hacer que los naipes sean comparables, se debe decidir qué es más importante: valor o palo.</p>
</div>
<div class="paragraph">
<p>La respuesta puede depender del tipo de juego, pero para simplificar las cosas, haremos la elección arbitraria de que el palo es más importante, por lo que todas los tréboles superan a todos los diamantes, y así sucesivamente.</p>
</div>
<div class="paragraph">
<p>Con esa decisión tomada, podemos escribir <code>&lt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">import Base.&lt;

function &lt;(c1::Naipe, c2::Naipe)
    (c1.palo, c1.valor) &lt; (c2.palo, c2.valor)
end</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicio_18_1">Ejercicio 18-1</h4>
<div class="paragraph">
<p>Escriba un método <code>&lt;</code> para objetos <code>Hora</code>. Puede usar comparación de tuplas, o comparación de enteros.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_prueba_unitaria">Prueba unitaria</h3>
<div class="paragraph">
<p>Una <em>prueba unitaria</em> permite verificar el correcto funcionamiento de su código comparando los resultados obtenidos con los esperados. Esto puede ser útil para verificar que su código funciona correctamente después de haberlo modificado, y también es una forma de predefinir el comportamiento correcto de su código durante el desarrollo.
</p>
</div>
<div class="paragraph">
<p>Se pueden realizar pruebas unitarias simples con las macros <code>@test</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; using Test

julia&gt; @test Naipe(1, 4) &lt; Naipe(2, 4)
Test Passed
julia&gt; @test Naipe(1, 3) &lt; Naipe(1, 4)
Test Passed</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@test</code> devuelve <code>"Test Passed"</code> ("Prueba aprobada") si la expresión que sigue es <code>true</code>, <code>"Test Failed"</code> ("Prueba fallida") si es <code>false</code>, y <code>"Error Result"</code> ("Resultado de error") si no se pudo evaluar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mazos">Mazos</h3>
<div class="paragraph">
<p>Ahora que ya tenemos Naipes, el próximo paso es definir Mazos. Como un mazo está compuesto de naipes, naturalmente cada Mazo contendrá un arreglo de naipes como atributo.</p>
</div>
<div class="paragraph">
<p>A continuación se muestra una definición para <code>Mazo</code>. El constructor crea el atributo naipes y genera la baraja estándar de cincuenta
y dos naipes:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Mazo
    naipes :: Array{Naipe, 1}
end

function Mazo()
    mazo = Mazo(Naipe[])
    for palo in 1:4
        for valor in 1:13
            push!(mazo.naipes, Naipe(palo, valor))
        end
    end
    mazo
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La forma más fácil de poblar el mazo es mediante un bucle anidado. El bucle exterior enumera los palos desde 1 hasta 4. El bucle interior enumera los valores desde 1 hasta 13. Cada iteración crea un nuevo <code>Naipe</code> con el palo y valor actual, y lo agrega a <code>mazo.naipes</code>.</p>
</div>
<div class="paragraph">
<p>Este es un método <code>show</code> para <code>Mazo</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Base.show(io::IO, mazo::Mazo)
    for naipe in mazo.naipes
        print(io, naipe, " ")
    end
    println()
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Así es como se ve el resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Mazo()
A♣ 2♣ 3♣ 4♣ 5♣ 6♣ 7♣ 8♣ 9♣ 10♣ J♣ Q♣ K♣ A♦ 2♦ 3♦ 4♦ 5♦ 6♦ 7♦ 8♦ 9♦ 10♦ J♦ Q♦ K♦ A♥ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ Q♥ K♥ A♠ 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_añadir_eliminar_barajar_y_ordenar">Añadir, Eliminar, Barajar y Ordenar</h3>
<div class="paragraph">
<p>Para repartir los naipes, nos gustaría tener una función que elimine un naipe del mazo y lo devuelva. La función <code>pop!</code> proporciona una forma conveniente de realizar esto:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Base.pop!(mazo::Mazo)
    pop!(mazo.naipes)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como <code>pop!</code> elimina el último naipe en el arreglo, estamos repartiendo desde el extremo inferior del mazo.</p>
</div>
<div class="paragraph">
<p>Para añadir un naipe, podemos usar la función <code>push!</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Base.push!(mazo::Mazo, naipe::Naipe)
    push!(mazo.naipes, naipe)
    mazo
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un método como este, que usa otro método sin hacer mucho más se llama <em>enchapado</em>. La metáfora proviene de la carpintería, donde un enchapado es una capa fina de madera de alta calidad que se pega a la superficie de una pieza de madera de baja calidad para mejorar su apariencia.
</p>
</div>
<div class="paragraph">
<p>En este caso, <code>push!</code> es un método "fino" que expresa una operación de arreglos adecuada para los mazos. Mejora la apariencia o interfaz, de la implementación.</p>
</div>
<div class="paragraph">
<p>También podemos escribir un método llamado <code>shuffle!</code> (barajar en inglés) Usando la función <code>Random.shuffle!</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">using Random

function Random.shuffle!(mazo::Mazo)
    shuffle!(mazo.naipes)
    mazo
end</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicio_18_2">Ejercicio 18-2</h4>
<div class="paragraph">
<p>Escriba una función llamada <code>sort!</code> (ordenar en inglés) que use la función <code>sort!</code> para ordenar las cartas en un Mazo. <code>sort!</code> usa el método <code>isless</code> que definimos para determinar el orden.
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tipos_abstractos_y_subtipos">Tipos Abstractos y Subtipos</h3>
<div class="paragraph">
<p>Queremos que un tipo represente una "mano", es decir, los naipes que tiene un jugador. Una mano es similar a un mazo: ambos están compuestos de un conjunto de naipes, y ambos requieren de operaciones tales como agregar y eliminar una carta.</p>
</div>
<div class="paragraph">
<p>Una mano es diferente de un mazo en ciertos aspectos; podemos querer realizar ciertas operaciones sobre una mano que no tendrían sentido sobre un mazo. Por ejemplo, en el poker querríamos comparar una mano con otra para ver quién gana. En bridge, necesitamos calcular el puntaje de la mano para así poder hacer la subasta.</p>
</div>
<div class="paragraph">
<p>Por lo tanto, necesitamos una forma de agrupar los <em>tipos concretos</em> que están relacionados. En Julia, esto se hace definiendo un <em>abstract type</em> (tipo abstracto en inglés) que sea padre de <code>Mazo</code> y <code>Mano</code>. A esto se le llama <em>crear subtipos</em>.
</p>
</div>
<div class="paragraph">
<p>Llamemos al tipo abstracto <code>ConjuntoDeCartas</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">abstract type ConjuntoDeCartas end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se puede crear un nuevo tipo abstracto con la palabra reservada <code>abstract type</code>. De manera opcional, se puede especificar un tipo "padre" de una estructura colocando después del nombre de esta, el símbolo <code>&lt;:</code> seguido del nombre de un tipo abstracto existente.
</p>
</div>
<div class="paragraph">
<p>Cuando no se proporciona un <em>supertipo</em>, el supertipo por defecto es <code>Any</code>, es decir, un tipo abstracto predefinido del que todos los objetos son instancias y del que todos los tipos son <em>subtipos</em>.
</p>
</div>
<div class="paragraph">
<p>Ahora podemos expresar que <code>Mazo</code> es un "hijo" de <code>ConjuntoDeCartas</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Mazo &lt;: ConjuntoDeCartas
    naipes :: Array{Naipe, 1}
end

function Mazo()
    mazo = Mazo(Naipe[])
    for palo in 1:4
        for valor in 1:13
            push!(mazo.naipes, Naipe(palo, valor))
        end
    end
    mazo
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador <code>isa</code> comprueba si un objeto es de un tipo dado:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; mazo = Mazo();

julia&gt; mazo isa ConjuntoDeCartas
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una mano también es un <code>ConjuntoDeCartas</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Mano &lt;: ConjuntoDeCartas
    naipes :: Array{Naipe, 1}
    etiqueta :: String
end

function Mano(etiqueta::String="")
    Mano(Naipe[], etiqueta)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>En lugar de llenar la mano con 52 naipes nuevos, el constructor de <code>Mano</code> inicializa <code>naipes</code> a un arreglo vacío. Se puede etiquetar a la <code>Mano</code> pasando un argumento opcional al constructor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; mano = Mano("nueva mano")
Mano(Naipe[], "nueva mano")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tipos_abstractos_y_funciones">Tipos Abstractos y Funciones</h3>
<div class="paragraph">
<p>Ahora podemos expresar las operaciones que tienen en común <code>Mazo</code> y <code>Mano</code>, al ser funciones que tienen como argumento a <code>ConjuntoDeCartas</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Base.show(io::IO, cdc::ConjuntoDeCartas)
    for naipe in cdc.naipes
        print(io, naipe, " ")
    end
end

function Base.pop!(cdc::ConjuntoDeCartas)
    pop!(cdc.naipes)
end

function Base.push!(cdc::ConjuntoDeCartas, naipe::Naipe)
    push!(cdc.naipes, naipe)
    nothing
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Podemos usar <code>pop!</code> y <code>push!</code> para repartir una carta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; mazo = Mazo()
A♣ 2♣ 3♣ 4♣ 5♣ 6♣ 7♣ 8♣ 9♣ 10♣ J♣ Q♣ K♣ A♦ 2♦ 3♦ 4♦ 5♦ 6♦ 7♦ 8♦ 9♦ 10♦ J♦ Q♦ K♦ A♥ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ Q♥ K♥ A♠ 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠
julia&gt; shuffle!(mazo)
6♣ 9♠ 10♠ 8♠ 8♣ Q♣ 9♦ 3♦ 6♥ 4♥ J♣ 7♦ 2♠ 5♣ 3♣ 2♥ 10♥ 6♠ Q♥ 4♦ 2♦ 4♣ 10♦ J♥ 8♥ 5♠ K♣ 3♠ 7♥ A♠ K♠ A♦ 9♥ 6♦ 9♣ Q♠ J♦ K♦ 3♥ 7♠ A♥ A♣ Q♦ 5♦ 2♣ 7♣ 5♥ 8♦ 10♣ J♠ 4♠ K♥
julia&gt; naipe = pop!(mazo)
K♥
julia&gt; push!(mano, naipe)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A continuación, encapsularemos este código en una función llamada <code>mover!</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function mover!(cdc1::ConjuntoDeCartas, cdc2::ConjuntoDeCartas, n::Int)
    @assert 1 ≤ n ≤ length(cs1.naipes)
    for i in 1:n
        naipe = pop!(cdc1)
        push!(cdc2, naipe)
    end
    nothing
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>mover!</code> toma tres argumentos: dos objetos <code>ConjuntoDeCartas</code> y el número de cartas a repartir. Modifica ambos objetos <code>ConjuntoDeCartas</code>, y devuelve <code>nothing</code>.</p>
</div>
<div class="paragraph">
<p>En algunos juegos, las cartas se mueven de una mano a otra, o de una mano al mazo. Puedes usar <code>mover!</code> para cualquiera de estas operaciones: <code>cdc1</code> y <code>cdc2</code> pueden ser un <code>Mazo</code> o una <code>Mano</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_diagramas_de_tipos">Diagramas de tipos</h3>
<div class="paragraph">
<p>Hasta ahora hemos visto diagramas de pila; que muestran el estado de un programa, y diagramas de objetos; que muestran los atributos de un objeto y sus valores. Estos diagramas son como una foto sacada durante la ejecución de un programa, por lo que cambian a medida que se ejecuta el programa.</p>
</div>
<div class="paragraph">
<p>También son muy detallados; en algunos casos demasiado detallados. Un <em>diagrama de tipos</em> es una representación más abstracta de la estructura de un programa. En vez de mostrar objetos individuales, muestra los tipos y las relaciones entre ellos.
</p>
</div>
<div class="paragraph">
<p>Hay varias formas de relación entre tipos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los objetos de un tipo concreto pueden contener referencias a objetos de otro tipo. Por ejemplo, cada Rectangulo contiene una referencia a un Punto, y cada Mazo contiene referencias a un conjunto de Naipes. Este tipo de relación se llama <em>TIENE-UN</em>, como por ejemplo "un Rectángulo tiene un Punto".
</p>
</li>
<li>
<p>Un tipo concreto puede tener un tipo abstracto como supertipo. Esta relación se llama <em>ES-UN</em>, como por ejemplo "una Mano es un ConjuntoDeCartas".
</p>
</li>
<li>
<p>Un tipo puede depender de otro si los objetos de un tipo toman objetos del segundo tipo como parámetros, o usan objetos del segundo tipo como parte de un cálculo. Este tipo de relación se llama <em>dependencia</em>.
</p>
</li>
</ul>
</div>
<div id="fig18-1" class="imageblock">
<div class="content">
<img src="images/fig181.svg" alt="fig181">
</div>
<div class="title">Figura 23. Type diagram</div>
</div>
<div class="paragraph">
<p>Cada una de las flechas superiores representa una relación ES-UN; en este caso, indica que Mano tiene como supertipo a ConjuntoDeCartas.</p>
</div>
<div class="paragraph">
<p>Cada una de las flechas inferiores representa una relación TIENE-UN; en este caso, un Mazo tiene referencias a objetos Naipe.</p>
</div>
<div class="paragraph">
<p>El asterisco (<code>*</code>) cerca de la flecha es una <em>multiplicidad</em>; indica cuántos Naipes tiene un Mazo. Una multiplicidad puede ser un número simple; como <code>52</code>, un rango; <code>como 5:7</code> o un asterisco; lo cual indica que un Mazo puede tener cualquier número de Naipes.
</p>
</div>
<div class="paragraph">
<p>No hay dependencias en este diagrama. Normalmente se mostrarían con una flecha achurada. Si hay muchas dependencias, a veces se omiten.</p>
</div>
<div class="paragraph">
<p>Un diagrama más detallado podría mostrar que un Mazo en realidad contiene un arreglo de Naipes, pero los tipos integrados como arreglos y diccionarios generalmente no se incluyen en los diagramas de tipos.</p>
</div>
</div>
<div class="sect2">
<h3 id="interactive">Depuración</h3>
<div class="paragraph">
<p>Utilizar subtipos puede dificultar la depuración ya que al llamar a una función con un objeto como argumento, puede ser complicado determinar qué método se invocará.</p>
</div>
<div class="paragraph">
<p>Supongamos que estamos escribiendo una función que funciona con objetos <code>Mano</code>. Nos gustaría que funcionara con todo tipo de <code>Mano+s, como +ManoDePoker</code>, <code>ManoDeBridge</code>, etc. Si invocas un método como <code>sort!</code>, podrías obtener el método definido para un tipo abstracto <code>Mano</code>, pero si existiera un método <code>sort!</code> que tuviera como argumento cualquiera de estos subtipos de <code>Mano</code>, obtendrás esa versión. Este comportamiento suele ser algo bueno, pero puede ser confuso.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function Base.sort!(mano::Mano)
    sort!(mano.naipes)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si no estás seguro del flujo de ejecución de un programa, la solución más simple es agregar sentencias de impresión al inicio de sus métodos más relevantes. Si <code>shuffle!</code> imprimiera un mensaje como <code>Ejecutando shuffle! en Mazo</code>, durante la ejecución del programa, sería posible rastrear el flujo de ejecución.</p>
</div>
<div class="paragraph">
<p>Una mejor alternativa es la macro <code>@which</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; @which sort!(mano)
sort!(mano::Mano) in Main at REPL[5]:1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Entonces, el método <code>sort!</code> de <code>mano</code> es el que tiene como argumento un objeto de tipo <code>Mano</code>.</p>
</div>
<div class="paragraph">
<p>Una sugerencia para el diseño del programa: cuando anula un método, la interfaz del nuevo método debería ser la misma que la anterior. Debería tomar los mismos parámetros, devolver el mismo tipo y obedecer las mismas condiciones previas y posteriores. Si sigues esta regla, cualquier función diseñada para funcionar con una instancia de un supertipo, como un <code>ConjuntoDeCartas</code>, también funcionará con instancias de sus subtipos <code>Mazo</code> y <code>Mano</code>.</p>
</div>
<div class="paragraph">
<p>Si viola esta regla, llamada "principio de sustitución de Liskov", su código colapsará como un castillo de naipes (jeje).
</p>
</div>
<div class="paragraph">
<p>La función <code>supertype</code> permite encontrar el supertipo directo de un tipo.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; supertype(Mazo)
ConjuntoDeCartas</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_encapsulado_de_datos">Encapsulado de Datos</h3>
<div class="paragraph">
<p>Los capítulos anteriores muestran un plan de desarrollo que podríamos llamar "diseño orientado a tipos". Identificamos los objetos que necesitamos, como <code>Punto</code>, <code>Rectangulo</code> y <code>Hora</code>, y definimos estructuras para representarlos. En cada caso hay una correspondencia obvia entre el objeto y alguna entidad en el mundo real (o al menos en el mundo matemático).
</p>
</div>
<div class="paragraph">
<p>A veces no es tan obvio los objetos que necesitamos y cómo estos deben interactuar. En ese caso, se necesita un plan de desarrollo diferente. De la misma manera que aprendimos sobre interfaces de funciones por encapsulado y generalización, podemos aprender sobre interfaces de tipo por encapsulado de datos.
</p>
</div>
<div class="paragraph">
<p>El análisis de Markov, de <a href="#markov_analysis">Análisis de Markov</a>, es un buen ejemplo. Si descarga el código desde <a href="https://github.com/BenLauwens/ThinkJulia.jl/blob/master/src/solutions/chap13.jl" class="bare">https://github.com/BenLauwens/ThinkJulia.jl/blob/master/src/solutions/chap13.jl</a>, verá que se usan dos variables globales: <code>sufijos</code> y <code>prefijo</code>, las cuales se leen y escriben desde varias funciones.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">sufijos = Dict()
prefijos = []</code></pre>
</div>
</div>
<div class="paragraph">
<p>Debido que estas variables son globales, solo podemos ejecutar un análisis a la vez. Si leemos dos textos, sus prefijos y sufijos se agregarían a las mismas estructuras de datos (lo que generaría un texto interesante).</p>
</div>
<div class="paragraph">
<p>Para ejecutar múltiples análisis y mantenerlos separados, podemos encapsular el estado de cada análisis en un objeto. Así es como se vería:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Markov
    orden :: Int64
    sufijos :: Dict{Tuple{String,Vararg{String}}, Array{String, 1}}
    prefijo :: Array{String, 1}
end

function Markov(orden::Int64=2)
    new(orden, Dict{Tuple{String,Vararg{String}}, Array{String, 1}}(), Array{String, 1}())
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>A continuación, transformamos las funciones en métodos. Por ejemplo, para <code>procesarpalabra</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function procesarpalabra(markov::Markov, palabra::String)
    if length(markov.prefijo) &lt; markov.orden
        push!(markov.prefijo, palabra)
        return
    end
    get!(markov.sufijos, (markov.prefijo...,), Array{String, 1}())
    push!(markov.sufijos[(markov.prefijo...,)], palabra)
    popfirst!(markov.prefijo)
    push!(markov.prefijo, palabra)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Transformar un programa así (cambiando el diseño sin cambiar el comportamiento) es otro ejemplo de refactorización (vea <a href="#refactorización">[refactorización]</a>).
</p>
</div>
<div class="paragraph">
<p>Este ejemplo sugiere el siguiente plan de desarrollo para diseñar tipos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Comience escribiendo funciones que lean y escriban variables globales (cuando sea necesario).</p>
</li>
<li>
<p>Una vez que el programa esté funcionando, busque asociaciones entre las variables globales y las funciones que las usan.</p>
</li>
<li>
<p>Encapsule variables relacionadas como atributos de una estructura.</p>
</li>
<li>
<p>Transforme las funciones asociadas en métodos que tengan como argumentos objetos del nuevo tipo.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_exercise_18_3">Exercise 18-3</h4>
<div class="paragraph">
<p>Descargue el código de Markov de <a href="https://github.com/BenLauwens/ThinkJulia.jl/blob/master/src/solutions/chap13.jl" class="bare">https://github.com/BenLauwens/ThinkJulia.jl/blob/master/src/solutions/chap13.jl</a>, y siga los pasos descritos anteriormente para encapsular las variables globales como atributos de una nueva estructura llamada <code>Markov</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_17">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">codificar</dt>
<dd>
<p>Representar un conjunto de valores uilizando otro conjunto de valores, generando una asociación entre ellos.
</p>
</dd>
<dt class="hdlist1">prueba unitaria</dt>
<dd>
<p>Manera estandarizada de probar que el código está correcto.
</p>
</dd>
<dt class="hdlist1">enchapado</dt>
<dd>
<p>Un método o función que mejora la interfaz de otra función sin hacer muchos cálculos.
</p>
</dd>
<dt class="hdlist1">crear subtipos</dt>
<dd>
<p>La capacidad de definir una jerarquía de tipos relacionados.
</p>
</dd>
<dt class="hdlist1">tipo abstracto</dt>
<dd>
<p>Un tipo que puede ser padre de otro tipo.
</p>
</dd>
<dt class="hdlist1">tipo concreto</dt>
<dd>
<p>Un tipo que se puede construir.
</p>
</dd>
<dt class="hdlist1">subtipo</dt>
<dd>
<p>Un tipo que tiene como padre un tipo abstracto.
</p>
</dd>
<dt class="hdlist1">supertipo</dt>
<dd>
<p>Un tipo abstracto que es el padre de otro tipo.
</p>
</dd>
<dt class="hdlist1">relación ES-UN</dt>
<dd>
<p>Una relación entre un subtipo y su supertipo.
</p>
</dd>
<dt class="hdlist1">relación TIENE-UN</dt>
<dd>
<p>Una relación entre dos tipos donde las instancias de un tipo contienen referencias a instancias del otro.
</p>
</dd>
<dt class="hdlist1">dependencia</dt>
<dd>
<p>Una relación entre dos tipos donde las instancias de un tipo usan instancias del otro tipo, pero no las almacenan como atributos.
</p>
</dd>
<dt class="hdlist1">diagrama de tipos</dt>
<dd>
<p>Un diagrama que muestra los tipos en un programa y las relaciones entre ellos.
</p>
</dd>
<dt class="hdlist1">multiplicidad</dt>
<dd>
<p>Una notación en un diagrama de tipo que muestra, para una relación TIENE-UN, cuántas referencias hay a instancias de otra clase.
</p>
</dd>
<dt class="hdlist1">encapsulado de datos</dt>
<dd>
<p>Un plan de desarrollo de programas que implica hacer un prototipo que use variables globales y una versión final que convierta las variables globales en atributos de instancia.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_exercises">Exercises</h3>
<div class="sect3">
<h4 id="ex18-1">Exercise 18-4</h4>
<div class="paragraph">
<p>Para el siguiente programa, dibuje un diagrama de tipos que muestre estos tipos y las relaciones entre ellos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">abstract type PadrePingPong end

struct Ping &lt;: PadrePingPong
    pong :: PadrePingPong
end

struct Pong &lt;: PadrePingPong
    pings :: Array{Ping, 1}
    function Pong(pings=Array{Ping, 1}())
        new(pings)
    end
end

function agregarping(pong::Pong, ping::Ping)
    push!(pong.pings, ping)
    nothing
end

pong = Pong()
ping = Ping(pong)
agregarping(pong, ping)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ex18-2">Ejercicio 18-5</h4>
<div class="paragraph">
<p>Escriba un método llamado <code>repartir!</code> que tome tres parámetros: un <code>Mazo</code>, el número de manos y el número de naipes por mano. Debería crear el número apropiado de objetos <code>Mano</code>, repartir el número apropiado de naipes por mano y devolver un arreglo de +Mano+s.
</p>
</div>
</div>
<div class="sect3">
<h4 id="ex18-3">Ejercicio 18-6</h4>
<div class="paragraph">
<p>Las siguientes son las posibles manos en el póker, en orden de valor creciente y probabilidad decreciente:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">pareja</dt>
<dd>
<p>dos cartas del mismo número</p>
</dd>
<dt class="hdlist1">doble pareja</dt>
<dd>
<p>dos pares de cartas del mismo número</p>
</dd>
<dt class="hdlist1">trío</dt>
<dd>
<p>tres cartas del mismo número</p>
</dd>
<dt class="hdlist1">escalera</dt>
<dd>
<p>Cinco cartas consecutivas (los ases pueden ser considerados altos o bajos, por lo tanto As-2-3-4-5 es escalera, 10-Jota-Reina-Rey-As también, pero Reina-Rey-As-2-3 no.)</p>
</dd>
<dt class="hdlist1">color</dt>
<dd>
<p>cinco cartas del mismo palo</p>
</dd>
<dt class="hdlist1">full</dt>
<dd>
<p>tres cartas iguales en su valor, más otras dos iguales en su valor</p>
</dd>
<dt class="hdlist1">póker</dt>
<dd>
<p>Cuatro cartas iguales en su valor</p>
</dd>
<dt class="hdlist1">escalera de color</dt>
<dd>
<p>Cinco cartas consecutivas del mismo palo</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>El objetivo de este ejercicio es estimar la probabilidad de tener estas diferentes manos.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Agregue métodos llamados <code>tienepareja</code>, <code>tienedoblepareja</code>, etc. que devuelvan <code>true</code> o <code>false</code> según si la mano cumple o no con los criterios relevantes. Su código debería funcionar correctamente para "manos" que contengan cualquier número de naipes (aunque 5 y 7 son los tamaños más comunes).
</p>
</li>
<li>
<p>Escriba un método llamado <code>clasificar</code> que descubra la clasificación de mayor valor para una mano, y defina el atributo <code>etiqueta</code> con esta clasificación. Por ejemplo, una mano de 7 cartas que contiene un color y una pareja, debe etiquetarse como "color".
</p>
</li>
<li>
<p>Cuando esté convencido de que sus métodos de clasificación están funcionando correctamente, estime las probabilidades de las distintas manos. Escriba una función que baraje un mazo de naipes, la divida en diferentes manos, clasifique las manos y cuente la cantidad de veces que aparecen varias clasificaciones.</p>
</li>
<li>
<p>Imprima una tabla de las clasificaciones y sus probabilidades. Ejecute su programa con un número cada vez mayor de manos hasta que los valores de salida converjan con un grado razonable de precisión. Compare sus resultados con los valores en <a href="https://en.wikipedia.org/wiki/Hand_rankings" class="bare">https://en.wikipedia.org/wiki/Hand_rankings</a>.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap19">19. Extra: Sintaxis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Uno de los objetivos de este libro es enseñarle lo justo y necesario de Julia. Se explica una sola forma de hacer las cosas, y en ocasiones se deja como ejercicio al lector una segunda manera.</p>
</div>
<div class="paragraph">
<p>Ahora veremos algunos temas que hemos dejado de lado, que sí son útiles. Julia proporciona una serie de características que no son realmente necesarias (se puede escribir un buen código sin ellas), pero a veces permiten escribir un código más conciso, legible y/o eficiente.</p>
</div>
<div class="paragraph">
<p>En este capítulo y el siguiente se discute aquello que se ha omitido en los capítulos anteriores:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>más sintaxis</p>
</li>
<li>
<p>funciones, tipos y macros disponibles directamente de <code>Base</code>
</p>
</li>
<li>
<p>funciones, tipos y macros de la Biblioteca Estándar (Standard Library)
</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_tuplas_con_nombre">Tuplas con nombre</h3>
<div class="paragraph">
<p>Es posible colocarle nombre a los componentes de una tupla, creando una tupla con nombre:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = (a=1, b=1+1)
(a = 1, b = 2)
julia&gt; x.a
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>En las tuplas con nombre, se puede acceder a los atributos con su nombre utilizando la sintaxis de punto <code>(x.a)</code>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_funciones">Funciones</h3>
<div class="paragraph">
<p>Las funciones en Julia también se pueden definir mediante una sintaxis compacta.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; f(x,y) = x + y
f (generic function with 1 method)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="anonymous_functions">Funciones Anonimas</h4>
<div class="paragraph">
<p>Podemos definir una función sin especificar su nombre:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x -&gt; x^2 + 2x - 1
#1 (generic function with 1 method)
julia&gt; function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Estos son ejemplos de <em>funciones anónimas</em>. Las funciones anónimas generalmente se usan como argumento de otra función:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; using Plots

julia&gt; plot(x -&gt; x^2 + 2x - 1, 0, 10, xlabel="x", ylabel="y")</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#fig19-1">Plot</a> muestra el resultado del comando plot (graficar en inglés).</p>
</div>
<div id="fig19-1" class="imageblock">
<div class="content">
<img src="images/fig191.svg" alt="fig191">
</div>
<div class="title">Figura 24. Plot</div>
</div>
</div>
<div class="sect3">
<h4 id="_argumentos_con_nombre">Argumentos con nombre</h4>
<div class="paragraph">
<p>También se puede poner nombre a los argumentos de una función:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; function migrafico(x, y; style="continua", width=1, color="negro")
           ###
       end
migrafico (generic function with 1 method)
julia&gt; migrafico(0:10, 0:10, style="dotted", color="blue")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los <em>argumentos con nombre</em> en una función se especifican después de un punto y coma en la especificación, pero al llamar a la función se pueden utilizar solo comas.
</p>
</div>
</div>
<div class="sect3">
<h4 id="_clausuras">Clausuras</h4>
<div class="paragraph">
<p>Una <em>clausura</em> es una técnica que permite que una función capture una variable definida fuera del ambito de la función.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; foo(x) = ()-&gt;x
foo (generic function with 1 method)

julia&gt; bar = foo(1)
#1 (generic function with 1 method)

julia&gt; bar()
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, la función <code>foo</code> devuelve una función anónima que tiene acceso al argumento <code>x</code> de la función <code>foo</code>. <code>bar</code> apunta a la función anónima y devuelve el valor del argumento de <code>foo</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bloques">Bloques</h3>
<div class="paragraph">
<p>Un <em>bloque</em> es una forma de agrupar varias sentencias. Un bloque comienza con la palabra reservada <code>begin</code> y termina con <code>end</code>.
</p>
</div>
<div class="paragraph">
<p>En <a href="#chap04">Estudio de Caso: Diseño de Interfaz</a> se presentó la macro <code>@svg</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, la macro <code>@svg</code> tiene un único argumento: un bloque, que agrupa 3 llamadas a funciones.</p>
</div>
<div class="sect3">
<h4 id="_bloques_let">Bloques <code>let</code></h4>
<div class="paragraph">
<p>Un bloque <code>let</code> es útil para crear nuevas ligaduras (o bindings), es decir, variables locales que pueden apuntar a valores.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x, y, z = -1, -1, -1;

julia&gt; let x = 1, z
           @show x y z;
       end
x = 1
y = -1
ERROR: UndefVarError: z not defined
julia&gt; @show x y z;
x = -1
y = -1
z = -1</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el ejemplo, la primera macro <code>@show</code> muestra la variable local <code>x</code>, la variable global <code>y</code> y la variable local indefinida <code>z</code>. Las variables globales se mantienen intactas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_bloques_do">Bloques <code>do</code></h4>
<div class="paragraph">
<p>En <a href="#reading_and_writing">Lectura y Escritura</a> cerramos el archivo después de terminar de escribir en él. Esto se puede hacer automáticamente usando un <em>Bloque do</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; datos = "El Cid convoca a sus vasallos;\néstos se destierran con él.\n"
"El Cid convoca a sus vasallos;\néstos se destierran con él.\n"
julia&gt; open("salida.txt", "w") do fout
           write(fout, datos)
       end
61</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, <code>fout</code> es el archivo stream utilizado para la salida.</p>
</div>
<div class="paragraph">
<p>Esto es equivalente a:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; f = fout -&gt; begin
           write(fout, datos)
       end
#3 (generic function with 1 method)
julia&gt; open(f, "salida.txt", "w")
61</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función anónima se utiliza como primer argumento de la función <code>open</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un bloque <code>do</code> puede "capturar" variables de su ámbito envolvente (enclosed scope). Por ejemplo, la variable <code>datos</code> en el ejemplo anterior de <code>open ... do</code> es capturada desde el ámbito externo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructuras_de_control">Estructuras de control</h3>
<div class="sect3">
<h4 id="_operador_ternario">Operador ternario</h4>
<div class="paragraph">
<p>El <em>operador ternario</em>, <code>?:</code>, puede utilizarse en vez de una sentencia <code>if-elseif</code>. Esta sentencia se usa cuando se necesita elegir entre diferentes expresiones con valor único.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = 150
150
julia&gt; a % 2 == 0 ? println("par") : println("impar")
par</code></pre>
</div>
</div>
<div class="paragraph">
<p>La expresión que va antes de <code>?</code> es una expresión de condición. Si la condición es <code>true</code>, se evalúa la expresión que va antes de <code>:</code>; de lo contrario, se evalúa la expresión que va después de <code>:</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_evaluación_de_cortocircuito">Evaluación de cortocircuito</h4>
<div class="paragraph">
<p>Los operadores <code>&amp;&amp;</code> y <code>||</code> realizan una <em>evaluación de cortocircuito</em>, es decir, se evalúa el siguiente argumento solo cuando es necesario para determinar el valor final.
</p>
</div>
<div class="paragraph">
<p>Por ejemplo, una función factorial recursiva podría definirse así:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fact(n::Integer)
    n &gt;= 0 || error("n debe ser no negativo")
    n == 0 &amp;&amp; return 1
    n * fact(n-1)
end</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tarea_o_corrutina">Tarea (o Corrutina)</h4>
<div class="paragraph">
<p>Una <em>tarea</em> es una estructura de control que puede ceder el control de forma cooperativa sin hacer return. En Julia, una tarea puede implementarse como una función con un objeto <code>Channel</code> como primer argumento. Se usa un channel para pasar valores de la función a la sentencia que la llama.</p>
</div>
<div class="paragraph">
<p>El término "cooperativo" alude a que los programas deben cooperar para que todo el esquema de programación funcione.</p>
</div>
<div class="paragraph">
<p>La secuencia de Fibonnaci se puede generar mediante una tarea.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function fib(c::Channel)
    a = 0
    b = 1
    put!(c, a)
    while true
        put!(c, b)
        (a, b) = (b, a+b)
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>put!</code> almacena valores en un objeto channel y <code>take!</code> lee valores desde él:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fib_gen = Channel(fib);

julia&gt; take!(fib_gen)
0
julia&gt; take!(fib_gen)
1
julia&gt; take!(fib_gen)
1
julia&gt; take!(fib_gen)
2
julia&gt; take!(fib_gen)
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>El constructor <code>Channel</code> crea la tarea. La función <code>fib</code> se suspende después de cada llamada a <code>put!</code> y se reanuda al llamar a <code>take!</code>. Por razones de rendimiento, se almacenan varios valores de la secuencia en el objeto channel durante un ciclo de reanudación/suspensión.</p>
</div>
<div class="paragraph">
<p>Un objeto channel también se puede usar como iterador:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; for val in Channel(fib)
           print(val, " ")
           val &gt; 20 &amp;&amp; break
       end
0 1 1 2 3 5 8 13 21</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tipos">Tipos</h3>
<div class="sect3">
<h4 id="_tipos_primitivos">Tipos Primitivos</h4>
<div class="paragraph">
<p>Un tipo concreto compuesto por bits se llama <em>tipo primitivo</em>. A diferencia de la mayoría de los lenguajes, en Julia podemos declarar nuestros propios tipos primitivos. Los tipos primitivos estándar se definen de la misma manera:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">primitive type Float64 &lt;: AbstractFloat 64 end
primitive type Bool &lt;: Integer 8 end
primitive type Char &lt;: AbstractChar 32 end
primitive type Int64 &lt;: Signed 64 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El número en las sentencias especifica cuántos bits se requieren.</p>
</div>
<div class="paragraph">
<p>El siguiente ejemplo crea un tipo primitivo <code>Byte</code> y un constructor:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; primitive type Byte 8 end

julia&gt; Byte(val::UInt8) = reinterpret(Byte, val)
Byte
julia&gt; b = Byte(0x01)
Byte(0x01)</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>reinterpret</code> se usa para almacenar los bits de un entero sin signo con 8 bits (<code>UInt8</code>) en el byte.
</p>
</div>
</div>
<div class="sect3">
<h4 id="_tipos_paramétricos">Tipos Paramétricos</h4>
<div class="paragraph">
<p>El sistema de tipos de Julia es <em>paramétrico</em>, lo que significa que los tipos pueden tener parámetros.</p>
</div>
<div class="paragraph">
<p>Los parámetros de un tipo se colocan después del nombre del tipo, entre llaves:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Punto{T&lt;:Real}
    x::T
    y::T
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Con esto se define un nuevo tipo paramétrico, <code>Punto{T&lt;:Real}</code>, que contiene dos "coordenadas" de tipo <code>T</code>, que puede ser cualquier tipo que tenga <code>Real</code> como supertipo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Punto(0.0, 0.0)
Punto{Float64}(0.0, 0.0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Además de los tipos compuestos, los tipos abstractos y los tipos primitivos también pueden tener parámetros.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Para mejorar el rendimiento, es totalmente recomendable tener tipos concretos como atributos de una estructura, por lo que esta es una buena manera de hacer que <code>Punto</code> sea rápido y flexible.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_union_de_tipo">Union de Tipo</h4>
<div class="paragraph">
<p>Una <em>union de tipo</em> es un tipo paramétrico abstracto que puede actuar como cualquiera de los tipos de sus argumentos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; EnteroOCadena = Union{Int64, String}
Union{Int64, String}
julia&gt; 150 :: EnteroOCadena
150
julia&gt; "Julia" :: EnteroOCadena
"Julia"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una unión de tipos es, en la mayoría de los lenguajes informáticos, una construcción interna para trabajar con tipos. Sin embargo, Julia pone a disposición esta característica para sus usuarios, ya que permite generar un código eficiente (cuando la unión es entre pocos tipos). Esta característica otorga una gran flexibilidad para controlar el dispatch.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_métodos_2">Métodos</h3>
<div class="sect3">
<h4 id="_métodos_paramétricos">Métodos Paramétricos</h4>
<div class="paragraph">
<p>Las definiciones de métodos también pueden tener parámetros de tipo que limiten su especificación:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; espuntoentero(p::Punto{T}) where {T} = (T === Int64)
espuntoentero (generic function with 1 method)
julia&gt; p = Punto(1, 2)
Punto{Int64}(1, 2)
julia&gt; espuntoentero(p)
true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_objetos_similares_a_funciones">Objetos Similares a Funciones</h4>
<div class="paragraph">
<p>Cualquier objeto arbitrario de Julia puede hacerse "invocable". Tales objetos "invocables" a veces se denominan <em>funtores</em>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Polinomio{R}
    coef::Vector{R}
end

function (p::Polinomio)(x)
    val = p.coef[end]
    for coef in p.coef[end-1:-1:1]
        val = val * x + coef
    end
    val
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para evaluar el polinomio, simplemente debemos llamarlo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; p = Polinomio([1,10,100])
Polinomio{Int64}([1, 10, 100])
julia&gt; p(3)
931</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_constructores">Constructores</h3>
<div class="paragraph">
<p>Los tipos paramétricos se pueden construir explícita o implícitamente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Punto(1,2)         # T implicito
Punto{Int64}(1, 2)
julia&gt; Punto{Int64}(1, 2) # T explicito
Punto{Int64}(1, 2)
julia&gt; Punto(1,2.5)       # T implicito
ERROR: MethodError: no method matching Punto(::Int64, ::Float64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se generan constructores internos y externos por defecto para cada <code>T</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Punto{T&lt;:Real}
    x::T
    y::T
    Punto{T}(x,y) where {T&lt;:Real} = new(x,y)
end

Punto(x::T, y::T) where {T&lt;:Real} = Punto{T}(x,y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>y tanto <code>x</code> como <code>y</code> deben ser del mismo tipo.</p>
</div>
<div class="paragraph">
<p>Cuando <code>x</code> e <code>y</code> son de tipos diferentes, se puede definir el siguiente constructor externo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">Punto(x::Real, y::Real) = Punto(promote(x,y)...);</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>promote</code> se detalla en <a href="#promoción">[promoción]</a>.
</p>
</div>
</div>
<div class="sect2">
<h3 id="_conversión_y_promoción">Conversión y Promoción</h3>
<div class="paragraph">
<p>Julia tiene un sistema para convertir argumentos de diferentes tipos a un tipo común. Esto es llamado promoción, y aunque no es automático, se puede realizar fácilmente.</p>
</div>
<div class="sect3">
<h4 id="_conversion">Conversion</h4>
<div class="paragraph">
<p>Un valor se puede convertir de un tipo a otro:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = 12
12
julia&gt; typeof(x)
Int64
julia&gt; convert(UInt8, x)
0x0c
julia&gt; typeof(ans)
UInt8</code></pre>
</div>
</div>
<div class="paragraph">
<p>Podemos agregar nuestros propios métodos <code>convert</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; Base.convert(::Type{Punto{T}}, x::Array{T, 1}) where {T&lt;:Real} = Punto(x...)

julia&gt; convert(Punto{Int64}, [1, 2])
Punto{Int64}(1, 2)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="promotion">Promoción</h4>
<div class="paragraph">
<p><em>Promoción</em> es la conversión de valores de diferentes tipos a un solo tipo común:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; promote(1, 2.5, 3)
(1.0, 2.5, 3.0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Generalmente, los métodos para la función <code>promote</code> no se definen directamente, sino que se usa la función auxiliar <code>promot_rule</code> para especificar las reglas de la promoción:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">promote_rule(::Type{Float64}, ::Type{Int32}) = Float64</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_metaprogramación">Metaprogramación</h3>
<div class="paragraph">
<p>Un código de Julia se puede representar como una estructura de datos del mismo lenguaje. Esto permite que un programa escriba y manipule su propio código.</p>
</div>
<div class="sect3">
<h4 id="_expresiones">Expresiones</h4>
<div class="paragraph">
<p>Cada programa de Julia comienza como una cadena:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; prog = "1 + 2"
"1 + 2"</code></pre>
</div>
</div>
<div class="paragraph">
<p>El siguiente paso es analizar cada cadena en un objeto llamado <em>expresión</em>, representado por el tipo de Julia <code>Expr</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ex = Meta.parse(prog)
:(1 + 2)
julia&gt; typeof(ex)
Expr
julia&gt; dump(ex)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>dump</code> muestra objetos expr con anotaciones.
</p>
</div>
<div class="paragraph">
<p>Las expresiones se pueden construir directamente con el prefijo <code>:</code> entre paréntesis o usando un bloque quote:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ex = quote
           1 + 2
       end;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_eval"><code>eval</code></h4>
<div class="paragraph">
<p>Julia puede evaluar un objeto de expresión usando la función <code>eval</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; eval(ex)
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cada módulo tiene su propia función <code>eval</code> que evalúa las expresiones de su ámbito.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p>Generalmente si un código tiene muchas llamadas a <code>eval</code>, significa que algo está mal. <code>eval</code> se considera "malo".</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_macros">Macros</h4>
<div class="paragraph">
<p>Las macros pueden incluir código generado en un programa. Una <em>macro</em> asocia una tupla de objetos <code>Expr</code> directamente con una expresión compilada:
</p>
</div>
<div class="paragraph">
<p>Aquí hay una macro simple:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">macro contenedorvariable(contenedor, elemento)
    return esc(:($(Symbol(contenedor,elemento)) = $contenedor[$elemento]))
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las macros se llaman anteponiendo <code>@</code> (arroba) a su nombre. La llamada a la macro <code>@contenedorvariable letras 1</code> se reemplaza por:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">:(letras1 = letras[1])</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@macroexpand @contenedorvariable letras 1</code>  returns this expression which is extremely useful for debugging.
</p>
</div>
<div class="paragraph">
<p>Este ejemplo ilustra cómo una macro puede acceder al nombre de sus argumentos, algo que una función no puede hacer. Se debe "escapar" de la expresión de retorno con <code>esc</code> porque debe resolverse en el entorno de la macro llamada.
</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Nota</div>
</td>
<td class="content">
<div class="paragraph">
<p>¿Por qué usar Macros?</p>
</div>
<div class="paragraph">
<p>Las macros generan e incluyen fragmentos de código personalizado durante el tiempo de análisis, es decir, <em>antes</em> de ejecutar el programa completo.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_funciones_generadas">Funciones Generadas</h4>
<div class="paragraph">
<p>La macro <code>@generated</code> crea código especializado para métodos dependiendo del tipo de los argumentos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">@generated function cuadrado(x)
    println(x)
    :(x * x)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El cuerpo devuelve una expresión citada como una macro.</p>
</div>
<div class="paragraph">
<p>Para la sentencia que llama, la <em>función generada</em> se comporta como una función normal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = cuadrado(2); # nota: la salida es de la instrucción println () que está en el cuerpo
Int64
julia&gt; x              # ahora imprimimos x
4
julia&gt; y = cuadrado("spam");
String
julia&gt; y
"spamspam"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_datos_faltantes">Datos Faltantes</h3>
<div class="paragraph">
<p>Los <em>datos faltantes</em> se pueden representar a través del objeto <code>missing</code>, que es la instancia única del tipo <code>Missing</code>.
</p>
</div>
<div class="paragraph">
<p>Los arreglos pueden contener datos faltantes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = [1, missing]
2-element Array{Union{Missing, Int64},1}:
 1
  missing</code></pre>
</div>
</div>
<div class="paragraph">
<p>El tipo de dicho arreglo es <code>Union{Missing, T}</code>, donde <code>T</code> es el tipo de los valores que realmente tenemos en el arreglo.</p>
</div>
<div class="paragraph">
<p>Las funciones de reducción devuelven <code>missing</code> cuando se invocan con arreglos que contienen valores faltantes</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; sum(a)
missing</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este caso, se puede usar la función <code>skipmissing</code> para omitir los valores faltantes:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; sum(skipmissing([1, missing]))
1</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_llamar_a_código_de_c_y_fortran">Llamar a Código de C y Fortran</h3>
<div class="paragraph">
<p>Se escribe mucho código en C o Fortran. Reutilizar un código que ya ha sido probado generalmente es mejor que escribir su propia versión en otro lenguaje. Julia puede llamar directamente a las bibliotecas C o Fortran existentes utilizando la sintaxis <code>ccall</code>.
</p>
</div>
<div class="paragraph">
<p>En <a href="#databases">Bases de datos</a> se presentó una interfaz de Julia de la biblioteca GDBM de funciones de base de datos. La biblioteca está escrita en C. Para cerrar la base de datos, se debe hacer una llamada a la función <code>close(db)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">Base.close(dbm::DBM) = gdbm_close(dbm.handle)

function gdbm_close(handle::Ptr{Cvoid})
    ccall((:gdbm_close, "libgdbm"), Cvoid, (Ptr{Cvoid},), handle)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un objeto dbm tiene un atributo <code>handle</code> de tipo <code>Ptr{Cvoid}</code>. Este atributo contiene un puntero de C que apunta a la base de datos. Para cerrar la base de datos, debe llamarse a la función de C <code>gdbm_close</code> teniendo como único argumento el puntero C apuntando a la base de datos, sin valor de retorno. Julia hace esto directamente con la función <code>ccall</code> que tiene como argumentos:
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>una tupla que consiste en un símbolo que contiene el nombre de la función que queremos llamar: <code>:gdbm_close</code> y la librería compartida especificada como una cadena: <code>+"libgdm"</code>,</p>
</li>
<li>
<p>el tipo de retorno: <code>Cvoid</code>,</p>
</li>
<li>
<p>una tupla de tipos de argumentos: <code>(Ptr{Cvoid},)</code> y</p>
</li>
<li>
<p>los valores del argumento: <code>handle</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Una visión completa de la librería GDBM se puede encontrar como ejemplo en las fuentes de ThinkJulia.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossary_2">Glossary</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">clausura</dt>
<dd>
<p>Función que captura variables del ámbito en dónde está definida.
</p>
</dd>
<dt class="hdlist1">bloque let</dt>
<dd>
<p>Bloque de asignación de nuevas ligaduras variables.
</p>
</dd>
<dt class="hdlist1">función anónima</dt>
<dd>
<p>Función definida sin nombre.
</p>
</dd>
<dt class="hdlist1">tupla con nombre</dt>
<dd>
<p>Tupla con componentes con nombre.
</p>
</dd>
<dt class="hdlist1">argumentos con nombre</dt>
<dd>
<p>Argumentos identificados por su nombre en vez de solo por la posición que ocupan.
</p>
</dd>
<dt class="hdlist1">bloque do</dt>
<dd>
<p>Construcción usada para definir y llamar a una función anónima parecida a un bloque de código normal.
</p>
</dd>
<dt class="hdlist1">operador ternario</dt>
<dd>
<p>Operador de estructura de control que toma tres operandos: una condición, una expresión que se ejecutará si la condición devuelve <code>true</code> y una expresión que se ejecutará si la condición devuelve <code>false</code>.
</p>
</dd>
<dt class="hdlist1">evaluación de cortocircuito</dt>
<dd>
<p>Evaluación de un operador booleano para el que se ejecuta o evalúa el segundo argumento solo si el primero no es suficiente para determinar el valor de la expresión.
</p>
</dd>
<dt class="hdlist1">tareas (corrutina)</dt>
<dd>
<p>Característica de las estructuras de control que permite suspender y reanudar cálculos de manera flexible.
</p>
</dd>
<dt class="hdlist1">tipo primitivo</dt>
<dd>
<p>Tipo concreto cuyos datos están compuestos de bits.
</p>
</dd>
<dt class="hdlist1">unión de tipos</dt>
<dd>
<p>Tipo que incluye todas las instancias de cualquiera de sus tipos de parámetros como objetos.
</p>
</dd>
<dt class="hdlist1">tipo paramétrico</dt>
<dd>
<p>Tipo que tiene parámetros.
</p>
</dd>
<dt class="hdlist1">funtor</dt>
<dd>
<p>Objeto con un método asociado, para que sea invocable.
</p>
</dd>
<dt class="hdlist1">conversión</dt>
<dd>
<p>Permite convertir un valor de un tipo a otro.
</p>
</dd>
<dt class="hdlist1">promoción</dt>
<dd>
<p>Conversión de valores de diferentes tipos a un soloa tipo común.
</p>
</dd>
<dt class="hdlist1">expresión</dt>
<dd>
<p>Tipo de Julia que contiene una construcción de lenguaje.
Julia type that holds a language construct.
</p>
</dd>
<dt class="hdlist1">macro</dt>
<dd>
<p>Forma de incluir el código generado en el cuerpo final de un programa.
</p>
</dd>
<dt class="hdlist1">funciones generadas</dt>
<dd>
<p>Funciones capaces de generar código especializado según el tipo de los argumentos.
</p>
</dd>
<dt class="hdlist1">datos faltantes</dt>
<dd>
<p>Instancias que representan datos sin valor.
</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap20">20. Extra: Base y Librería Estándar</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Julia tiene todo lo necesario. El módulo <code>Base</code> contiene las funciones, tipos y macros más útiles. Los cuales están disponibles directamente en Julia.
</p>
</div>
<div class="paragraph">
<p>Julia también posee una gran cantidad de módulos especializados en su Biblioteca Estándar (módulos para Fechas, Computación Distribuida, Álgebra Lineal, Perfiles, Números Aleatorios, entre otros). Las funciones, los tipos y las macros definidos en la Biblioteca estándar deben importarse antes de poder usarse:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>import <em>Module</em></code> importa el modulo, y <code><em>Module.fn</em>(x)</code> llama a la función <code><em>fn</em></code>
</p>
</li>
<li>
<p><code>using <em>Module</em></code> importa todas las funciones, tipos y macros exportadas de <code><em>Module</em></code>.
</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Además, es posible agregar más funciones a una gran cantidad de paquetes (<a href="https://juliaobserver.com" class="bare">https://juliaobserver.com</a>).</p>
</div>
<div class="paragraph">
<p>Este capítulo no es un reemplazo de la documentación oficial de Julia. Solo se dan algunos ejemplos para ilustrar lo que es posible hacer, sin ser exhaustivo. Las funciones ya vistas no están incluidas. Se puede encontrar una explicación más completa en <a href="https://docs.julialang.org" class="bare">https://docs.julialang.org</a>.</p>
</div>
<div class="sect2">
<h3 id="_midiendo_el_rendimiento">Midiendo el Rendimiento</h3>
<div class="paragraph">
<p>Hemos visto que algunos algoritmos funcionan mejor que otros. <code>fibonnaci</code> en <a href="#memos">Pistas</a> es mucho más rápido que <code>fib</code> en <a href="#one_more_example">Un Ejemplo Más</a>. La macro <code>@time</code> permite cuantificar la diferencia:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; fib(1)
1
julia&gt; fibonacci(1)
1
julia&gt; @time fib(40)
  0.567546 seconds (5 allocations: 176 bytes)
102334155
julia&gt; @time fibonacci(40)
  0.000012 seconds (8 allocations: 1.547 KiB)
102334155</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@time</code> imprime el tiempo que tardó en ejecutarse la función, el número de asignaciones (allocations) y la memoria asignada antes de devolver el resultado. La función fibonacci (que guarda resultados previos) es mucho más rápida pero necesita más memoria.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>El teorema "No free lunch" dice que no existe un único modelo que funcione mejor en todos los casos.</p>
</div>
</blockquote>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Observación</div>
</td>
<td class="content">
<div class="paragraph">
<p>Para comparar dos algoritmos, estos deben implementarse como funciones. Una función en Julia se compila la primera vez que se ejecuta, por lo tanto, se debe excluir la primera vez que se llama a estas funciones al medir el rendimiento; de lo contrario, también se mediría el tiempo de compilación.</p>
</div>
<div class="paragraph">
<p>El paquete <code>BenchmarkTools</code> (<a href="https://github.com/JuliaCI/BenchmarkTools.jl" class="bare">https://github.com/JuliaCI/BenchmarkTools.jl</a>) proporciona la macro <code>@btime</code> que realiza una evaluación comparativa de la manera correcta. ¡Así que úsela!</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="collections_and_data_structures">Colecciones y Estructuras de Datos</h3>
<div class="paragraph">
<p>En <a href="#dictionary_subtraction">Resta de Diccionario</a> usamos diccionarios para encontrar las palabras que aparecían en un documento y que no aparecían en un arreglo de palabras. La función que escribimos tomaba <code>d1</code>, que contenía las palabras del documento como claves, y <code>d2</code>, que contenía el arreglo de palabras. Y devolvía un diccionario que contenía las claves de <code>d1</code> que no estaban en <code>d2</code>.
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function resta(d1, d2)
    res = Dict()
    for clave in keys(d1)
        if clave ∉ keys(d2)
            res[clave] = nothing
        end
    end
    res
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>En todos estos diccionarios, los valores son <code>nothing</code> porque nunca los usamos. Con esto estamos desperdiciando espacio de almacenamiento.</p>
</div>
<div class="paragraph">
<p>Julia ofrece otro tipo integrado llamado conjunto, que se comporta como una colección de claves de diccionario sin valores. Agregar elementos a un conjunto es rápido; también lo es verificar si un elemento forma parte de él. Además, los conjuntos proporcionan funciones y operadores para calcular operaciones de conjuntos.
</p>
</div>
<div class="paragraph">
<p>Por ejemplo, la resta de conjuntos está disponible como una función llamada <code>setdiff</code>. Entonces reescribiendo <code>resta</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function resta(d1, d2)
    setdiff(d1, d2)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado es un conjunto en vez de un diccionario.</p>
</div>
<div class="paragraph">
<p>Algunos de los ejercicios en este libro se pueden hacer de manera eficiente y concisa con conjuntos. Por ejemplo, a continuación se muestra una solución para <code>repetido</code>, de <a href="#ex10-7">Ejercicio 10-7</a>, que usa un diccionario:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function repetido(t)
    d = Dict()
    for x in t
        if x ∈ d
            return true
        end
        d[x] = nothing
    end
    false
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando un elemento aparece por primera vez, se agrega al diccionario. Si el mismo elemento aparece nuevamente, la función devuelve <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Usando conjuntos, podemos escribir la misma función:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function repetido(t)
    length(Set(t)) &lt; length(t)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un elemento solo puede aparecer en un conjunto una vez, por lo que si un elemento en <code>t</code> aparece más de una vez, el conjunto será más pequeño que <code>t</code>. Si no hay elementos repetidos, el conjunto tendrá el mismo tamaño que <code>t</code>.</p>
</div>
<div class="paragraph">
<p>También podemos usar conjuntos para hacer algunos de los ejercicios de <a href="#chap09">Estudio de Caso: Juego de Palabras</a>. Por ejemplo, aquí hay una versión de <code>usasolo</code> con un bucle:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function usasolo(palabra, disponibles)
    for letra in palabra
        if letra ∉ disponibles
            return false
        end
    end
    true
end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>usasolo</code> comprueba si todas las letras en <code>palabra</code> están en <code>disponibles</code>. Podemos reescribir esta función:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function usasolo(palabra, disponibles)
    Set(palabra) ⊆ Set(disponibles)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador <code>⊆</code> (<strong><code>\subseteq TAB</code></strong>) verifica si un conjunto es un subconjunto de otro, incluida la posibilidad de que sean iguales, lo cual es cierto si todas las letras en <code>palabra</code> aparecen en <code>disponibles</code>.
</p>
</div>
<div class="sect3">
<h4 id="_exercise_20_1">Exercise 20-1</h4>
<div class="paragraph">
<p>Reescriba la función <code>evita</code> de <a href="#chap09">Estudio de Caso: Juego de Palabras</a> usando conjuntos.
</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_matemáticas">Matemáticas</h3>
<div class="paragraph">
<p>También se pueden usar números complejos en Julia. La constante global <code>im</code> está asociada al número complejo \(\mathrm{i}\), que representa la raíz cuadrada principal de \(-1\).
</p>
</div>
<div class="paragraph">
<p>Ahora podemos verificar la identidad de Euler,
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ℯ^(im*π)+1
0.0 + 1.2246467991473532e-16im</code></pre>
</div>
</div>
<div class="paragraph">
<p>El símbolo <code>ℯ</code> (<strong><code>\euler TAB</code></strong>) es la base de los logaritmos naturales.
</p>
</div>
<div class="paragraph">
<p>Analicemos la naturaleza compleja de las funciones trigonométricas:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{equation}
{\cos\left(x\right)=\frac{\mathrm{e}^{\mathrm{i}x}+\mathrm{e}^{-\mathrm{i}x}}{2}\,.}
\end{equation}\]
</div>
</div>
<div class="paragraph">
<p>Podemos probar esta fórmula para diferentes valores de \(x\).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; x = 0:0.1:2π
0.0:0.1:6.2
julia&gt; cos.(x) == 0.5*(ℯ.^(im*x)+ℯ.^(-im*x))
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aquí se muestra otro ejemplo del operador punto. Julia también permite usar valores numéricos con identificadores (símbolos léxicos que nombran entidades, como <code>π</code>) como en <code>2π</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cadenas">Cadenas</h3>
<div class="paragraph">
<p>En <a href="#chap08">Cadenas</a> y <a href="#chap09">Estudio de Caso: Juego de Palabras</a>, realizamos algunas búsquedas en cadenas. Además, Julia puede usar <em>expresiones regulares</em> (o <em>regexes</em>) compatibles con Perl, lo que facilita la tarea de encontrar patrones complejos en cadenas.
</p>
</div>
<div class="paragraph">
<p>La función <code>usasolo</code> se puede implementar como una expresión regular:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function usasolo(palabra, disponibles)
  r = Regex("[^$(disponibles)]")
  !occursin(r, palabra)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>La expresión regular busca un carácter que no está en la cadena <code>disponible</code> y <code>occursin</code> devuelve <code>true</code> si el patrón se encuentra en <code>palabra</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; usasolo("banana", "abn")
true
julia&gt; usasolo("bananas", "abn")
false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las expresiones regulares también se pueden construir como literales de cadena no estándar con el prefijo <code>r</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; match(r"[^abn]", "banana")

julia&gt; m = match(r"[^abn]", "bananas")
RegexMatch("s")</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este caso, la interpolación de cadenas no está permitida. La función <code>match</code> devuelve nothing si no se encuentra el patrón, de lo contrario, devuelve un objeto regexmatch.
</p>
</div>
<div class="paragraph">
<p>Podemos extraer la siguiente información de un objeto regexmatch:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>la subcadena que coincide: <code>m.match</code></p>
</li>
<li>
<p>las subcadenas que coinciden en forma de arreglo de cadenas: <code>m.captures</code></p>
</li>
<li>
<p>la primera posición en la que se encuentra el patrón: <code>m.offset</code></p>
</li>
<li>
<p>las posiciones de las subcadenas que coinciden en forma de arreglo: <code>m.offsets</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; m.match
"s"
julia&gt; m.offset
7</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las expresiones regulares son extremadamente poderosas y el manual de PERL <a href="http://perldoc.perl.org/perlre.html" class="bare">http://perldoc.perl.org/perlre.html</a> explica cómo realizar hasta las búsquedas más extrañas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arreglos">Arreglos</h3>
<div class="paragraph">
<p>En el <a href="#chap10">Arreglos</a> usamos un objeto de arreglo unidimensional, con un índice para acceder a sus elementos. Sin embargo, en Julia las matrices son multidimensionales.</p>
</div>
<div class="paragraph">
<p>Creemos una <em>matriz</em> de ceros de 2 por 3:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; z = zeros(Float64, 2, 3)
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
julia&gt; typeof(z)
Array{Float64,2}</code></pre>
</div>
</div>
<div class="paragraph">
<p>El tipo de esta matriz es un arreglo que contiene números de punto flotante. Esta matriz es de 2 dimensiones.
</p>
</div>
<div class="paragraph">
<p>La función <code>size</code> devuelve una tupla con el número de elementos en cada dimensión:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; size(z)
(2, 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función <code>ones</code> construye una matriz con elementos de valor unitario:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; s = ones(String, 1, 3)
1×3 Array{String,2}:
 ""  ""  ""</code></pre>
</div>
</div>
<div class="paragraph">
<p>El elemento de valor unitario de una cadena es una cadena vacía.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Aviso</div>
</td>
<td class="content">
<div class="paragraph">
<p><code>s</code> no es un arreglo unidimensional:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; s ==  ["", "", ""]
false</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>s</code> es un vector fila y <code>["", "", ""]</code> es un vector columna.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Se puede crear una matriz usando espacios para separar elementos en una fila, y punto y coma <code>;</code> para separar filas:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se pueden usar corchetes para modificar elementos de una matriz:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; z[1,2] = 1
1
julia&gt; z[2,3] = 1
1
julia&gt; z
2×3 Array{Float64,2}:
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se pueden usar porciones en cada dimensión para seleccionar un subgrupo de elementos:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; u = z[:,2:end]
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador <code>.</code> aplica una operación en todas las dimensiones:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; ℯ.^(im*u)
2×2 Array{Complex{Float64},2}:
 0.540302+0.841471im       1.0+0.0im
      1.0+0.0im       0.540302+0.841471im</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interfaces">Interfaces</h3>
<div class="paragraph">
<p>Julia especifica algunas interfaces informales para definir comportamientos, es decir, métodos con un objetivo específico. Cuando se  extienden estos métodos para un tipo, los objetos de ese tipo se pueden usar para construir estos comportamientos.
</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Si parece un pato, nada como un pato y grazna como un pato, entonces probablemente <em>sea</em> un pato.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>En <a href="#one_more_example">Un Ejemplo Más</a> implementamos la función <code>fib</code> que devuelve el elemento \(n\)-ésimo de la secuencia de Fibonnaci.</p>
</div>
<div class="paragraph">
<p>Recorrer los valores de una colección, lo cual es llamado iteración, es una interfaz de este tipo. Creemos un iterador que devuelva la secuencia de Fibonacci:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">struct Fibonacci{T&lt;:Real} end
Fibonacci(d::DataType) = d&lt;:Real ? Fibonacci{d}() : error("No Real type!")

Base.iterate(::Fibonacci{T}) where {T&lt;:Real} = (zero(T), (one(T), one(T)))
Base.iterate(::Fibonacci{T}, state::Tuple{T, T}) where {T&lt;:Real} = (state[1], (state[2], state[1] + state[2]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Implementamos un tipo paramétrico <code>Fibonacci</code> sin atributos, un constructor externo y dos métodos <code>iterate</code>. Se llama al primer método <code>iterate</code> para inicializar el iterador, y este devuelve una tupla que consta de un primer valor: 0, y un estado. El estado en este caso es una tupla que contiene el segundo y el tercer valor: 1 y 1.</p>
</div>
<div class="paragraph">
<p>Se llama al segundo método <code>iterate</code> para obtener el siguiente valor de la secuencia de Fibonacci, y devuelve una tupla que tiene como primer elemento el siguiente valor y como segundo elemento el estado que es una tupla con los dos valores siguientes.</p>
</div>
<div class="paragraph">
<p>Ahora podemos usar <code>Fibonacci</code> en un bucle <code>for</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; for e in Fibonacci(Int64)
           e &gt; 100 &amp;&amp; break
           print(e, " ")
       end
0 1 1 2 3 5 8 13 21 34 55 89</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parece sacado debajo de la manga, pero la explicación es simple. Un bucle <code>for</code> en Julia</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">for i in iter
    # body
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>se traduce en:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">next = iterate(iter)
while next !== nothing
    (i, state) = next
    # body
    next = iterate(iter, state)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este es un ejemplo de cómo una interfaz bien definida permite que una implementación use todas las funciones disponibles en esta interfaz.</p>
</div>
</div>
<div class="sect2">
<h3 id="_módulo_interactive_utilities">Módulo Interactive Utilities</h3>
<div class="paragraph">
<p>Ya hemos visto el módulo <code>InteractiveUtils</code> en <a href="#interactive">Depuración</a>. La macro <code>@which</code> es solo una de las tantas opciones.
</p>
</div>
<div class="paragraph">
<p>La biblioteca LLVM transforma el código de Julia en código de máquina, en varios pasos. Podemos visualizar la salida de cada etapa.</p>
</div>
<div class="paragraph">
<p>Veamos un ejemplo simple:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">function sumacuadrada(a::Float64, b::Float64)
    a^2 + b^2
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>El primer paso es mirar el código de bajo nivel (lowered code):
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; using InteractiveUtils

julia&gt; @code_lowered sumacuadrada(3.0, 4.0)
CodeInfo(
1 ─ %1 = Core.apply_type(Base.Val, 2)
│   %2 = (%1)()
│   %3 = Base.literal_pow(:^, a, %2)
│   %4 = Core.apply_type(Base.Val, 2)
│   %5 = (%4)()
│   %6 = Base.literal_pow(:^, b, %5)
│   %7 = %3 + %6
└──      return %7
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>La macro <code>@code_lowered</code> devuelve un arreglo de una <em>representación intermedia</em> del código que utiliza el compilador para generar código optimizado.
</p>
</div>
<div class="paragraph">
<p>El siguiente paso añade información del tipo:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; @code_typed sumacuadrada(3.0, 4.0)
CodeInfo(
1 ─ %1 = Base.mul_float(a, a)::Float64
│   %2 = Base.mul_float(b, b)::Float64
│   %3 = Base.add_float(%1, %2)::Float64
└──      return %3
) =&gt; Float64</code></pre>
</div>
</div>
<div class="paragraph">
<p>El tipo de resultados intermedios y el valor de retorno se infiere correctamente.</p>
</div>
<div class="paragraph">
<p>Esta representación del código se transforma en código LLVM:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; @code_llvm sumacuadrada(3.0, 4.0)
;  @ none:2 within `sumacuadrada'
define double @julia_sumacuadrada_19234(double, double) {
top:
; ┌ @ intfuncs.jl:244 within `literal_pow'
; │┌ @ float.jl:405 within `*'
    %2 = fmul double %0, %0
    %3 = fmul double %1, %1
; └└
; ┌ @ float.jl:401 within `+'
   %4 = fadd double %2, %3
; └
  ret double %4
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Y finalmente se genera el <em>código de máquina</em>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; @code_native sumacuadrada(3.0, 4.0)
	.section	__TEXT,__text,regular,pure_instructions
; ┌ @ none:2 within `sumacuadrada'
; │┌ @ intfuncs.jl:244 within `literal_pow'
; ││┌ @ none:2 within `*'
	vmulsd	%xmm0, %xmm0, %xmm0
	vmulsd	%xmm1, %xmm1, %xmm1
; │└└
; │┌ @ float.jl:401 within `+'
	vaddsd	%xmm1, %xmm0, %xmm0
; │└
	retq
	nopl	(%rax)
; └</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_depuración_15">Depuración</h3>
<div class="paragraph">
<p>Las macros <code>Logging</code> son una alternativa al andamiaje con sentencias de impresión:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; @warn "¡Oh vosotros los que entráis, abandonad la depuración con printf!"
┌ Warning: ¡Oh vosotros los que entráis, abandonad la depuración con printf!
└ @ Main REPL[1]:1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las sentencias de depuración (debug) no tienen que eliminarse del código. Por ejemplo, en contraste con el <code>@warn</code> anterior
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-jlcon" data-lang="jlcon">julia&gt; @debug "La suma de algunos valores $(sum(rand(100)))"</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>debug</em> por defecto no produce salida. En este caso, <code>sum(rand(100))</code> nunca se evaluará a menos que <em>debug logging</em> esté habilitado.
</p>
</div>
<div class="paragraph">
<p>El nivel de logging puede seleccionarse mediante la variable de entorno <code>JULIA_DEBUG</code>:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>$ JULIA_DEBUG=all julia -e '@debug "La suma de algunos valores $(sum(rand(100)))"'
┌ Debug: La suma de algunos valores 47.116520814555024
└ @ Main none:1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aquí, hemos utilizado <code>all</code> para obtener toda la información de depuración, pero también se puede optar por generar salida solo para un archivo o módulo específico.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glosario_18">Glosario</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">regex</dt>
<dd>
<p>Expresión regular, una secuencia de caracteres que definen un patrón de búsqueda.
</p>
</dd>
<dt class="hdlist1">matriz</dt>
<dd>
<p>Arreglo bidimensional.
</p>
</dd>
<dt class="hdlist1">representación intermedia</dt>
<dd>
<p>Estructura de datos utilizada internamente por un compilador para representar el código fuente.
</p>
</dd>
<dt class="hdlist1">código de máquina</dt>
<dd>
<p>Instrucciones que pueden ser ejecutadas directamente por la unidad central de procesamiento de una computadora.
</p>
</dd>
<dt class="hdlist1">debug logging</dt>
<dd>
<p>Almacenar mensajes de depuración en un registro (log).
</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap21">21. Depuración</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Al depurar, es necesario distinguir entre los diferentes tipos de errores para rastrearlos más rápidamente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los errores de sintaxis se descubren cuando el intérprete traduce el código fuente a código de bytes. Estos errores indican que hay una falla en la estructura del programa. Por ejemplo, omitir la palabra reservada <code>end</code> al final de un bloque de funciones genera el mensaje <code>ERROR: LoadError: syntax: incomplete: function requires end</code>.
</p>
</li>
<li>
<p>Los errores en tiempo de ejecución se presentan si algo falla mientras se ejecuta el programa. La mayoría de los mensajes de error en tiempo de ejecución indican dónde ocurrió el error y qué funciones se estaban ejecutando. Ejemplo: Una recursión infinita eventualmente causa el error en tiempo de ejecución <code>ERROR: StackOverflowError</code>.
</p>
</li>
<li>
<p>Los errores semánticos ocurren cuando un programa se ejecuta sin generar mensajes de error pero no hace lo que debería. Por ejemplo: una expresión puede no evaluarse en el orden esperado, generando un resultado incorrecto.
</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El primer paso en la depuración es averiguar el tipo de error al que se enfrenta. Aunque las siguientes secciones están organizadas por tipo de error, algunas técnicas son aplicables en más de una situación.</p>
</div>
<div class="sect2">
<h3 id="_errores_de_sintaxis">Errores de Sintaxis</h3>
<div class="paragraph">
<p>Los errores de sintaxis suelen ser fáciles de corregir una vez que se descubre cuáles son. Desafortunadamente, muchas veces los mensajes de error no son útiles. Los mensajes más comunes son <code>ERROR: LoadError: syntax: incomplete: premature end of input</code> y <code>ERROR: LoadError: syntax: unexpected "="</code>, los cuales no son muy informativos.</p>
</div>
<div class="paragraph">
<p>Por otro lado, el mensaje indica en qué parte del programa se produjo el problema. En realidad, indica dónde Julia notó que había un problema, que no es necesariamente dónde está el error. A veces, el error es anterior a la ubicación del mensaje de error, generalmente en la línea anterior.</p>
</div>
<div class="paragraph">
<p>Si está programando incrementalmente, debería tener casi localizado el error. Estará en la última línea que agregó.</p>
</div>
<div class="paragraph">
<p>Si está copiando código de un libro, comience comparando su código con el código del libro. Verifique cada letra. Al mismo tiempo, recuerde que el libro puede contener errores, por lo que si ve algo que parece un error de sintaxis, es posible que lo sea.</p>
</div>
<div class="paragraph">
<p>Aquí hay algunas formas de evitar los errores de sintaxis más comunes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Asegúrese de no estar usando una palabra reservada de Julia en un nombre de variable.</p>
</li>
<li>
<p>Compruebe que tiene la palabra reservada <code>end</code> al final de cada sentencia compuesta, incluyendo los bloques <code>for</code>, <code>while</code>, <code>if</code> y <code>function</code>.</p>
</li>
<li>
<p>Asegúrese de que las cadenas tengan su par de comillas de apertura y cierre. Asegúrese de que todas las comillas sean "comillas rectas", y no otro tipo de "comillas".</p>
</li>
<li>
<p>Si tiene cadenas que ocupan varias líneas con triples comillas, asegúrese de que ha terminado la cadena correctamente. Una cadena sin terminar puede provocar un error invalid token al final de su programa, o puede hacer que la siguiente parte del programa sea tratada como una cadena hasta llegar a la siguiente cadena. ¡El segundo caso podría no presentar mensaje de error!</p>
</li>
<li>
<p>Un paréntesis sin cerrar —<code>(</code>, <code>{</code>, or <code>[</code>— hace que Julia continúe con la línea siguiente como parte de la sentencia actual. Generalmente, se produce un error casi inmediatamente en la siguiente línea.</p>
</li>
<li>
<p>Verifique el clásico error que se produce al ocupar <code>=</code> en lugar de <code>==</code> dentro de un condicional.</p>
</li>
<li>
<p>Si tiene caracteres que no son ASCII en el código (incluidas cadenas y comentarios), esto podría causar un problema, aunque Julia generalmente maneja caracteres no ASCII. Tenga cuidado si pega texto de una página web u otra fuente.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Si nada funciona, pase a la siguiente sección &#8230;&#8203;</p>
</div>
<div class="sect3">
<h4 id="_sigo_haciendo_cambios_y_no_hay_diferencia">Sigo haciendo cambios y no hay diferencia</h4>
<div class="paragraph">
<p>Si el REPL dice que hay un error y usted no lo ve, podría deberse a que usted y el REPL no están viendo el mismo código. Verifique su entorno de programación para asegurarse de que el programa que está editando es el que Julia está tratando de ejecutar.</p>
</div>
<div class="paragraph">
<p>Si no está seguro, intente poner un error de sintaxis obvio y deliberado al comienzo del programa. Ahora ejecútelo de nuevo. Si REPL no encuentra el nuevo error, no está ejecutando el nuevo código.</p>
</div>
<div class="paragraph">
<p>Estas son algunas de las posibles razones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Editó el archivo y olvidó guardar los cambios antes de ejecutarlo nuevamente. Algunos entornos de programación hacen esto por usted, pero otros no.</p>
</li>
<li>
<p>Cambió el nombre del archivo, pero aún está ejecutando el archivo con el nombre anterior.</p>
</li>
<li>
<p>Algo en su entorno de desarrollo está configurado incorrectamente.</p>
</li>
<li>
<p>Si está escribiendo un módulo y está usando <code>using</code>, asegúrese de no darle a su módulo el mismo nombre que uno de los módulos estándar de Julia.</p>
</li>
<li>
<p>Si está usando <code>using</code> para importar un módulo, recuerde que debe reiniciar REPL cuando modifique el código en el módulo. Si vuelve a importar el módulo, no ocurre nada.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Si se queda atascado y no puede darse cuenta de lo que está sucediendo, un enfoque es comenzar de nuevo con un nuevo programa como "¡Hola, Mundo!" y asegurarse de que puede ejecutar este programa ya conocido. Luego, puede agregar gradualmente las piezas del programa original al nuevo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_errores_en_tiempo_de_ejecución">Errores en Tiempo de Ejecución</h3>
<div class="paragraph">
<p>Una vez que su programa es sintácticamente correcto, Julia puede leerlo y al menos comenzar a ejecutarlo. ¿Qué podría salir mal?</p>
</div>
<div class="sect3">
<h4 id="_mi_programa_no_hace_absolutamente_nada">Mi programa no hace absolutamente nada</h4>
<div class="paragraph">
<p>Este problema es común cuando su archivo consta de funciones y clases, pero en realidad no llama a ninguna función para iniciar la ejecución. Esto puede ser intencional si solo se busca importar este módulo para suministrar clases y funciones.</p>
</div>
<div class="paragraph">
<p>Si no es intencional, asegúrese de que haya una llamada a la función en el programa, y asegúrese de que el flujo de ejecución pase por esta llamada (vea <a href="#flow_of_execution">Flujo de Ejecución</a>).
</p>
</div>
</div>
<div class="sect3">
<h4 id="_mi_programa_se_congela">Mi programa se congela</h4>
<div class="paragraph">
<p>Si un programa se detiene y parece no estar haciendo nada, está "congelado". Generalmente eso significa que está atrapado en un bucle infinito o en una recursión infinita.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si hay un bucle en particular que le resulta sospechoso de provocar el pproblema, agregue una sentencia de impresión justo antes del bucle que diga "entrando al bucle" y otra inmediatamente posterior que diga "saliendo del bucle".</p>
<div class="paragraph">
<p>Ejecute el programa. Si recibe el primer mensaje y no el segundo, tiene un bucle infinito. Vea <a href="#infinite_loop">Bucle Infinito</a>.
</p>
</div>
</li>
<li>
<p>La mayoría de las veces, una recursión infinita hará que el programa se ejecute por un rato y luego produzca un error <code>ERROR: LoadError: StackOverflowError</code>. Si eso sucede, vea <a href="#infinite_recursion">Recursión Infinita</a>.</p>
<div class="paragraph">
<p>Si no obtiene este error pero sospecha que hay un problema con un método o función recursiva, igual puede utilizar las técnicas de <a href="#infinite_recursion">Recursión Infinita</a>.
</p>
</div>
</li>
<li>
<p>Si ninguno de esos pasos funciona, comience a probar otros bucles, y otras funciones y métodos recursivos.</p>
</li>
<li>
<p>Si esto no funciona, quizás es porque no entiendes el flujo de ejecución de tu programa. Vea <a href="#flow_of_execution">Flujo de Ejecución</a>.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="infinite_loop">Bucle Infinito</h5>
<div class="paragraph">
<p>Si crees tener un bucle infinito y crees saber cuál es, añade una sentencia de impresión que imprima los valores de las variables de la condición al final del bucle junto con el valor de la condición.</p>
</div>
<div class="paragraph">
<p>Por ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">while x &gt; 0 &amp;&amp; y &lt; 0
    # hacer algo con x
    # hacer algo con y
    @debug "variables" x y
    @debug "condicion" x &gt; 0 &amp;&amp; y &lt; 0
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora, cuando ejecute el programa en modo de depuración, verá el valor de las variables y la condición en cada iteración. En la última iteración, la condición debe ser <code>false</code>. Si el ciclo continúa, podrá ver los valores de <code>x</code> e <code>y</code>, y podrá averiguar por qué no
se actualizan correctamente.</p>
</div>
</div>
<div class="sect4">
<h5 id="infinite_recursion">Recursión Infinita</h5>
<div class="paragraph">
<p>La mayoría de las veces, una recursión infinita hace que el programa se ejecute durante un tiempo y luego produzca un error <code>ERROR: LoadError: StackOverflowError</code>.
</p>
</div>
<div class="paragraph">
<p>Si sospecha que una función o un método está causando una recursión infinita, comience por asegurarse de que hay un caso base. En otras palabras, debería haber una condición que haga que la función devuelva un valor sin hacer otra llamada recursiva. Si no, necesita revisar el algoritmo y encontrar ese caso base.</p>
</div>
<div class="paragraph">
<p>Si hay un caso base pero el programa no parece llegar hasta él, añada una sentencia de impresión al inicio de la función que imprima los parámetros. Ahora, cuando ejecute el programa, verá el valor de los parámetros cada vez que se llame la función. Si los parámetros no se acercan al caso base, eso le dará alguna idea de por qué no lo hace.</p>
</div>
</div>
<div class="sect4">
<h5 id="flow_of_execution">Flujo de Ejecución</h5>
<div class="paragraph">
<p>Si no está seguro del flujo de ejecución en su programa, añada sentencias de impresión al principio de cada función con mensajes como “entrando a la función fun”, donde fun sea el nombre de la función.</p>
</div>
<div class="paragraph">
<p>Ahora, cuando ejecute el programa, se imprimirá una mensaje en cada función a medida que estas sean llamadas.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cuando_ejecuto_el_programa_recibo_una_excepción">Cuando ejecuto el programa recibo una excepción.</h4>
<div class="paragraph">
<p>Si algo sale mal durante la ejecución, Julia imprime un mensaje que incluye el nombre de la excepción, la línea del programa donde sucedió el problema y un trazado inverso.</p>
</div>
<div class="paragraph">
<p>El trazado inverso identifica la función que se está ejecutando y la función que la llamó, y luego la función que llamó a esa, y así sucesivamente. En otras palabras, traza la ruta de las llamadas a las funciones que le llevaron a donde se encuentra. También incluye los numeros de las líneas de su archivo donde suceden todas esas llamadas.</p>
</div>
<div class="paragraph">
<p>El primer paso es examinar el lugar del programa donde ocurrió el error y ver si puede adivinar lo que sucedió. Estos son algunos de los errores en tiempo de ejecución más comunes:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">ArgumentError</dt>
<dd>
<p>Uno de los argumentos para llamar a una función no tiene la forma esperada.
</p>
</dd>
<dt class="hdlist1">BoundsError</dt>
<dd>
<p>Se está tratando de acceder a un elemento de un arreglo fuera de los límites de indexación.
</p>
</dd>
<dt class="hdlist1">DomainError</dt>
<dd>
<p>El argumento de una función o constructor no pertenece al dominio válido.
</p>
</dd>
<dt class="hdlist1">DivideError</dt>
<dd>
<p>Se intentó dividir un entero por 0.
</p>
</dd>
<dt class="hdlist1">EOFError</dt>
<dd>
<p>No había más datos disponibles para leer desde un archivo o stream.
</p>
</dd>
<dt class="hdlist1">InexactError</dt>
<dd>
<p>No se puede convertir a un tipo.
</p>
</dd>
<dt class="hdlist1">KeyError</dt>
<dd>
<p>Se está tratando de acceder o eliminar un elemento inexistente de un objeto <code>AbstractDict</code> (<code>Dict</code>) o <code>Set</code>.
</p>
</dd>
<dt class="hdlist1">MethodError</dt>
<dd>
<p>No existe un método con la especificación de tipo requerida en la función genérica dada. Alternativamente, no existe un método único más específico.
</p>
</dd>
<dt class="hdlist1">OutOfMemoryError</dt>
<dd>
<p>Una operación asignó demasiada memoria para que el sistema o el recolector de basura opere correctamente.
</p>
</dd>
<dt class="hdlist1">OverflowError</dt>
<dd>
<p>El resultado de una expresión es demasiado grande para el tipo especificado y se produce un desbordamiento.
</p>
</dd>
<dt class="hdlist1">StackOverflowError</dt>
<dd>
<p>Una llamada a función trata de usar más espacio que el que está disponible en la pila de llamadas. Esto generalmente ocurre cuando una llamada se repite infinitamente.
</p>
</dd>
<dt class="hdlist1">StringIndexError</dt>
<dd>
<p>Se produjo un error al intentar acceder a un índice inválido de una cadena.
</p>
</dd>
<dt class="hdlist1">SystemError</dt>
<dd>
<p>Falló una llamada al sistema, y se muestra un mensaje de error.
</p>
</dd>
<dt class="hdlist1">TypeError</dt>
<dd>
<p>Error de aserción de tipo, o error producido al llamar a una función integrada con un tipo de argumento incorrecto.
</p>
</dd>
<dt class="hdlist1">UndefVarError</dt>
<dd>
<p>Un símbolo en el entorno (o ámbito) actual no está definido.
</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_puse_tantas_sentencias_de_impresión_que_me_ahogo_en_información">Puse tantas sentencias de impresión que me ahogo en información</h4>
<div class="paragraph">
<p>Uno de los problemas de usar sentencias print en la depuración es que puede terminar ahogado por tanta información. Hay dos formas de resolver esto: simplificar la salida o simplificar el programa.</p>
</div>
<div class="paragraph">
<p>Para simplificar la salida, puede eliminar o comentar (convertir en comentarios) las sentencias print que no sean útiles, o combinarlas, o dar a la salida un formato que la haga más comprensible.</p>
</div>
<div class="paragraph">
<p>Para simplificar el programa puede hacer varias cosas. Primero, reducir la escala del problema en el que está trabajando el programa. Por ejemplo, si está buscando algo en una lista, búsquelo en una lista pequeña. Si el programa acepta entradas del usuario, ingrese la entrada más simple que provoque el problema.</p>
</div>
<div class="paragraph">
<p>Segundo, "limpie" el programa. Elimine el código muerto y reorganice el programa para hacerlo tan legible como sea posible. Por ejemplo, si sospecha que el problema está en una parte del programa con un anidamiento muy profundo, pruebe a reescribir esa parte con una estructura más simple. Si sospecha de una función muy larga, trate de dividirla en funciones más pequeñas y pruébelas separadamente.
</p>
</div>
<div class="paragraph">
<p>Generalmente, el proceso de encontrar el caso de prueba mínimo te lleva al error. Si encuentra que un programa funciona en una situación pero no en otra, eso le dará una pista sobre lo que está sucediendo.</p>
</div>
<div class="paragraph">
<p>De forma parecida, reescribir una porción de código puede ayudarle a encontrar errores sutiles. Si realiza un cambio que cree que no debería afectar el programa, pero lo hace, entonces eso puede darle una pista.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_errores_semánticos">Errores Semánticos</h3>
<div class="paragraph">
<p>En cierto modo, los errores semánticos son los más difíciles de corregir, ya que el intérprete no entrega información sobre lo
que está mal. Sólo usted sabe lo que se supone que debe hacer el programa.</p>
</div>
<div class="paragraph">
<p>El primer paso es hacer una conexión entre el código y el comportamiento que está viendo. Necesita una hipótesis sobre lo que realmente
está haciendo el programa. Una de las dificultades que nos encontramos para ello es la alta velocidad de los computadores.</p>
</div>
<div class="paragraph">
<p>A menudo desearía ralentizar el programa a una velocidad humana. El tiempo que lleva colocar unas sentencias print en los lugares adecuados suele ser menor que el que lleva configurar un depurador, poner y quitar puntos de interrupción, y “hacer avanzar” al programa hasta donde se produce el error.</p>
</div>
<div class="sect3">
<h4 id="_mi_programa_no_funciona">Mi programa no funciona</h4>
<div class="paragraph">
<p>Debería hacerse estas preguntas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>¿Hay algo que se supone que debería hacer el programa pero que no sucede? Busque la sección del código que realiza esa función y asegúrese de que se ejecuta cuando debería.</p>
</li>
<li>
<p>¿Ocurre algo que no debería? Busque el código en su programa que realiza esa función y vea si se ejecuta cuando no debe.</p>
</li>
<li>
<p>¿Hay alguna sección del código que cause un efecto que no esperaba? asegurese de que entiende el código en cuestión, especialmente si incluye funciones o métodos de otros módulos de Julia. Lea la documentación de las funciones a las que llama. Pruébelas escribiendo casos de prueba simples y comprobando sus resultados.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para programar necesitará tener un modelo mental de cómo funcionan los programas. Si escribe un programa que no hace lo que esperaba de él, muchas veces el problema no estará en el programa, sino en su modelo mental.
</p>
</div>
<div class="paragraph">
<p>La mejor manera de corregir su modelo mental es dividiendo el programa en sus componentes (normalmente en funciones y métodos) y probando cada componente de forma independiente. Una vez que encuentre la discrepancia entre su modelo y la realidad, podrá solucionar el problema.</p>
</div>
<div class="paragraph">
<p>Por supuesto, debería ir haciendo y probando componentes a medida que desarrolla el programa. Si encuentra un problema, sólo habría que revisar una pequeña cantidad de código nuevo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tengo_una_expresión_grande_y_peliaguda_y_no_hace_lo_que_espero">Tengo una expresión grande y peliaguda y no hace lo que espero.</h4>
<div class="paragraph">
<p>Está bien escribir expresiones complejas mientras sean legibles, pero pueden ser difíciles de depurar. Suele ser una buena idea dividir una expresión compleja en una serie de asignaciones de variables temporales.</p>
</div>
<div class="paragraph">
<p>Por ejamplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">agregarcarta(juego.manos[i], sacarcarta(juego.manos[encontrarvecino(juego, i)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puede reescribirse como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">vecino = encontrarvecino(juego, i)
cartaseleccionada = sacarcarta(juego.manos[vecino])
agregarcarta(juego.manos[i], cartaseleccionada)</code></pre>
</div>
</div>
<div class="paragraph">
<p>La versión explícita es más fácil de leer porque los nombres de variables nos entregan documentación adicional, y es más fácil de depurar porque se pueden comprobar los tipos de las variables intermedias y mostrar sus valores.</p>
</div>
<div class="paragraph">
<p>Otro problema que puede suceder con las expresiones grandes es que el orden de evaluación puede no ser el que usted esperaba. Por ejemplo, si está traduciendo la expresión \(\frac{x}{2\pi}\) a Julia, podría escribir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">y = x / 2 * π</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto no es correcto, ya que la multiplicación y la división tienen la misma precedencia, y se evalúan de izquierda a derecha. Así que esa expresión calcula \(\frac{x\pi}{2}\).</p>
</div>
<div class="paragraph">
<p>Una buena forma de depurar expresiones es añadir paréntesis para que sea explícito el orden de evaluación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">y = x / (2 * π)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Siempre que no esté seguro del orden de evaluación, utilice paréntesis. El programa no sólo será correcto (en el sentido de que hace lo que usted quiere), sino que además será más legible para otras personas que no hayan memorizado las reglas de precedencia.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tengo_una_función_que_no_devuelve_lo_que_esperaba">Tengo una función que no devuelve lo que esperaba.</h4>
<div class="paragraph">
<p>Si tiene una sentencia return con una expresión compleja, no tendrá la oportunidad de imprimir el valor de retorno antes de retornar. De nuevo, puede usar una variable temporal. Por ejemplo, en lugar de:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">return sacarpares(juego.manos[i])</code></pre>
</div>
</div>
<div class="paragraph">
<p>podría escribir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-julia" data-lang="julia">contar = sacarpares(juego.manos[i])
return contar</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora ya tiene la oportunidad de mostrar el valor de <code>count</code> antes de retornar.</p>
</div>
</div>
<div class="sect3">
<h4 id="_estoy_atascado_de_verdad_y_necesito_ayuda">Estoy atascado de verdad y necesito ayuda.</h4>
<div class="paragraph">
<p>Primero, intente alejarse del computador durante unos minutos. Trabajar con un computador puede provocar estos efectos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Frustración y/o furia.</p>
</li>
<li>
<p>Creencias supersticiosas (“el computador me odia”) y pensamiento mágico (“el programa sólo funciona cuando me pongo el gorro hacia atrás”).</p>
</li>
<li>
<p>Programar dando palos de ciego (el empeño de programar escribiendo todos los programas posibles y eligiendo el que hace lo correcto).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Si se encuentra afectado por alguno de estos síntomas, levántese y dé un paseo. Cuando esté calmado, piense en el programa. ¿Qué es lo que hace? ¿Cuáles pueden ser las causas de tal comportamiento? ¿Cuándo fue la última vez que su programa funcionaba y qué fue lo siguiente que hizo?</p>
</div>
<div class="paragraph">
<p>A veces lleva tiempo encontrar un error. Muchas veces encontramos errores cuando estamos lejos del computador y divagamos. Algunos de los mejores lugares para encontrar errores son los trenes, las duchas y la cama, justo antes de quedarse dormido.</p>
</div>
</div>
<div class="sect3">
<h4 id="_no_de_verdad_necesito_ayuda">No, de verdad necesito ayuda</h4>
<div class="paragraph">
<p>Sucede. Incluso los mejores programadores se atascan de vez en cuando. A veces trabaja durante tanto tiempo en un programa que no puede ver el error. Lo que necesita es un par de ojos nuevos.</p>
</div>
<div class="paragraph">
<p>Antes de llamar a alguien, asegúrese de estar preparado. Su programa debería ser tan simple como sea posible, y usted debería estar
trabajando con la entrada mínima que provoca el error. Debería tener sentencias print en los lugares adecuados (y lo que dicen debería ser comprensible). Debería entender el problema lo bastante bien como para describirlo de manera concisa.</p>
</div>
<div class="paragraph">
<p>Cuando llame a alguien para que le ayude, asegúrese de darles la información que necesitan:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si hay un mensaje de error, ¿cuál es y qué parte del programa señala?</p>
</li>
<li>
<p>¿Qué fue lo último que hizo antes de que apareciera el error? ¿Cuáles son las últimas líneas de cúdigo que escribió, o cuál es el nuevo caso de prueba que falla?</p>
</li>
<li>
<p>¿Qué ha intentado hasta ahora y qué ha averiguado?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cuando encuentre el error, tómese un momento para pensar acerca de lo que podría haber hecho para encontrarlo más rápido. La siguiente vez que vea algo parecido, será capaz de encontrar el error antes.</p>
</div>
<div class="paragraph">
<p>Recuerde, el objetivo no es solo hacer que el programa funcione. El objetivo es aprender cómo hacer funcionar el programa.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_entrada_de_unicode">Apéndice A: Entrada de Unicode</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La siguiente tabla muestra algunos de los muchos carácteres Unicode que pueden ingresarse mediante abreviaciones similares a aquellas utilizadas en Latex, en el REPL de Julia (y en muchos otros entornos de edición).
</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Carácter</th>
<th class="tableblock halign-left valign-top">Tab completion sequence</th>
<th class="tableblock halign-left valign-top">representaciónASCII</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>²</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\^2</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>₁</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\_1</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>₂</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\_2</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>🍎</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\:apple:</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>🍌</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\:banana:</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>🐫</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\:camel:</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>🍐</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\:pear:</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>🐢</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\:turtle:</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>∩</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\cap</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>≡</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\equiv</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>===</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ℯ</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\euler</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>∈</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\in</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>in</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>≥</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\ge</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;=</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>≤</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\le</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;=</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>≠</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\ne</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!=</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>∉</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\notin</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>π</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\pi</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pi</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>⊆</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\subseteq</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ε</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>\varepsilon</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="juliabox">Apéndice B: JuliaBox</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JuliaBox permite ejecutar Julia en su navegador. Ingrese a la página <a href="https://www.juliabox.com" class="bare">https://www.juliabox.com</a>, inicie sesión y comience a usar el entorno Jupyter.</p>
</div>
<div class="paragraph">
<p>La pantalla inicial se muestra en <a href="#figb-1">Initial screen</a>. El botón "new" (nuevo) permite la creación de un notebook de Julia, un archivo de texto (text file), una carpeta (folder) o una sesión de terminal (terminal session).</p>
</div>
<div class="paragraph">
<p>En una sesión de terminal, el comando <strong><code>julia</code></strong> inicia REPL como se muestra en <a href="#figb-2">Terminal session</a>.</p>
</div>
<div class="paragraph">
<p>La interfaz del notebook permite mezclar texto (en modo Markdown) y código con su respectiva salida. <a href="#figb-3">Notebook</a> muestra un ejemplo.</p>
</div>
<div class="paragraph">
<p>Puedes encontrar más documentación en el sitio web de Jupyter: <a href="http://jupyter.org/documentation" class="bare">http://jupyter.org/documentation</a>.</p>
</div>
<div id="figb-1" class="imageblock">
<div class="content">
<img src="images/screenshot0.png" alt="screenshot0">
</div>
<div class="title">Figura 25. Initial screen</div>
</div>
<div id="figb-2" class="imageblock">
<div class="content">
<img src="images/screenshot1.png" alt="screenshot1">
</div>
<div class="title">Figura 26. Terminal session</div>
</div>
<div id="figb-3" class="imageblock">
<div class="content">
<img src="images/screenshot2.png" alt="screenshot2">
</div>
<div class="title">Figura 27. Notebook</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cambios">Apéndice C: Cambios de ThinkJulia</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este libro es una traducción de <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html">ThinkJulia</a>, que está disponible bajo la <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.es">Licencia Creative Commons Atribución-NoComercial 3.0 No portada</a>. Esta licencia requiere que los trabajos derivados (como este libro) enumeren los cambios que se hicieron en el trabajo derivado en comparación con la fuente.</p>
</div>
<div class="paragraph">
<p>Las diferencias en este libro de ThinkJulia incluyen lo siguiente:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Traducción del inglés al español.</p>
</li>
<li>
<p>Se cambiaron muchas frases idiomáticas que no serán familiares para los lectores en español ("Se cayó el centavo").</p>
</li>
<li>
<p>En lugar de usar el texto de la novela "Emma" en el Capítulo 13, se usa el texto de "DonQuijote".</p>
</li>
<li>
<p>Debido a que O&#8217;Reilly no financió la traducción y no ha hecho planes para un libro impreso, hemos eliminado algunas de las referencias a O&#8217;Reilly en el prefacio.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_index">Index</h2>
<div class="sectionbody">

</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Reeves, Byron, and Clifford Ivar Nass. 1996. “The Media Equation: How People Treat Computers, Television, and New Media Like Real People and Places.” Chicago, IL: Center for the Study of Language and Information; New York: Cambridge University Press.
</div>
</div>
<div id="footer">
<div id="footer-text">
Ultima actualización 2020-02-18 13:04:47 -0800
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>